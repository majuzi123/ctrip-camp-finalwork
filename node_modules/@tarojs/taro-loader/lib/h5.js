"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("@tarojs/helper");
const loader_utils_1 = require("loader-utils");
const path_1 = require("path");
const constants_1 = require("./constants");
function genResource(path, pages, loaderContext, syncFileName = false) {
    const stringify = (s) => (0, loader_utils_1.stringifyRequest)(loaderContext, s);
    const importDependent = syncFileName ? 'require' : 'import';
    return `Object.assign({
  path: '${path}',
  load: function(context, params) {
    const page = ${importDependent}(${stringify((0, path_1.join)(loaderContext.context, syncFileName || path))})
    return [page, context, params]
  }
}, ${JSON.stringify((0, helper_1.readConfig)(pages.get(path)))})`;
}
function default_1() {
    var _a, _b, _c;
    const options = (0, loader_utils_1.getOptions)(this);
    const stringify = (s) => (0, loader_utils_1.stringifyRequest)(this, s);
    const { frameworkArgs, creator, creatorLocation, importFrameworkStatement, importFrameworkName, extraImportForWeb, execBeforeCreateWebApp } = options.loaderMeta;
    const config = options.config;
    const pages = options.pages;
    const routerMode = ((_a = config === null || config === void 0 ? void 0 : config.router) === null || _a === void 0 ? void 0 : _a.mode) || 'hash';
    const isMultiRouterMode = routerMode === 'multi';
    const pxTransformConfig = options.pxTransformConfig;
    const pathDirname = (0, path_1.dirname)(this.resourcePath);
    const pageName = isMultiRouterMode ? (0, path_1.join)(pathDirname, options.filename).replace(options.sourceDir + '/', '') : '';
    if (options.bootstrap) {
        /** NOTE: Webpack Virtual Module plugin doesn't support triggering a rebuild for webpack5,
         * which can cause "module not found" error when webpack5 cache is enabled.
         * Currently the only "non-hacky" workaround is to mark this module as non-cacheable.
         *
         * See also:
         *   - https://github.com/sysgears/webpack-virtual-modules/issues/76
         *   - https://github.com/sysgears/webpack-virtual-modules/issues/86
         *   - https://github.com/windicss/windicss-webpack-plugin/blob/bbb91323a2a0c0f880eecdf49b831be092ccf511/src/loaders/virtual-module.ts
         *   - https://github.com/sveltejs/svelte-loader/pull/151
         */
        (_b = this.cacheable) === null || _b === void 0 ? void 0 : _b.call(this, false);
    }
    if (options.bootstrap)
        return `import(${stringify((0, path_1.join)(options.sourceDir, `${isMultiRouterMode ? pageName : options.entryFileName}.boot`))})`;
    let tabBarCode = `var tabbarIconPath = []
var tabbarSelectedIconPath = []
`;
    if (config.tabBar) {
        const tabbarList = config.tabBar.list;
        for (let i = 0; i < tabbarList.length; i++) {
            const t = tabbarList[i];
            if (t.iconPath) {
                const iconPath = stringify((0, path_1.join)(pathDirname, t.iconPath));
                tabBarCode += `tabbarIconPath[${i}] = typeof require(${iconPath}) === 'object' ? require(${iconPath}).default : require(${iconPath})\n`;
            }
            if (t.selectedIconPath) {
                const iconPath = stringify((0, path_1.join)(pathDirname, t.selectedIconPath));
                tabBarCode += `tabbarSelectedIconPath[${i}] = typeof require(${iconPath}) === 'object' ? require(${iconPath}).default : require(${iconPath})\n`;
            }
        }
    }
    const runtimePath = Array.isArray(options.runtimePath) ? options.runtimePath : [options.runtimePath];
    let setReconcilerPost = '';
    const setReconciler = runtimePath.reduce((res, item) => {
        if (constants_1.REG_POST.test(item)) {
            setReconcilerPost += `import '${item.replace(constants_1.REG_POST, '')}'\n`;
            return res;
        }
        else {
            return res + `import '${item}'\n`;
        }
    }, '');
    const routesConfig = isMultiRouterMode ? `config.routes = []
config.route = ${genResource(pageName, pages, this, options.filename)}
config.pageName = "${pageName}"` : `config.routes = [
  ${(_c = config.pages) === null || _c === void 0 ? void 0 : _c.map(path => genResource(path, pages, this)).join(',')}
]`;
    const routerCreator = isMultiRouterMode ? 'createMultiRouter' : 'createRouter';
    const code = `${setReconciler}
import { initPxTransform } from '@tarojs/taro'
import { ${routerCreator} } from '@tarojs/router'
import component from ${stringify((0, path_1.join)(options.sourceDir, options.entryFileName))}
import { window } from '@tarojs/runtime'
import { ${creator} } from '${creatorLocation}'
${importFrameworkStatement}
${extraImportForWeb}
${setReconcilerPost}
var config = ${JSON.stringify(config)}
window.__taroAppConfig = config
${config.tabBar ? tabBarCode : ''}
if (config.tabBar) {
  var tabbarList = config.tabBar.list
  for (var i = 0; i < tabbarList.length; i++) {
    var t = tabbarList[i]
    if (t.iconPath) {
      t.iconPath = tabbarIconPath[i]
    }
    if (t.selectedIconPath) {
      t.selectedIconPath = tabbarSelectedIconPath[i]
    }
  }
}
${routesConfig}
${execBeforeCreateWebApp || ''}
var inst = ${creator}(component, ${frameworkArgs})
${routerCreator}(inst, config, ${importFrameworkName})
initPxTransform({
  designWidth: ${pxTransformConfig.designWidth},
  deviceRatio: ${JSON.stringify(pxTransformConfig.deviceRatio)},
  baseFontSize: ${pxTransformConfig.baseFontSize || (pxTransformConfig.minRootSize >= 1 ? pxTransformConfig.minRootSize : 20)}
})
`;
    return code;
}
exports.default = default_1;
//# sourceMappingURL=h5.js.map