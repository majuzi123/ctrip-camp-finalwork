"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.H5Combination = void 0;
const helper_1 = require("@tarojs/helper");
const path_1 = __importDefault(require("path"));
const utils_1 = require("../utils");
const H5AppInstance_1 = __importDefault(require("../utils/H5AppInstance"));
const Combination_1 = require("./Combination");
const H5BaseConfig_1 = require("./H5BaseConfig");
const H5WebpackModule_1 = require("./H5WebpackModule");
const H5WebpackPlugin_1 = require("./H5WebpackPlugin");
class H5Combination extends Combination_1.Combination {
    constructor() {
        super(...arguments);
        this.webpackPlugin = new H5WebpackPlugin_1.H5WebpackPlugin(this);
        this.webpackModule = new H5WebpackModule_1.H5WebpackModule(this);
    }
    process(config) {
        var _a;
        const baseConfig = new H5BaseConfig_1.H5BaseConfig(this.appPath, config);
        const chain = this.chain = baseConfig.chain;
        const { entry = {}, output = {}, entryFileName = 'app', mode = 'production', sourceMapType = 'eval-cheap-module-source-map', publicPath = '/', chunkDirectory = 'chunk', alias = {}, router, frameworkExts } = config;
        const routerMode = (router === null || router === void 0 ? void 0 : router.mode) || 'hash';
        const isMultiRouterMode = routerMode === 'multi';
        this.inst = new H5AppInstance_1.default(entry, {
            sourceDir: this.sourceDir,
            frameworkExts,
            entryFileName
        });
        if (isMultiRouterMode) {
            delete entry[entryFileName];
            this.inst.pagesConfigList.forEach((page, index) => {
                entry[index] = [page];
            });
        }
        const webpackOutput = this.getOutput({
            publicPath,
            chunkDirectory,
            customOutput: output,
            entryFileName
        });
        const module = this.webpackModule.getModules();
        const [, pxtransformOption] = this.webpackModule.__postcssOption.find(([name]) => name === 'postcss-pxtransform') || [];
        if (isMultiRouterMode) {
            this.webpackPlugin.pages = (_a = this.inst.appConfig) === null || _a === void 0 ? void 0 : _a.pages;
        }
        this.webpackPlugin.pxtransformOption = pxtransformOption;
        const plugin = this.webpackPlugin.getPlugins();
        chain.merge({
            entry,
            output: webpackOutput,
            mode,
            devtool: this.getDevtool(sourceMapType),
            resolve: { alias },
            plugin,
            module,
            optimization: this.getOptimization(mode)
        });
    }
    getOutput({ publicPath = '/', chunkDirectory, customOutput = {}, entryFileName = 'app' }) {
        const filename = (chunk) => chunk.runtime === entryFileName ? 'js/[name].js' : '[name].js';
        return Object.assign({ path: this.outputDir, filename, chunkFilename: `${chunkDirectory}/[name].js`, publicPath: (0, utils_1.parsePublicPath)(publicPath) }, customOutput);
    }
    getOptimization(nodeEnv) {
        const isProd = nodeEnv === 'production';
        const cacheGroups = {
            default: false,
            defaultVendors: false,
            common: {
                name: isProd ? false : 'common',
                minChunks: 2,
                priority: 1
            },
            vendors: {
                name: isProd ? false : 'vendors',
                minChunks: 2,
                test: (module) => /[\\/]node_modules[\\/]/.test(module.resource),
                priority: 10
            },
            taro: {
                name: isProd ? false : 'taro',
                test: (module) => /@tarojs[\\/][a-z]+/.test(module.context),
                priority: 100
            }
        };
        const optimization = {
            nodeEnv,
            chunkIds: isProd ? 'deterministic' : 'named',
            removeEmptyChunks: true,
            splitChunks: {
                chunks: 'initial',
                hidePathInfo: true,
                minSize: 0,
                cacheGroups
            }
        };
        if (!isProd) {
            cacheGroups.name = false;
            optimization.runtimeChunk = 'single';
        }
        return optimization;
    }
    getConfigFilePath(filePath = '') {
        return (0, helper_1.resolveMainFilePath)(`${filePath.replace(path_1.default.extname(filePath), '')}.config`);
    }
    getPagesConfigList(pages = []) {
        const pageMap = new Map();
        pages.forEach((page) => pageMap.set(page, this.getConfigFilePath(path_1.default.join(this.sourceDir, page))));
        return pageMap;
    }
}
exports.H5Combination = H5Combination;
//# sourceMappingURL=H5Combination.js.map