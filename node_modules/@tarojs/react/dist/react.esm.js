import { isString, isObject, isFunction, capitalize, toCamelCase, internalComponents, isNumber, noop, isUndefined, isBoolean, ensure } from '@tarojs/shared';
import { FormElement, document } from '@tarojs/runtime';
import Reconciler from 'react-reconciler';
import { DefaultEventPriority } from 'react-reconciler/constants';

function isEventName(s) {
    return s[0] === 'o' && s[1] === 'n';
}
const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function updateProps(dom, oldProps, newProps) {
    const updatePayload = getUpdatePayload(dom, oldProps, newProps);
    if (updatePayload) {
        updatePropsByPayload(dom, oldProps, updatePayload);
    }
}
function updatePropsByPayload(dom, oldProps, updatePayload) {
    for (let i = 0; i < updatePayload.length; i += 2) { // key, value 成对出现
        const key = updatePayload[i];
        const newProp = updatePayload[i + 1];
        const oldProp = oldProps[key];
        setProperty(dom, key, newProp, oldProp);
    }
}
function getUpdatePayload(dom, oldProps, newProps) {
    let i;
    let updatePayload = null;
    for (i in oldProps) {
        if (!(i in newProps)) {
            (updatePayload = updatePayload || []).push(i, null);
        }
    }
    const isFormElement = dom instanceof FormElement;
    for (i in newProps) {
        if (oldProps[i] !== newProps[i] || (isFormElement && i === 'value')) {
            (updatePayload = updatePayload || []).push(i, newProps[i]);
        }
    }
    return updatePayload;
}
// function eventProxy (e: CommonEvent) {
//   const el = document.getElementById(e.currentTarget.id)
//   const handlers = el!.__handlers[e.type]
//   handlers[0](e)
// }
function setEvent(dom, name, value, oldValue) {
    const isCapture = name.endsWith('Capture');
    let eventName = name.toLowerCase().slice(2);
    if (isCapture) {
        eventName = eventName.slice(0, -7);
    }
    const compName = capitalize(toCamelCase(dom.tagName.toLowerCase()));
    if (eventName === 'click' && compName in internalComponents) {
        eventName = 'tap';
    }
    if (isFunction(value)) {
        if (oldValue) {
            dom.removeEventListener(eventName, oldValue, false);
            dom.addEventListener(eventName, value, { isCapture, sideEffect: false });
        }
        else {
            dom.addEventListener(eventName, value, isCapture);
        }
    }
    else {
        dom.removeEventListener(eventName, oldValue);
    }
}
function setStyle(style, key, value) {
    if (key[0] === '-') {
        style.setProperty(key, value.toString());
        // css variables need not further judgment
        return;
    }
    style[key] =
        isNumber(value) && IS_NON_DIMENSIONAL.test(key) === false
            ? value + 'px'
            : value == null
                ? ''
                : value;
}
function setProperty(dom, name, value, oldValue) {
    var _a, _b;
    name = name === 'className' ? 'class' : name;
    if (name === 'key' ||
        name === 'children' ||
        name === 'ref') ;
    else if (name === 'style') {
        const style = dom.style;
        if (isString(value)) {
            style.cssText = value;
        }
        else {
            if (isString(oldValue)) {
                style.cssText = '';
                oldValue = null;
            }
            if (isObject(oldValue)) {
                for (const i in oldValue) {
                    if (!(value && i in value)) {
                        setStyle(style, i, '');
                    }
                }
            }
            if (isObject(value)) {
                for (const i in value) {
                    if (!oldValue || value[i] !== oldValue[i]) {
                        setStyle(style, i, value[i]);
                    }
                }
            }
        }
    }
    else if (isEventName(name)) {
        setEvent(dom, name, value, oldValue);
    }
    else if (name === 'dangerouslySetInnerHTML') {
        const newHtml = (_a = value === null || value === void 0 ? void 0 : value.__html) !== null && _a !== void 0 ? _a : '';
        const oldHtml = (_b = oldValue === null || oldValue === void 0 ? void 0 : oldValue.__html) !== null && _b !== void 0 ? _b : '';
        if (newHtml || oldHtml) {
            if (oldHtml !== newHtml) {
                dom.innerHTML = newHtml;
            }
        }
    }
    else if (!isFunction(value)) {
        if (value == null) {
            dom.removeAttribute(name);
        }
        else {
            dom.setAttribute(name, value);
        }
    }
}

/* eslint-disable @typescript-eslint/indent */
const hostConfig = {
    // below keys order by {React ReactFiberHostConfig.custom.js}, convenient for comparing each other.
    // -------------------
    // required by @types/react-reconciler
    // -------------------
    getPublicInstance(inst) {
        return inst;
    },
    getRootHostContext() {
        return {};
    },
    getChildHostContext(parentHostContext) {
        return parentHostContext;
    },
    prepareForCommit(..._) {
        return null;
    },
    resetAfterCommit: noop,
    createInstance(type) {
        return document.createElement(type);
    },
    appendInitialChild(parent, child) {
        parent.appendChild(child);
    },
    finalizeInitialChildren(dom, _, props) {
        updateProps(dom, {}, props); // 提前执行更新属性操作，Taro 在 Page 初始化后会立即从 dom 读取必要信息
        return false;
    },
    prepareUpdate(instance, _, oldProps, newProps) {
        return getUpdatePayload(instance, oldProps, newProps);
    },
    shouldSetTextContent() {
        return false;
    },
    createTextInstance(text) {
        return document.createTextNode(text);
    },
    scheduleTimeout: setTimeout,
    cancelTimeout: clearTimeout,
    noTimeout: -1,
    isPrimaryRenderer: true,
    warnsIfNotActing: true,
    supportsMutation: true,
    supportsPersistence: false,
    supportsHydration: false,
    getInstanceFromNode: () => null,
    beforeActiveInstanceBlur: noop,
    afterActiveInstanceBlur: noop,
    preparePortalMount: noop,
    prepareScopeUpdate: noop,
    getInstanceFromScope: () => null,
    getCurrentEventPriority() {
        return DefaultEventPriority;
    },
    detachDeletedInstance: noop,
    // -------------------
    //      Microtasks
    //     (optional)
    // -------------------
    supportsMicrotasks: true,
    scheduleMicrotask: isUndefined(Promise)
        ? setTimeout
        : (callback) => Promise.resolve(null)
            .then(callback)
            .catch(function (error) {
            setTimeout(() => {
                throw error;
            });
        }),
    // -------------------
    //      Mutation
    //     (required if supportsMutation is true)
    // -------------------
    appendChild(parent, child) {
        parent.appendChild(child);
    },
    appendChildToContainer(parent, child) {
        parent.appendChild(child);
    },
    commitTextUpdate(textInst, _, newText) {
        textInst.nodeValue = newText;
    },
    commitMount: noop,
    commitUpdate(dom, updatePayload, _, oldProps) {
        updatePropsByPayload(dom, oldProps, updatePayload);
    },
    insertBefore(parent, child, refChild) {
        parent.insertBefore(child, refChild);
    },
    insertInContainerBefore(parent, child, refChild) {
        parent.insertBefore(child, refChild);
    },
    removeChild(parent, child) {
        parent.removeChild(child);
    },
    removeChildFromContainer(parent, child) {
        parent.removeChild(child);
    },
    resetTextContent: noop,
    hideInstance(instance) {
        const style = instance.style;
        style.setProperty('display', 'none');
    },
    hideTextInstance(textInstance) {
        textInstance.nodeValue = '';
    },
    unhideInstance(instance, props) {
        const styleProp = props.style;
        let display = (styleProp === null || styleProp === void 0 ? void 0 : styleProp.hasOwnProperty('display')) ? styleProp.display : null;
        display = display == null || isBoolean(display) || display === '' ? '' : ('' + display).trim();
        // eslint-disable-next-line dot-notation
        instance.style['display'] = display;
    },
    unhideTextInstance(textInstance, text) {
        textInstance.nodeValue = text;
    },
    clearContainer(element) {
        if (element.childNodes.length > 0) {
            element.textContent = '';
        }
    },
};
const TaroReconciler = Reconciler(hostConfig);
if (process.env.NODE_ENV !== 'production') {
    const foundDevTools = TaroReconciler.injectIntoDevTools({
        bundleType: 1,
        version: '18.0.0',
        rendererPackageName: 'taro-react',
    });
    if (!foundDevTools) {
        // eslint-disable-next-line no-console
        console.info('%cDownload the React DevTools ' +
            'for a better development experience: ' +
            'https://reactjs.org/link/react-devtools', 'font-weight:bold');
    }
}

const ContainerMap = new WeakMap();
class Root {
    constructor(renderer, domContainer, options) {
        this.renderer = renderer;
        this.initInternalRoot(renderer, domContainer, options);
    }
    initInternalRoot(renderer, domContainer, options) {
        // Since react-reconciler v0.27, createContainer need more parameters
        // @see:https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react-reconciler/src/ReactFiberReconciler.js#L248
        const containerInfo = domContainer;
        if (options) {
            const tag = 1; // ConcurrentRoot
            const concurrentUpdatesByDefaultOverride = false;
            let isStrictMode = false;
            let identifierPrefix = '';
            let onRecoverableError = (error) => console.error(error);
            let transitionCallbacks = null;
            if (options.unstable_strictMode === true) {
                isStrictMode = true;
            }
            if (options.identifierPrefix !== undefined) {
                identifierPrefix = options.identifierPrefix;
            }
            if (options.onRecoverableError !== undefined) {
                onRecoverableError = options.onRecoverableError;
            }
            if (options.unstable_transitionCallbacks !== undefined) {
                transitionCallbacks = options.unstable_transitionCallbacks;
            }
            this.internalRoot = renderer.createContainer(containerInfo, tag, null, // hydrationCallbacks
            isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks);
        }
        else {
            const tag = 0; // LegacyRoot
            this.internalRoot = renderer.createContainer(containerInfo, tag, null, // hydrationCallbacks
            false, // isStrictMode
            false, // concurrentUpdatesByDefaultOverride,
            '', // identifierPrefix
            () => { }, // onRecoverableError, this isn't reachable because onRecoverableError isn't called in the legacy API.
            null // transitionCallbacks
            );
        }
    }
    render(children, cb) {
        const { renderer, internalRoot } = this;
        renderer.updateContainer(children, internalRoot, null, cb);
        return renderer.getPublicRootInstance(internalRoot);
    }
    unmount(cb) {
        this.renderer.updateContainer(null, this.internalRoot, null, cb);
    }
}
function render(element, domContainer, cb) {
    const oldRoot = ContainerMap.get(domContainer);
    if (oldRoot != null) {
        return oldRoot.render(element, cb);
    }
    const root = new Root(TaroReconciler, domContainer);
    ContainerMap.set(domContainer, root);
    return root.render(element, cb);
}
function createRoot(domContainer, options = {}) {
    const oldRoot = ContainerMap.get(domContainer);
    if (oldRoot != null) {
        return oldRoot;
    }
    // options should be an object
    const root = new Root(TaroReconciler, domContainer, options);
    ContainerMap.set(domContainer, root);
    return root;
}

const unstable_batchedUpdates = TaroReconciler.batchedUpdates;
function unmountComponentAtNode(dom) {
    ensure(dom && [1, 8, 9, 11].includes(dom.nodeType), 'unmountComponentAtNode(...): Target container is not a DOM element.');
    const root = ContainerMap.get(dom);
    if (!root)
        return false;
    unstable_batchedUpdates(() => {
        root.unmount(() => {
            ContainerMap.delete(dom);
        });
    }, null);
    return true;
}
function findDOMNode(comp) {
    if (comp == null) {
        return null;
    }
    const nodeType = comp.nodeType;
    if (nodeType === 1 || nodeType === 3) {
        return comp;
    }
    return TaroReconciler.findHostInstance(comp);
}
const portalType = isFunction(Symbol) && Symbol.for
    ? Symbol.for('react.portal')
    : 0xeaca;
function createPortal(children, containerInfo, key) {
    return {
        $$typeof: portalType,
        key: key == null ? null : String(key),
        children,
        containerInfo,
        implementation: null
    };
}
var index = {
    render,
    createRoot,
    unstable_batchedUpdates,
    unmountComponentAtNode,
    findDOMNode,
    createPortal
};

export { createPortal, createRoot, index as default, findDOMNode, render, unmountComponentAtNode, unstable_batchedUpdates };
//# sourceMappingURL=react.esm.js.map
