function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import { useAddToFavorites, useDidHide, useDidShow, useError, useLaunch, useLoad, useOptionMenuClick, usePageNotFound, usePageScroll, usePullDownRefresh, usePullIntercept, useReachBottom, useReady, useResize, useRouter, useSaveExitState, useScope, useShareAppMessage, useShareTimeline, useTabItemTap, useTitleClick, useUnload } from "./chunk-KTQMUWJZ.js";
import { Current, Events, _raf, createPageConfig, eventCenter, getCurrentInstance, hooks, incrementId, isFunction, nextTick, options, stringify } from "./chunk-C7DARJKE.js";
import { __commonJS, __toESM } from "./chunk-R3PFIBHC.js";
// node_modules/mobile-detect/mobile-detect.js
var require_mobile_detect = __commonJS({
    "node_modules/mobile-detect/mobile-detect.js" (exports, module) {
        (function(define2, undefined2) {
            define2(function() {
                "use strict";
                var impl = {};
                impl.mobileDetectRules = {
                    "phones": {
                        "iPhone": "\\biPhone\\b|\\biPod\\b",
                        "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+|\\b(BBA100|BBB100|BBD100|BBE100|BBF100|STH100)\\b-[0-9]+",
                        "Pixel": "; \\bPixel\\b",
                        "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
                        "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 5X|Nexus 6",
                        "Dell": "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
                        "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052",
                        "Samsung": "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F|SM-G610F|SM-G981B|SM-G892A|SM-A530F",
                        "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)|LM-G710",
                        "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533|SOV34|601SO|F8332",
                        "Asus": "Asus.*Galaxy|PadFone.*Mobile",
                        "Xiaomi": "^(?!.*\\bx11\\b).*xiaomi.*$|POCOPHONE F1|MI 8|Redmi Note 9S|Redmi Note 5A Prime|N2G47H|M2001J2G|M2001J2I|M1805E10A|M2004J11G|M1902F1G|M2002J9G|M2004J19G|M2003J6A1G",
                        "NokiaLumia": "Lumia [0-9]{3,4}",
                        "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
                        "Palm": "PalmSource|Palm",
                        "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
                        "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
                        "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
                        "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
                        "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
                        "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
                        "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
                        "Alcatel": "Alcatel",
                        "Nintendo": "Nintendo (3DS|Switch)",
                        "Amoi": "Amoi",
                        "INQ": "INQ",
                        "OnePlus": "ONEPLUS",
                        "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
                    },
                    "tablets": {
                        "iPad": "iPad|iPad.*Mobile",
                        "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
                        "GoogleTablet": "Android.*Pixel C",
                        "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835|SM-T830|SM-T837V|SM-T720|SM-T510|SM-T387V|SM-P610|SM-T290|SM-T515|SM-T590|SM-T595|SM-T725|SM-T817P|SM-P585N0|SM-T395|SM-T295|SM-T865|SM-P610N|SM-P615|SM-T970|SM-T380|SM-T5950|SM-T905|SM-T231|SM-T500|SM-T860",
                        "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk/[0-9.]+ like Chrome/[0-9.]+ (?!Mobile)",
                        "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
                        "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
                        "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b",
                        "BlackBerryTablet": "PlayBook|RIM Tablet",
                        "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
                        "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
                        "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
                        "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30|A3-A40",
                        "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
                        "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
                        "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
                        "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
                        "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304X|TB-X304F|TB-X304L|TB-X505F|TB-X505L|TB-X505X|TB-X605F|TB-X605L|TB-8703F|TB-8703X|TB-8703N|TB-8704N|TB-8704F|TB-8704X|TB-8704V|TB-7304F|TB-7304I|TB-7304X|Tab2A7-10F|Tab2A7-20F|TB2-X30L|YT3-X50L|YT3-X50F|YT3-X50M|YT-X705F|YT-X703F|YT-X703L|YT-X705L|YT-X705X|TB2-X30F|TB2-X30L|TB2-X30M|A2107A-F|A2107A-H|TB3-730F|TB3-730M|TB3-730X|TB-7504F|TB-7504X|TB-X704F|TB-X104F|TB3-X70F|TB-X705F|TB-8504F|TB3-X70L|TB3-710F|TB-X704L",
                        "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
                        "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
                        "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
                        "ArnovaTablet": "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
                        "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
                        "IRUTablet": "M702pro",
                        "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
                        "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
                        "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
                        "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
                        "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
                        "NokiaLumiaTablet": "Lumia 2520",
                        "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712",
                        "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
                        "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
                        "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
                        "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
                        "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
                        "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
                        "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
                        "FlyTablet": "IQ310|Fly Vision",
                        "bqTablet": "Android.*(bq)?.*\\b(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))\\b|Maxwell.*Lite|Maxwell.*Plus",
                        "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09|AGS-L09|CMR-AL19",
                        "NecTablet": "\\bN-06D|\\bN-08D",
                        "PantechTablet": "Pantech.*P4100",
                        "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
                        "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
                        "ZyncTablet": "z1000|Z99 2G|z930|z990|z909|Z919|z900",
                        "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
                        "NabiTablet": "Android.*\\bNabi",
                        "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
                        "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
                        "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
                        "PlaystationTablet": "Playstation.*(Portable|Vita)",
                        "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
                        "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
                        "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
                        "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
                        "GalapadTablet": "Android [0-9.]+; [a-z-]+; \\bG1\\b",
                        "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
                        "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
                        "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
                        "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
                        "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
                        "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
                        "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
                        "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
                        "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
                        "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
                        "DPSTablet": "DPS Dream 9|DPS Dual 7",
                        "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
                        "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
                        "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
                        "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
                        "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
                        "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
                        "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
                        "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
                        "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
                        "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497|VFD 1400",
                        "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
                        "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
                        "iMobileTablet": "i-mobile i-note",
                        "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
                        "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
                        "AMPETablet": "Android.* A78 ",
                        "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
                        "TecnoTablet": "TECNO P9|TECNO DP8D",
                        "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
                        "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
                        "FX2Tablet": "FX2 PAD7|FX2 PAD10",
                        "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
                        "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
                        "VerizonTablet": "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
                        "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
                        "CaptivaTablet": "CAPTIVA PAD",
                        "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
                        "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
                        "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b",
                        "JaytechTablet": "TPC-PA762",
                        "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
                        "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
                        "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
                        "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
                        "AocTablet": "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
                        "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
                        "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
                        "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
                        "MediacomTablet": "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA",
                        "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
                        "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
                        "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
                        "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
                        "UbislateTablet": "UbiSlate[\\s]?7C",
                        "PocketBookTablet": "Pocketbook",
                        "KocasoTablet": "\\b(TB-1207)\\b",
                        "HisenseTablet": "\\b(F5281|E2371)\\b",
                        "Hudl": "Hudl HT7S3|Hudl 2",
                        "TelstraTablet": "T-Hub2",
                        "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107"
                    },
                    "oss": {
                        "AndroidOS": "Android",
                        "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
                        "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
                        "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
                        "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Windows Mobile|Windows Phone [0-9.]+|WCE;",
                        "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
                        "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
                        "iPadOS": "CPU OS 13",
                        "SailfishOS": "Sailfish",
                        "MeeGoOS": "MeeGo",
                        "MaemoOS": "Maemo",
                        "JavaOS": "J2ME/|\\bMIDP\\b|\\bCLDC\\b",
                        "webOS": "webOS|hpwOS",
                        "badaOS": "\\bBada\\b",
                        "BREWOS": "BREW"
                    },
                    "uas": {
                        "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome/[.0-9]* (Mobile)?",
                        "Dolfin": "\\bDolfin\\b",
                        "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR/[0-9.]+$|Coast/[0-9.]+",
                        "Skyfire": "Skyfire",
                        "Edge": "\\bEdgiOS\\b|Mobile Safari/[.0-9]* Edge",
                        "IE": "IEMobile|MSIEMobile",
                        "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
                        "Bolt": "bolt",
                        "TeaShark": "teashark",
                        "Blazer": "Blazer",
                        "Safari": "Version((?!\\bEdgiOS\\b).)*Mobile.*Safari|Safari.*Mobile|MobileSafari",
                        "WeChat": "\\bMicroMessenger\\b",
                        "UCBrowser": "UC.*Browser|UCWEB",
                        "baiduboxapp": "baiduboxapp",
                        "baidubrowser": "baidubrowser",
                        "DiigoBrowser": "DiigoBrowser",
                        "Mercury": "\\bMercury\\b",
                        "ObigoBrowser": "Obigo",
                        "NetFront": "NF-Browser",
                        "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
                        "PaleMoon": "Android.*PaleMoon|Mobile.*PaleMoon"
                    },
                    "props": {
                        "Mobile": "Mobile/[VER]",
                        "Build": "Build/[VER]",
                        "Version": "Version/[VER]",
                        "VendorID": "VendorID/[VER]",
                        "iPad": "iPad.*CPU[a-z ]+[VER]",
                        "iPhone": "iPhone.*CPU[a-z ]+[VER]",
                        "iPod": "iPod.*CPU[a-z ]+[VER]",
                        "Kindle": "Kindle/[VER]",
                        "Chrome": [
                            "Chrome/[VER]",
                            "CriOS/[VER]",
                            "CrMo/[VER]"
                        ],
                        "Coast": [
                            "Coast/[VER]"
                        ],
                        "Dolfin": "Dolfin/[VER]",
                        "Firefox": [
                            "Firefox/[VER]",
                            "FxiOS/[VER]"
                        ],
                        "Fennec": "Fennec/[VER]",
                        "Edge": "Edge/[VER]",
                        "IE": [
                            "IEMobile/[VER];",
                            "IEMobile [VER]",
                            "MSIE [VER];",
                            "Trident/[0-9.]+;.*rv:[VER]"
                        ],
                        "NetFront": "NetFront/[VER]",
                        "NokiaBrowser": "NokiaBrowser/[VER]",
                        "Opera": [
                            " OPR/[VER]",
                            "Opera Mini/[VER]",
                            "Version/[VER]"
                        ],
                        "Opera Mini": "Opera Mini/[VER]",
                        "Opera Mobi": "Version/[VER]",
                        "UCBrowser": [
                            "UCWEB[VER]",
                            "UC.*Browser/[VER]"
                        ],
                        "MQQBrowser": "MQQBrowser/[VER]",
                        "MicroMessenger": "MicroMessenger/[VER]",
                        "baiduboxapp": "baiduboxapp/[VER]",
                        "baidubrowser": "baidubrowser/[VER]",
                        "SamsungBrowser": "SamsungBrowser/[VER]",
                        "Iron": "Iron/[VER]",
                        "Safari": [
                            "Version/[VER]",
                            "Safari/[VER]"
                        ],
                        "Skyfire": "Skyfire/[VER]",
                        "Tizen": "Tizen/[VER]",
                        "Webkit": "webkit[ /][VER]",
                        "PaleMoon": "PaleMoon/[VER]",
                        "SailfishBrowser": "SailfishBrowser/[VER]",
                        "Gecko": "Gecko/[VER]",
                        "Trident": "Trident/[VER]",
                        "Presto": "Presto/[VER]",
                        "Goanna": "Goanna/[VER]",
                        "iOS": " \\bi?OS\\b [VER][ ;]{1}",
                        "Android": "Android [VER]",
                        "Sailfish": "Sailfish [VER]",
                        "BlackBerry": [
                            "BlackBerry[\\w]+/[VER]",
                            "BlackBerry.*Version/[VER]",
                            "Version/[VER]"
                        ],
                        "BREW": "BREW [VER]",
                        "Java": "Java/[VER]",
                        "Windows Phone OS": [
                            "Windows Phone OS [VER]",
                            "Windows Phone [VER]"
                        ],
                        "Windows Phone": "Windows Phone [VER]",
                        "Windows CE": "Windows CE/[VER]",
                        "Windows NT": "Windows NT [VER]",
                        "Symbian": [
                            "SymbianOS/[VER]",
                            "Symbian/[VER]"
                        ],
                        "webOS": [
                            "webOS/[VER]",
                            "hpwOS/[VER];"
                        ]
                    },
                    "utils": {
                        "Bot": "Googlebot|facebookexternalhit|Google-AMPHTML|s~amp-validator|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom|contentkingapp|AspiegelBot",
                        "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker/M1A1-R2D2",
                        "DesktopMode": "WPDesktop",
                        "TV": "SonyDTV|HbbTV",
                        "WebKit": "(webkit)[ /]([\\w.]+)",
                        "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b",
                        "Watch": "SM-V700"
                    }
                };
                impl.detectMobileBrowsers = {
                    fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
                    shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
                    tabletPattern: /android|ipad|playbook|silk/i
                };
                var hasOwnProp = Object.prototype.hasOwnProperty, isArray;
                impl.FALLBACK_PHONE = "UnknownPhone";
                impl.FALLBACK_TABLET = "UnknownTablet";
                impl.FALLBACK_MOBILE = "UnknownMobile";
                isArray = "isArray" in Array ? Array.isArray : function(value) {
                    return Object.prototype.toString.call(value) === "[object Array]";
                };
                function equalIC(a, b) {
                    return a != null && b != null && a.toLowerCase() === b.toLowerCase();
                }
                function containsIC(array, value) {
                    var valueLC, i2, len = array.length;
                    if (!len || !value) {
                        return false;
                    }
                    valueLC = value.toLowerCase();
                    for(i2 = 0; i2 < len; ++i2){
                        if (valueLC === array[i2].toLowerCase()) {
                            return true;
                        }
                    }
                    return false;
                }
                function convertPropsToRegExp(object) {
                    for(var key in object){
                        if (hasOwnProp.call(object, key)) {
                            object[key] = new RegExp(object[key], "i");
                        }
                    }
                }
                function prepareUserAgent(userAgent) {
                    return (userAgent || "").substr(0, 500);
                }
                (function init23() {
                    var key, values, value, i2, len, verPos, mobileDetectRules = impl.mobileDetectRules;
                    for(key in mobileDetectRules.props){
                        if (hasOwnProp.call(mobileDetectRules.props, key)) {
                            values = mobileDetectRules.props[key];
                            if (!isArray(values)) {
                                values = [
                                    values
                                ];
                            }
                            len = values.length;
                            for(i2 = 0; i2 < len; ++i2){
                                value = values[i2];
                                verPos = value.indexOf("[VER]");
                                if (verPos >= 0) {
                                    value = value.substring(0, verPos) + "([\\w._\\+]+)" + value.substring(verPos + 5);
                                }
                                values[i2] = new RegExp(value, "i");
                            }
                            mobileDetectRules.props[key] = values;
                        }
                    }
                    convertPropsToRegExp(mobileDetectRules.oss);
                    convertPropsToRegExp(mobileDetectRules.phones);
                    convertPropsToRegExp(mobileDetectRules.tablets);
                    convertPropsToRegExp(mobileDetectRules.uas);
                    convertPropsToRegExp(mobileDetectRules.utils);
                    mobileDetectRules.oss0 = {
                        WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
                        WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
                    };
                })();
                impl.findMatch = function(rules, userAgent) {
                    for(var key in rules){
                        if (hasOwnProp.call(rules, key)) {
                            if (rules[key].test(userAgent)) {
                                return key;
                            }
                        }
                    }
                    return null;
                };
                impl.findMatches = function(rules, userAgent) {
                    var result = [];
                    for(var key in rules){
                        if (hasOwnProp.call(rules, key)) {
                            if (rules[key].test(userAgent)) {
                                result.push(key);
                            }
                        }
                    }
                    return result;
                };
                impl.getVersionStr = function(propertyName, userAgent) {
                    var props = impl.mobileDetectRules.props, patterns, i2, len, match;
                    if (hasOwnProp.call(props, propertyName)) {
                        patterns = props[propertyName];
                        len = patterns.length;
                        for(i2 = 0; i2 < len; ++i2){
                            match = patterns[i2].exec(userAgent);
                            if (match !== null) {
                                return match[1];
                            }
                        }
                    }
                    return null;
                };
                impl.getVersion = function(propertyName, userAgent) {
                    var version = impl.getVersionStr(propertyName, userAgent);
                    return version ? impl.prepareVersionNo(version) : NaN;
                };
                impl.prepareVersionNo = function(version) {
                    var numbers;
                    numbers = version.split(/[a-z._ \/\-]/i);
                    if (numbers.length === 1) {
                        version = numbers[0];
                    }
                    if (numbers.length > 1) {
                        version = numbers[0] + ".";
                        numbers.shift();
                        version += numbers.join("");
                    }
                    return Number(version);
                };
                impl.isMobileFallback = function(userAgent) {
                    return impl.detectMobileBrowsers.fullPattern.test(userAgent) || impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0, 4));
                };
                impl.isTabletFallback = function(userAgent) {
                    return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
                };
                impl.prepareDetectionCache = function(cache2, userAgent, maxPhoneWidth) {
                    if (cache2.mobile !== undefined2) {
                        return;
                    }
                    var phone, tablet, phoneSized;
                    tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
                    if (tablet) {
                        cache2.mobile = cache2.tablet = tablet;
                        cache2.phone = null;
                        return;
                    }
                    phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
                    if (phone) {
                        cache2.mobile = cache2.phone = phone;
                        cache2.tablet = null;
                        return;
                    }
                    if (impl.isMobileFallback(userAgent)) {
                        phoneSized = MobileDetect2.isPhoneSized(maxPhoneWidth);
                        if (phoneSized === undefined2) {
                            cache2.mobile = impl.FALLBACK_MOBILE;
                            cache2.tablet = cache2.phone = null;
                        } else if (phoneSized) {
                            cache2.mobile = cache2.phone = impl.FALLBACK_PHONE;
                            cache2.tablet = null;
                        } else {
                            cache2.mobile = cache2.tablet = impl.FALLBACK_TABLET;
                            cache2.phone = null;
                        }
                    } else if (impl.isTabletFallback(userAgent)) {
                        cache2.mobile = cache2.tablet = impl.FALLBACK_TABLET;
                        cache2.phone = null;
                    } else {
                        cache2.mobile = cache2.tablet = cache2.phone = null;
                    }
                };
                impl.mobileGrade = function(t) {
                    var $isMobile = t.mobile() !== null;
                    if (t.os("iOS") && t.version("iPad") >= 4.3 || t.os("iOS") && t.version("iPhone") >= 3.1 || t.os("iOS") && t.version("iPod") >= 3.1 || t.version("Android") > 2.1 && t.is("Webkit") || t.version("Windows Phone OS") >= 7 || t.is("BlackBerry") && t.version("BlackBerry") >= 6 || t.match("Playbook.*Tablet") || t.version("webOS") >= 1.4 && t.match("Palm|Pre|Pixi") || t.match("hp.*TouchPad") || t.is("Firefox") && t.version("Firefox") >= 12 || t.is("Chrome") && t.is("AndroidOS") && t.version("Android") >= 4 || t.is("Skyfire") && t.version("Skyfire") >= 4.1 && t.is("AndroidOS") && t.version("Android") >= 2.3 || t.is("Opera") && t.version("Opera Mobi") > 11 && t.is("AndroidOS") || t.is("MeeGoOS") || t.is("Tizen") || t.is("Dolfin") && t.version("Bada") >= 2 || (t.is("UC Browser") || t.is("Dolfin")) && t.version("Android") >= 2.3 || t.match("Kindle Fire") || t.is("Kindle") && t.version("Kindle") >= 3 || t.is("AndroidOS") && t.is("NookTablet") || t.version("Chrome") >= 11 && !$isMobile || t.version("Safari") >= 5 && !$isMobile || t.version("Firefox") >= 4 && !$isMobile || t.version("MSIE") >= 7 && !$isMobile || t.version("Opera") >= 10 && !$isMobile) {
                        return "A";
                    }
                    if (t.os("iOS") && t.version("iPad") < 4.3 || t.os("iOS") && t.version("iPhone") < 3.1 || t.os("iOS") && t.version("iPod") < 3.1 || t.is("Blackberry") && t.version("BlackBerry") >= 5 && t.version("BlackBerry") < 6 || t.version("Opera Mini") >= 5 && t.version("Opera Mini") <= 6.5 && (t.version("Android") >= 2.3 || t.is("iOS")) || t.match("NokiaN8|NokiaC7|N97.*Series60|Symbian/3") || t.version("Opera Mobi") >= 11 && t.is("SymbianOS")) {
                        return "B";
                    }
                    if (t.version("BlackBerry") < 5 || t.match("MSIEMobile|Windows CE.*Mobile") || t.version("Windows Mobile") <= 5.2) {
                        return "C";
                    }
                    return "C";
                };
                impl.detectOS = function(ua) {
                    return impl.findMatch(impl.mobileDetectRules.oss0, ua) || impl.findMatch(impl.mobileDetectRules.oss, ua);
                };
                impl.getDeviceSmallerSide = function() {
                    return window.screen.width < window.screen.height ? window.screen.width : window.screen.height;
                };
                function MobileDetect2(userAgent, maxPhoneWidth) {
                    this.ua = prepareUserAgent(userAgent);
                    this._cache = {};
                    this.maxPhoneWidth = maxPhoneWidth || 600;
                }
                MobileDetect2.prototype = {
                    constructor: MobileDetect2,
                    mobile: function() {
                        impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
                        return this._cache.mobile;
                    },
                    phone: function() {
                        impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
                        return this._cache.phone;
                    },
                    tablet: function() {
                        impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
                        return this._cache.tablet;
                    },
                    userAgent: function() {
                        if (this._cache.userAgent === undefined2) {
                            this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
                        }
                        return this._cache.userAgent;
                    },
                    userAgents: function() {
                        if (this._cache.userAgents === undefined2) {
                            this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
                        }
                        return this._cache.userAgents;
                    },
                    os: function() {
                        if (this._cache.os === undefined2) {
                            this._cache.os = impl.detectOS(this.ua);
                        }
                        return this._cache.os;
                    },
                    version: function(key) {
                        return impl.getVersion(key, this.ua);
                    },
                    versionStr: function(key) {
                        return impl.getVersionStr(key, this.ua);
                    },
                    is: function(key) {
                        return containsIC(this.userAgents(), key) || equalIC(key, this.os()) || equalIC(key, this.phone()) || equalIC(key, this.tablet()) || containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
                    },
                    match: function(pattern) {
                        if (!(pattern instanceof RegExp)) {
                            pattern = new RegExp(pattern, "i");
                        }
                        return pattern.test(this.ua);
                    },
                    isPhoneSized: function(maxPhoneWidth) {
                        return MobileDetect2.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
                    },
                    mobileGrade: function() {
                        if (this._cache.grade === undefined2) {
                            this._cache.grade = impl.mobileGrade(this);
                        }
                        return this._cache.grade;
                    }
                };
                if (typeof window !== "undefined" && window.screen) {
                    MobileDetect2.isPhoneSized = function(maxPhoneWidth) {
                        return maxPhoneWidth < 0 ? undefined2 : impl.getDeviceSmallerSide() <= maxPhoneWidth;
                    };
                } else {
                    MobileDetect2.isPhoneSized = function() {};
                }
                MobileDetect2._impl = impl;
                MobileDetect2.version = "1.4.5 2021-03-13";
                return MobileDetect2;
            });
        })(function(undefined2) {
            if (typeof module !== "undefined" && module.exports) {
                return function(factory) {
                    module.exports = factory();
                };
            } else if (false) {
                return false;
            } else if (typeof window !== "undefined") {
                return function(factory) {
                    window.MobileDetect = factory();
                };
            } else {
                throw new Error("unknown environment");
            }
        }());
    }
});
// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
    "node_modules/strict-uri-encode/index.js" (exports, module) {
        "use strict";
        module.exports = (str)=>encodeURIComponent(str).replace(/[!'()*]/g, (x)=>`%${x.charCodeAt(0).toString(16).toUpperCase()}`);
    }
});
// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
    "node_modules/decode-uri-component/index.js" (exports, module) {
        "use strict";
        var token = "%[a-f0-9]{2}";
        var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
        var multiMatcher = new RegExp("(" + token + ")+", "gi");
        function decodeComponents(components2, split) {
            try {
                return [
                    decodeURIComponent(components2.join(""))
                ];
            } catch (err) {}
            if (components2.length === 1) {
                return components2;
            }
            split = split || 1;
            var left = components2.slice(0, split);
            var right = components2.slice(split);
            return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
        }
        function decode2(input) {
            try {
                return decodeURIComponent(input);
            } catch (err) {
                var tokens = input.match(singleMatcher) || [];
                for(var i2 = 1; i2 < tokens.length; i2++){
                    input = decodeComponents(tokens, i2).join("");
                    tokens = input.match(singleMatcher) || [];
                }
                return input;
            }
        }
        function customDecodeURIComponent(input) {
            var replaceMap = {
                "%FE%FF": "\uFFFD\uFFFD",
                "%FF%FE": "\uFFFD\uFFFD"
            };
            var match = multiMatcher.exec(input);
            while(match){
                try {
                    replaceMap[match[0]] = decodeURIComponent(match[0]);
                } catch (err) {
                    var result = decode2(match[0]);
                    if (result !== match[0]) {
                        replaceMap[match[0]] = result;
                    }
                }
                match = multiMatcher.exec(input);
            }
            replaceMap["%C2"] = "\uFFFD";
            var entries = Object.keys(replaceMap);
            for(var i2 = 0; i2 < entries.length; i2++){
                var key = entries[i2];
                input = input.replace(new RegExp(key, "g"), replaceMap[key]);
            }
            return input;
        }
        module.exports = function(encodedURI) {
            if (typeof encodedURI !== "string") {
                throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
            }
            try {
                encodedURI = encodedURI.replace(/\+/g, " ");
                return decodeURIComponent(encodedURI);
            } catch (err) {
                return customDecodeURIComponent(encodedURI);
            }
        };
    }
});
// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
    "node_modules/split-on-first/index.js" (exports, module) {
        "use strict";
        module.exports = (string, separator)=>{
            if (!(typeof string === "string" && typeof separator === "string")) {
                throw new TypeError("Expected the arguments to be of type `string`");
            }
            if (separator === "") {
                return [
                    string
                ];
            }
            const separatorIndex = string.indexOf(separator);
            if (separatorIndex === -1) {
                return [
                    string
                ];
            }
            return [
                string.slice(0, separatorIndex),
                string.slice(separatorIndex + separator.length)
            ];
        };
    }
});
// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
    "node_modules/filter-obj/index.js" (exports, module) {
        "use strict";
        module.exports = function(obj, predicate) {
            var ret = {};
            var keys = Object.keys(obj);
            var isArr = Array.isArray(predicate);
            for(var i2 = 0; i2 < keys.length; i2++){
                var key = keys[i2];
                var val = obj[key];
                if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
                    ret[key] = val;
                }
            }
            return ret;
        };
    }
});
// node_modules/query-string/index.js
var require_query_string = __commonJS({
    "node_modules/query-string/index.js" (exports) {
        "use strict";
        var strictUriEncode = require_strict_uri_encode();
        var decodeComponent = require_decode_uri_component();
        var splitOnFirst = require_split_on_first();
        var filterObject = require_filter_obj();
        var isNullOrUndefined = (value)=>value === null || value === void 0;
        var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
        function encoderForArrayFormat(options3) {
            switch(options3.arrayFormat){
                case "index":
                    return (key)=>(result, value)=>{
                            const index2 = result.length;
                            if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                return result;
                            }
                            if (value === null) {
                                return [
                                    ...result,
                                    [
                                        encode(key, options3),
                                        "[",
                                        index2,
                                        "]"
                                    ].join("")
                                ];
                            }
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    "[",
                                    encode(index2, options3),
                                    "]=",
                                    encode(value, options3)
                                ].join("")
                            ];
                        };
                case "bracket":
                    return (key)=>(result, value)=>{
                            if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                return result;
                            }
                            if (value === null) {
                                return [
                                    ...result,
                                    [
                                        encode(key, options3),
                                        "[]"
                                    ].join("")
                                ];
                            }
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    "[]=",
                                    encode(value, options3)
                                ].join("")
                            ];
                        };
                case "colon-list-separator":
                    return (key)=>(result, value)=>{
                            if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                return result;
                            }
                            if (value === null) {
                                return [
                                    ...result,
                                    [
                                        encode(key, options3),
                                        ":list="
                                    ].join("")
                                ];
                            }
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    ":list=",
                                    encode(value, options3)
                                ].join("")
                            ];
                        };
                case "comma":
                case "separator":
                case "bracket-separator":
                    {
                        const keyValueSep = options3.arrayFormat === "bracket-separator" ? "[]=" : "=";
                        return (key)=>(result, value)=>{
                                if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                    return result;
                                }
                                value = value === null ? "" : value;
                                if (result.length === 0) {
                                    return [
                                        [
                                            encode(key, options3),
                                            keyValueSep,
                                            encode(value, options3)
                                        ].join("")
                                    ];
                                }
                                return [
                                    [
                                        result,
                                        encode(value, options3)
                                    ].join(options3.arrayFormatSeparator)
                                ];
                            };
                    }
                default:
                    return (key)=>(result, value)=>{
                            if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                                return result;
                            }
                            if (value === null) {
                                return [
                                    ...result,
                                    encode(key, options3)
                                ];
                            }
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    "=",
                                    encode(value, options3)
                                ].join("")
                            ];
                        };
            }
        }
        function parserForArrayFormat(options3) {
            let result;
            switch(options3.arrayFormat){
                case "index":
                    return (key, value, accumulator)=>{
                        result = /\[(\d*)\]$/.exec(key);
                        key = key.replace(/\[\d*\]$/, "");
                        if (!result) {
                            accumulator[key] = value;
                            return;
                        }
                        if (accumulator[key] === void 0) {
                            accumulator[key] = {};
                        }
                        accumulator[key][result[1]] = value;
                    };
                case "bracket":
                    return (key, value, accumulator)=>{
                        result = /(\[\])$/.exec(key);
                        key = key.replace(/\[\]$/, "");
                        if (!result) {
                            accumulator[key] = value;
                            return;
                        }
                        if (accumulator[key] === void 0) {
                            accumulator[key] = [
                                value
                            ];
                            return;
                        }
                        accumulator[key] = [].concat(accumulator[key], value);
                    };
                case "colon-list-separator":
                    return (key, value, accumulator)=>{
                        result = /(:list)$/.exec(key);
                        key = key.replace(/:list$/, "");
                        if (!result) {
                            accumulator[key] = value;
                            return;
                        }
                        if (accumulator[key] === void 0) {
                            accumulator[key] = [
                                value
                            ];
                            return;
                        }
                        accumulator[key] = [].concat(accumulator[key], value);
                    };
                case "comma":
                case "separator":
                    return (key, value, accumulator)=>{
                        const isArray = typeof value === "string" && value.includes(options3.arrayFormatSeparator);
                        const isEncodedArray = typeof value === "string" && !isArray && decode2(value, options3).includes(options3.arrayFormatSeparator);
                        value = isEncodedArray ? decode2(value, options3) : value;
                        const newValue = isArray || isEncodedArray ? value.split(options3.arrayFormatSeparator).map((item)=>decode2(item, options3)) : value === null ? value : decode2(value, options3);
                        accumulator[key] = newValue;
                    };
                case "bracket-separator":
                    return (key, value, accumulator)=>{
                        const isArray = /(\[\])$/.test(key);
                        key = key.replace(/\[\]$/, "");
                        if (!isArray) {
                            accumulator[key] = value ? decode2(value, options3) : value;
                            return;
                        }
                        const arrayValue = value === null ? [] : value.split(options3.arrayFormatSeparator).map((item)=>decode2(item, options3));
                        if (accumulator[key] === void 0) {
                            accumulator[key] = arrayValue;
                            return;
                        }
                        accumulator[key] = [].concat(accumulator[key], arrayValue);
                    };
                default:
                    return (key, value, accumulator)=>{
                        if (accumulator[key] === void 0) {
                            accumulator[key] = value;
                            return;
                        }
                        accumulator[key] = [].concat(accumulator[key], value);
                    };
            }
        }
        function validateArrayFormatSeparator(value) {
            if (typeof value !== "string" || value.length !== 1) {
                throw new TypeError("arrayFormatSeparator must be single character string");
            }
        }
        function encode(value, options3) {
            if (options3.encode) {
                return options3.strict ? strictUriEncode(value) : encodeURIComponent(value);
            }
            return value;
        }
        function decode2(value, options3) {
            if (options3.decode) {
                return decodeComponent(value);
            }
            return value;
        }
        function keysSorter(input) {
            if (Array.isArray(input)) {
                return input.sort();
            }
            if (typeof input === "object") {
                return keysSorter(Object.keys(input)).sort((a, b)=>Number(a) - Number(b)).map((key)=>input[key]);
            }
            return input;
        }
        function removeHash(input) {
            const hashStart = input.indexOf("#");
            if (hashStart !== -1) {
                input = input.slice(0, hashStart);
            }
            return input;
        }
        function getHash(url) {
            let hash = "";
            const hashStart = url.indexOf("#");
            if (hashStart !== -1) {
                hash = url.slice(hashStart);
            }
            return hash;
        }
        function extract(input) {
            input = removeHash(input);
            const queryStart = input.indexOf("?");
            if (queryStart === -1) {
                return "";
            }
            return input.slice(queryStart + 1);
        }
        function parseValue(value, options3) {
            if (options3.parseNumbers && !Number.isNaN(Number(value)) && typeof value === "string" && value.trim() !== "") {
                value = Number(value);
            } else if (options3.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
                value = value.toLowerCase() === "true";
            }
            return value;
        }
        function parse2(query, options3) {
            options3 = Object.assign({
                decode: true,
                sort: true,
                arrayFormat: "none",
                arrayFormatSeparator: ",",
                parseNumbers: false,
                parseBooleans: false
            }, options3);
            validateArrayFormatSeparator(options3.arrayFormatSeparator);
            const formatter = parserForArrayFormat(options3);
            const ret = /* @__PURE__ */ Object.create(null);
            if (typeof query !== "string") {
                return ret;
            }
            query = query.trim().replace(/^[?#&]/, "");
            if (!query) {
                return ret;
            }
            for (const param of query.split("&")){
                if (param === "") {
                    continue;
                }
                let [key, value] = splitOnFirst(options3.decode ? param.replace(/\+/g, " ") : param, "=");
                value = value === void 0 ? null : [
                    "comma",
                    "separator",
                    "bracket-separator"
                ].includes(options3.arrayFormat) ? value : decode2(value, options3);
                formatter(decode2(key, options3), value, ret);
            }
            for (const key of Object.keys(ret)){
                const value = ret[key];
                if (typeof value === "object" && value !== null) {
                    for (const k of Object.keys(value)){
                        value[k] = parseValue(value[k], options3);
                    }
                } else {
                    ret[key] = parseValue(value, options3);
                }
            }
            if (options3.sort === false) {
                return ret;
            }
            return (options3.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options3.sort)).reduce((result, key)=>{
                const value = ret[key];
                if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
                    result[key] = keysSorter(value);
                } else {
                    result[key] = value;
                }
                return result;
            }, /* @__PURE__ */ Object.create(null));
        }
        exports.extract = extract;
        exports.parse = parse2;
        exports.stringify = (object, options3)=>{
            if (!object) {
                return "";
            }
            options3 = Object.assign({
                encode: true,
                strict: true,
                arrayFormat: "none",
                arrayFormatSeparator: ","
            }, options3);
            validateArrayFormatSeparator(options3.arrayFormatSeparator);
            const shouldFilter = (key)=>options3.skipNull && isNullOrUndefined(object[key]) || options3.skipEmptyString && object[key] === "";
            const formatter = encoderForArrayFormat(options3);
            const objectCopy = {};
            for (const key of Object.keys(object)){
                if (!shouldFilter(key)) {
                    objectCopy[key] = object[key];
                }
            }
            const keys = Object.keys(objectCopy);
            if (options3.sort !== false) {
                keys.sort(options3.sort);
            }
            return keys.map((key)=>{
                const value = object[key];
                if (value === void 0) {
                    return "";
                }
                if (value === null) {
                    return encode(key, options3);
                }
                if (Array.isArray(value)) {
                    if (value.length === 0 && options3.arrayFormat === "bracket-separator") {
                        return encode(key, options3) + "[]";
                    }
                    return value.reduce(formatter(key), []).join("&");
                }
                return encode(key, options3) + "=" + encode(value, options3);
            }).filter((x)=>x.length > 0).join("&");
        };
        exports.parseUrl = (url, options3)=>{
            options3 = Object.assign({
                decode: true
            }, options3);
            const [url_, hash] = splitOnFirst(url, "#");
            return Object.assign({
                url: url_.split("?")[0] || "",
                query: parse2(extract(url), options3)
            }, options3 && options3.parseFragmentIdentifier && hash ? {
                fragmentIdentifier: decode2(hash, options3)
            } : {});
        };
        exports.stringifyUrl = (object, options3)=>{
            options3 = Object.assign({
                encode: true,
                strict: true,
                [encodeFragmentIdentifier]: true
            }, options3);
            const url = removeHash(object.url).split("?")[0] || "";
            const queryFromUrl = exports.extract(object.url);
            const parsedQueryFromUrl = exports.parse(queryFromUrl, {
                sort: false
            });
            const query = Object.assign(parsedQueryFromUrl, object.query);
            let queryString3 = exports.stringify(query, options3);
            if (queryString3) {
                queryString3 = `?${queryString3}`;
            }
            let hash = getHash(object.url);
            if (object.fragmentIdentifier) {
                hash = `#${options3[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options3) : object.fragmentIdentifier}`;
            }
            return `${url}${queryString3}${hash}`;
        };
        exports.pick = (input, filter3, options3)=>{
            options3 = Object.assign({
                parseFragmentIdentifier: true,
                [encodeFragmentIdentifier]: false
            }, options3);
            const { url , query , fragmentIdentifier  } = exports.parseUrl(input, options3);
            return exports.stringifyUrl({
                url,
                query: filterObject(query, filter3),
                fragmentIdentifier
            }, options3);
        };
        exports.exclude = (input, filter3, options3)=>{
            const exclusionFilter = Array.isArray(filter3) ? (key)=>!filter3.includes(key) : (key, value)=>!filter3(key, value);
            return exports.pick(input, exclusionFilter, options3);
        };
    }
});
// node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
    "node_modules/path-to-regexp/index.js" (exports, module) {
        module.exports = pathToRegexp2;
        module.exports.match = match;
        module.exports.regexpToFunction = regexpToFunction;
        module.exports.parse = parse2;
        module.exports.compile = compile;
        module.exports.tokensToFunction = tokensToFunction;
        module.exports.tokensToRegExp = tokensToRegExp;
        var DEFAULT_DELIMITER = "/";
        var PATH_REGEXP = new RegExp([
            "(\\\\.)",
            "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"
        ].join("|"), "g");
        function parse2(str, options3) {
            var tokens = [];
            var key = 0;
            var index2 = 0;
            var path = "";
            var defaultDelimiter = options3 && options3.delimiter || DEFAULT_DELIMITER;
            var whitelist = options3 && options3.whitelist || void 0;
            var pathEscaped = false;
            var res;
            while((res = PATH_REGEXP.exec(str)) !== null){
                var m = res[0];
                var escaped = res[1];
                var offset2 = res.index;
                path += str.slice(index2, offset2);
                index2 = offset2 + m.length;
                if (escaped) {
                    path += escaped[1];
                    pathEscaped = true;
                    continue;
                }
                var prev2 = "";
                var name = res[2];
                var capture = res[3];
                var group = res[4];
                var modifier = res[5];
                if (!pathEscaped && path.length) {
                    var k = path.length - 1;
                    var c = path[k];
                    var matches = whitelist ? whitelist.indexOf(c) > -1 : true;
                    if (matches) {
                        prev2 = c;
                        path = path.slice(0, k);
                    }
                }
                if (path) {
                    tokens.push(path);
                    path = "";
                    pathEscaped = false;
                }
                var repeat = modifier === "+" || modifier === "*";
                var optional = modifier === "?" || modifier === "*";
                var pattern = capture || group;
                var delimiter = prev2 || defaultDelimiter;
                tokens.push({
                    name: name || key++,
                    prefix: prev2,
                    delimiter,
                    optional,
                    repeat,
                    pattern: pattern ? escapeGroup(pattern) : "[^" + escapeString(delimiter === defaultDelimiter ? delimiter : delimiter + defaultDelimiter) + "]+?"
                });
            }
            if (path || index2 < str.length) {
                tokens.push(path + str.substr(index2));
            }
            return tokens;
        }
        function compile(str, options3) {
            return tokensToFunction(parse2(str, options3), options3);
        }
        function match(str, options3) {
            var keys = [];
            var re = pathToRegexp2(str, keys, options3);
            return regexpToFunction(re, keys);
        }
        function regexpToFunction(re, keys) {
            return function(pathname, options3) {
                var m = re.exec(pathname);
                if (!m) return false;
                var path = m[0];
                var index2 = m.index;
                var params = {};
                var decode2 = options3 && options3.decode || decodeURIComponent;
                for(var i2 = 1; i2 < m.length; i2++){
                    if (m[i2] === void 0) continue;
                    var key = keys[i2 - 1];
                    if (key.repeat) {
                        params[key.name] = m[i2].split(key.delimiter).map(function(value) {
                            return decode2(value, key);
                        });
                    } else {
                        params[key.name] = decode2(m[i2], key);
                    }
                }
                return {
                    path,
                    index: index2,
                    params
                };
            };
        }
        function tokensToFunction(tokens, options3) {
            var matches = new Array(tokens.length);
            for(var i2 = 0; i2 < tokens.length; i2++){
                if (typeof tokens[i2] === "object") {
                    matches[i2] = new RegExp("^(?:" + tokens[i2].pattern + ")$", flags(options3));
                }
            }
            return function(data, options4) {
                var path = "";
                var encode = options4 && options4.encode || encodeURIComponent;
                var validate = options4 ? options4.validate !== false : true;
                for(var i3 = 0; i3 < tokens.length; i3++){
                    var token = tokens[i3];
                    if (typeof token === "string") {
                        path += token;
                        continue;
                    }
                    var value = data ? data[token.name] : void 0;
                    var segment;
                    if (Array.isArray(value)) {
                        if (!token.repeat) {
                            throw new TypeError('Expected "' + token.name + '" to not repeat, but got array');
                        }
                        if (value.length === 0) {
                            if (token.optional) continue;
                            throw new TypeError('Expected "' + token.name + '" to not be empty');
                        }
                        for(var j = 0; j < value.length; j++){
                            segment = encode(value[j], token);
                            if (validate && !matches[i3].test(segment)) {
                                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"');
                            }
                            path += (j === 0 ? token.prefix : token.delimiter) + segment;
                        }
                        continue;
                    }
                    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
                        segment = encode(String(value), token);
                        if (validate && !matches[i3].test(segment)) {
                            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
                        }
                        path += token.prefix + segment;
                        continue;
                    }
                    if (token.optional) continue;
                    throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? "an array" : "a string"));
                }
                return path;
            };
        }
        function escapeString(str) {
            return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
        }
        function escapeGroup(group) {
            return group.replace(/([=!:$/()])/g, "\\$1");
        }
        function flags(options3) {
            return options3 && options3.sensitive ? "" : "i";
        }
        function regexpToRegexp(path, keys) {
            if (!keys) return path;
            var groups = path.source.match(/\((?!\?)/g);
            if (groups) {
                for(var i2 = 0; i2 < groups.length; i2++){
                    keys.push({
                        name: i2,
                        prefix: null,
                        delimiter: null,
                        optional: false,
                        repeat: false,
                        pattern: null
                    });
                }
            }
            return path;
        }
        function arrayToRegexp(path, keys, options3) {
            var parts = [];
            for(var i2 = 0; i2 < path.length; i2++){
                parts.push(pathToRegexp2(path[i2], keys, options3).source);
            }
            return new RegExp("(?:" + parts.join("|") + ")", flags(options3));
        }
        function stringToRegexp(path, keys, options3) {
            return tokensToRegExp(parse2(path, options3), keys, options3);
        }
        function tokensToRegExp(tokens, keys, options3) {
            options3 = options3 || {};
            var strict = options3.strict;
            var start2 = options3.start !== false;
            var end = options3.end !== false;
            var delimiter = options3.delimiter || DEFAULT_DELIMITER;
            var endsWith = [].concat(options3.endsWith || []).map(escapeString).concat("$").join("|");
            var route = start2 ? "^" : "";
            for(var i2 = 0; i2 < tokens.length; i2++){
                var token = tokens[i2];
                if (typeof token === "string") {
                    route += escapeString(token);
                } else {
                    var capture = token.repeat ? "(?:" + token.pattern + ")(?:" + escapeString(token.delimiter) + "(?:" + token.pattern + "))*" : token.pattern;
                    if (keys) keys.push(token);
                    if (token.optional) {
                        if (!token.prefix) {
                            route += "(" + capture + ")?";
                        } else {
                            route += "(?:" + escapeString(token.prefix) + "(" + capture + "))?";
                        }
                    } else {
                        route += escapeString(token.prefix) + "(" + capture + ")";
                    }
                }
            }
            if (end) {
                if (!strict) route += "(?:" + escapeString(delimiter) + ")?";
                route += endsWith === "$" ? "$" : "(?=" + endsWith + ")";
            } else {
                var endToken = tokens[tokens.length - 1];
                var isEndDelimited = typeof endToken === "string" ? endToken[endToken.length - 1] === delimiter : endToken === void 0;
                if (!strict) route += "(?:" + escapeString(delimiter) + "(?=" + endsWith + "))?";
                if (!isEndDelimited) route += "(?=" + escapeString(delimiter) + "|" + endsWith + ")";
            }
            return new RegExp(route, flags(options3));
        }
        function pathToRegexp2(path, keys, options3) {
            if (path instanceof RegExp) {
                return regexpToRegexp(path, keys);
            }
            if (Array.isArray(path)) {
                return arrayToRegexp(path, keys, options3);
            }
            return stringToRegexp(path, keys, options3);
        }
    }
});
// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js" (exports) {
        "use strict";
        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray2;
        exports.fromByteArray = fromByteArray2;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for(i2 = 0, len = code.length; i2 < len; ++i2){
            lookup[i2] = code[i2];
            revLookup[code.charCodeAt(i2)] = i2;
        }
        var i2;
        var len;
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
            var len2 = b64.length;
            if (len2 % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
            }
            var validLen = b64.indexOf("=");
            if (validLen === -1) validLen = len2;
            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
            return [
                validLen,
                placeHoldersLen
            ];
        }
        function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray2(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i3;
            for(i3 = 0; i3 < len2; i3 += 4){
                tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
                arr[curByte++] = tmp >> 16 & 255;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
                tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 1) {
                tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            return arr;
        }
        function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start2, end) {
            var tmp;
            var output = [];
            for(var i3 = start2; i3 < end; i3 += 3){
                tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
                output.push(tripletToBase64(tmp));
            }
            return output.join("");
        }
        function fromByteArray2(uint8) {
            var tmp;
            var len2 = uint8.length;
            var extraBytes = len2 % 3;
            var parts = [];
            var maxChunkLength = 16383;
            for(var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength){
                parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
            }
            if (extraBytes === 1) {
                tmp = uint8[len2 - 1];
                parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
            } else if (extraBytes === 2) {
                tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
            }
            return parts.join("");
        }
    }
});
// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
// node_modules/history/index.js
var Action;
(function(Action2) {
    Action2["Pop"] = "POP";
    Action2["Push"] = "PUSH";
    Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
var readOnly = true ? function(obj) {
    return Object.freeze(obj);
} : function(obj) {
    return obj;
};
function warning(cond, message) {
    if (!cond) {
        if (typeof console !== "undefined") console.warn(message);
        try {
            throw new Error(message);
        } catch (e) {}
    }
}
var BeforeUnloadEventType = "beforeunload";
var HashChangeEventType = "hashchange";
var PopStateEventType = "popstate";
function createBrowserHistory(options3) {
    if (options3 === void 0) {
        options3 = {};
    }
    var _options = options3, _options$window = _options.window, window2 = _options$window === void 0 ? document.defaultView : _options$window;
    var globalHistory = window2.history;
    function getIndexAndLocation() {
        var _window$location = window2.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
        var state = globalHistory.state || {};
        return [
            state.idx,
            readOnly({
                pathname,
                search,
                hash,
                state: state.usr || null,
                key: state.key || "default"
            })
        ];
    }
    var blockedPopTx = null;
    function handlePop() {
        if (blockedPopTx) {
            blockers.call(blockedPopTx);
            blockedPopTx = null;
        } else {
            var nextAction = Action.Pop;
            var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];
            if (blockers.length) {
                if (nextIndex != null) {
                    var delta = index2 - nextIndex;
                    if (delta) {
                        blockedPopTx = {
                            action: nextAction,
                            location: nextLocation,
                            retry: function retry() {
                                go(delta * -1);
                            }
                        };
                        go(delta);
                    }
                } else {
                    true ? warning(false, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : void 0;
                }
            } else {
                applyTx(nextAction);
            }
        }
    }
    window2.addEventListener(PopStateEventType, handlePop);
    var action = Action.Pop;
    var _getIndexAndLocation2 = getIndexAndLocation(), index2 = _getIndexAndLocation2[0], location2 = _getIndexAndLocation2[1];
    var listeners = createEvents();
    var blockers = createEvents();
    if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(_extends({}, globalHistory.state, {
            idx: index2
        }), "");
    }
    function createHref(to) {
        return typeof to === "string" ? to : createPath(to);
    }
    function getNextLocation(to, state) {
        if (state === void 0) {
            state = null;
        }
        return readOnly(_extends({
            pathname: location2.pathname,
            hash: "",
            search: ""
        }, typeof to === "string" ? parsePath(to) : to, {
            state,
            key: createKey()
        }));
    }
    function getHistoryStateAndUrl(nextLocation, index3) {
        return [
            {
                usr: nextLocation.state,
                key: nextLocation.key,
                idx: index3
            },
            createHref(nextLocation)
        ];
    }
    function allowTx(action2, location3, retry) {
        return !blockers.length || (blockers.call({
            action: action2,
            location: location3,
            retry
        }), false);
    }
    function applyTx(nextAction) {
        action = nextAction;
        var _getIndexAndLocation3 = getIndexAndLocation();
        index2 = _getIndexAndLocation3[0];
        location2 = _getIndexAndLocation3[1];
        listeners.call({
            action,
            location: location2
        });
    }
    function push(to, state) {
        var nextAction = Action.Push;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            push(to, state);
        }
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index2 + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];
            try {
                globalHistory.pushState(historyState, "", url);
            } catch (error) {
                window2.location.assign(url);
            }
            applyTx(nextAction);
        }
    }
    function replace(to, state) {
        var nextAction = Action.Replace;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            replace(to, state);
        }
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index2), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];
            globalHistory.replaceState(historyState, "", url);
            applyTx(nextAction);
        }
    }
    function go(delta) {
        globalHistory.go(delta);
    }
    var history2 = {
        get action () {
            return action;
        },
        get location () {
            return location2;
        },
        createHref,
        push,
        replace,
        go,
        back: function back() {
            go(-1);
        },
        forward: function forward() {
            go(1);
        },
        listen: function listen(listener) {
            return listeners.push(listener);
        },
        block: function block(blocker) {
            var unblock = blockers.push(blocker);
            if (blockers.length === 1) {
                window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
            }
            return function() {
                unblock();
                if (!blockers.length) {
                    window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
                }
            };
        }
    };
    return history2;
}
function createHashHistory(options3) {
    if (options3 === void 0) {
        options3 = {};
    }
    var _options2 = options3, _options2$window = _options2.window, window2 = _options2$window === void 0 ? document.defaultView : _options2$window;
    var globalHistory = window2.history;
    function getIndexAndLocation() {
        var _parsePath = parsePath(window2.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? "" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? "" : _parsePath$hash;
        var state = globalHistory.state || {};
        return [
            state.idx,
            readOnly({
                pathname,
                search,
                hash,
                state: state.usr || null,
                key: state.key || "default"
            })
        ];
    }
    var blockedPopTx = null;
    function handlePop() {
        if (blockedPopTx) {
            blockers.call(blockedPopTx);
            blockedPopTx = null;
        } else {
            var nextAction = Action.Pop;
            var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];
            if (blockers.length) {
                if (nextIndex != null) {
                    var delta = index2 - nextIndex;
                    if (delta) {
                        blockedPopTx = {
                            action: nextAction,
                            location: nextLocation,
                            retry: function retry() {
                                go(delta * -1);
                            }
                        };
                        go(delta);
                    }
                } else {
                    true ? warning(false, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : void 0;
                }
            } else {
                applyTx(nextAction);
            }
        }
    }
    window2.addEventListener(PopStateEventType, handlePop);
    window2.addEventListener(HashChangeEventType, function() {
        var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];
        if (createPath(nextLocation) !== createPath(location2)) {
            handlePop();
        }
    });
    var action = Action.Pop;
    var _getIndexAndLocation6 = getIndexAndLocation(), index2 = _getIndexAndLocation6[0], location2 = _getIndexAndLocation6[1];
    var listeners = createEvents();
    var blockers = createEvents();
    if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(_extends({}, globalHistory.state, {
            idx: index2
        }), "");
    }
    function getBaseHref() {
        var base = document.querySelector("base");
        var href = "";
        if (base && base.getAttribute("href")) {
            var url = window2.location.href;
            var hashIndex = url.indexOf("#");
            href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href;
    }
    function createHref(to) {
        return getBaseHref() + "#" + (typeof to === "string" ? to : createPath(to));
    }
    function getNextLocation(to, state) {
        if (state === void 0) {
            state = null;
        }
        return readOnly(_extends({
            pathname: location2.pathname,
            hash: "",
            search: ""
        }, typeof to === "string" ? parsePath(to) : to, {
            state,
            key: createKey()
        }));
    }
    function getHistoryStateAndUrl(nextLocation, index3) {
        return [
            {
                usr: nextLocation.state,
                key: nextLocation.key,
                idx: index3
            },
            createHref(nextLocation)
        ];
    }
    function allowTx(action2, location3, retry) {
        return !blockers.length || (blockers.call({
            action: action2,
            location: location3,
            retry
        }), false);
    }
    function applyTx(nextAction) {
        action = nextAction;
        var _getIndexAndLocation7 = getIndexAndLocation();
        index2 = _getIndexAndLocation7[0];
        location2 = _getIndexAndLocation7[1];
        listeners.call({
            action,
            location: location2
        });
    }
    function push(to, state) {
        var nextAction = Action.Push;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            push(to, state);
        }
        true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")") : void 0;
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index2 + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1];
            try {
                globalHistory.pushState(historyState, "", url);
            } catch (error) {
                window2.location.assign(url);
            }
            applyTx(nextAction);
        }
    }
    function replace(to, state) {
        var nextAction = Action.Replace;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            replace(to, state);
        }
        true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(to) + ")") : void 0;
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index2), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1];
            globalHistory.replaceState(historyState, "", url);
            applyTx(nextAction);
        }
    }
    function go(delta) {
        globalHistory.go(delta);
    }
    var history2 = {
        get action () {
            return action;
        },
        get location () {
            return location2;
        },
        createHref,
        push,
        replace,
        go,
        back: function back() {
            go(-1);
        },
        forward: function forward() {
            go(1);
        },
        listen: function listen(listener) {
            return listeners.push(listener);
        },
        block: function block(blocker) {
            var unblock = blockers.push(blocker);
            if (blockers.length === 1) {
                window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
            }
            return function() {
                unblock();
                if (!blockers.length) {
                    window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
                }
            };
        }
    };
    return history2;
}
function promptBeforeUnload(event2) {
    event2.preventDefault();
    event2.returnValue = "";
}
function createEvents() {
    var handlers = [];
    return {
        get length () {
            return handlers.length;
        },
        push: function push(fn) {
            handlers.push(fn);
            return function() {
                handlers = handlers.filter(function(handler) {
                    return handler !== fn;
                });
            };
        },
        call: function call(arg) {
            handlers.forEach(function(fn) {
                return fn && fn(arg);
            });
        }
    };
}
function createKey() {
    return Math.random().toString(36).substr(2, 8);
}
function createPath(_ref) {
    var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
    if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
    if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
    return pathname;
}
function parsePath(path) {
    var parsedPath = {};
    if (path) {
        var hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
            parsedPath.hash = path.substr(hashIndex);
            path = path.substr(0, hashIndex);
        }
        var searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
            parsedPath.search = path.substr(searchIndex);
            path = path.substr(0, searchIndex);
        }
        if (path) {
            parsedPath.pathname = path;
        }
    }
    return parsedPath;
}
// node_modules/@tarojs/router/dist/utils/index.js
var addLeadingSlash = (url = "")=>url.charAt(0) === "/" ? url : "/" + url;
var hasBasename = (path = "", prefix = "")=>new RegExp("^" + prefix + "(\\/|\\?|#|$)", "i").test(path) || path === prefix;
var stripBasename = (path = "", prefix = "")=>hasBasename(path, prefix) ? path.substring(prefix.length) : path;
var stripTrailing = (str = "")=>str.replace(/[?#][\s\S]*$/, "");
var getHomePage = (path = "", basename2 = "", customRoutes = {}, entryPagePath = "")=>{
    var _a;
    const routePath = addLeadingSlash(stripBasename(path, basename2));
    const alias = ((_a = Object.entries(customRoutes).find(([key])=>key === routePath)) === null || _a === void 0 ? void 0 : _a[1]) || routePath;
    return entryPagePath || (typeof alias === "string" ? alias : alias[0]) || basename2;
};
var getCurrentPage = (routerMode = "hash", basename2 = "/")=>{
    const pagePath = routerMode === "hash" ? location.hash.slice(1).split("?")[0] : location.pathname;
    return addLeadingSlash(stripBasename(pagePath, basename2));
};
var RoutesAlias = class {
    set(customRoutes = {}) {
        for(let key in customRoutes){
            const path = customRoutes[key];
            key = addLeadingSlash(key);
            if (typeof path === "string") {
                this.conf.push([
                    key,
                    addLeadingSlash(path)
                ]);
            } else if ((path === null || path === void 0 ? void 0 : path.length) > 0) {
                this.conf.push(...path.map((p)=>[
                        key,
                        addLeadingSlash(p)
                    ]));
            }
        }
    }
    constructor(){
        this.conf = [];
        this.getConfig = (url = "")=>{
            const customRoute = this.conf.filter((arr)=>{
                return arr.includes(url);
            });
            return customRoute[0];
        };
        this.getOrigin = (url = "")=>{
            var _a;
            return ((_a = this.getConfig(url)) === null || _a === void 0 ? void 0 : _a[0]) || url;
        };
        this.getAlias = (url = "")=>{
            var _a;
            return ((_a = this.getConfig(url)) === null || _a === void 0 ? void 0 : _a[1]) || url;
        };
        this.getAll = (url = "")=>{
            return this.conf.filter((arr)=>arr.includes(url)).reduceRight((p, a)=>{
                p.unshift(a[1]);
                return p;
            }, []);
        };
    }
};
var routesAlias = new RoutesAlias();
// node_modules/@tarojs/router/dist/router/index.js
var RouterConfig = class {
    static set config(e) {
        this.__config = e;
    }
    static get config() {
        return this.__config;
    }
    static get pages() {
        return this.config.pages || [];
    }
    static get router() {
        return this.config.router || {};
    }
    static get mode() {
        return this.router.mode || "hash";
    }
    static get customRoutes() {
        return this.router.customRoutes || {};
    }
    static isPage(url = "") {
        return this.pages.findIndex((e)=>addLeadingSlash(e) === url) !== -1;
    }
};
// node_modules/@tarojs/router/dist/history.js
var history;
var basename = "/";
var MpaHistory = class {
    get location() {
        return {
            pathname: window.location.pathname,
            search: window.location.search,
            hash: window.location.hash,
            key: `${window.history.length}`,
            state: window.history.state
        };
    }
    createHref(_to) {
        throw new Error("Method not implemented.");
    }
    parseUrl(to) {
        let url = to.pathname || "";
        if (RouterConfig.isPage(url)) {
            url += ".html";
        }
        if (to.search) {
            url += `?${to.search}`;
        }
        if (to.hash) {
            url += `#${to.hash}`;
        }
        return url;
    }
    push(to, _state = {}) {
        window.location.pathname = this.parseUrl(to);
    }
    replace(to, _state = {}) {
        window.location.replace(this.parseUrl(to));
    }
    go(delta) {
        window.history.go(delta);
    }
    listen(listener) {
        function callback(e) {
            if (e.action === "pushState") {
                listener({
                    action: Action.Push,
                    location: this.location
                });
            } else if (e.action === "replaceState") {
                listener({
                    action: Action.Replace,
                    location: this.location
                });
            } else {
                listener({
                    action: Action.Pop,
                    location: this.location
                });
            }
        }
        window.addEventListener("popstate", callback);
        return ()=>{
            window.removeEventListener("popstate", callback);
        };
    }
    block(_blocker) {
        throw new Error("Method not implemented.");
    }
    eventState(action) {
        return (data, unused, url)=>{
            const wrapper = window.history[action](data, unused, url);
            const evt = new Event(action);
            evt.action = action;
            evt.state = data;
            evt.unused = unused;
            evt.url = url;
            window.dispatchEvent(evt);
            return wrapper;
        };
    }
    constructor(){
        this.back = window.history.back;
        this.forward = window.history.forward;
        this.pushState = this.eventState("pushState");
        this.replaceState = this.eventState("replaceState");
    }
};
function setHistoryMode(mode, base = "/") {
    const options3 = {
        window
    };
    basename = base;
    if (mode === "browser") {
        history = createBrowserHistory(options3);
    } else if (mode === "multi") {
        history = new MpaHistory();
    } else {
        history = createHashHistory(options3);
    }
}
function prependBasename(url = "") {
    return basename.replace(/\/$/, "") + "/" + url.replace(/^\//, "");
}
// node_modules/@tarojs/router/dist/router/stack.js
var Stacks = class {
    set delta(delta) {
        if (delta > 0) {
            this.backDelta = delta;
        } else if (this.backDelta > 0) {
            --this.backDelta;
        } else {
            this.backDelta = 0;
        }
    }
    get delta() {
        return this.backDelta;
    }
    set method(methodName) {
        this.methodName = methodName;
    }
    get method() {
        return this.methodName;
    }
    get length() {
        return this.stacks.length;
    }
    get last() {
        return this.stacks[this.length - 1];
    }
    get() {
        return this.stacks;
    }
    getItem(index2) {
        return this.stacks[index2];
    }
    getLastIndex(pathname, stateWith = 1) {
        const list = [
            ...this.stacks
        ].reverse();
        return list.findIndex((page, i2)=>{
            var _a;
            return i2 >= stateWith && ((_a = page.path) === null || _a === void 0 ? void 0 : _a.replace(/\?.*/g, "")) === pathname;
        });
    }
    getDelta(pathname) {
        if (this.backDelta >= 1) {
            return this.backDelta;
        }
        const index2 = this.getLastIndex(pathname);
        return index2 > 0 ? index2 : 1;
    }
    getPrevIndex(pathname, stateWith = 1) {
        const lastIndex = this.getLastIndex(pathname, stateWith);
        if (lastIndex < 0) {
            return -1;
        }
        return this.length - 1 - lastIndex;
    }
    pop() {
        return this.stacks.pop();
    }
    push(page) {
        return this.stacks.push(page);
    }
    getTabs() {
        return this.tabs;
    }
    pushTab(path) {
        this.tabs[path] = this.last;
        this.pop();
    }
    popTab(path) {
        this.push(this.tabs[path]);
        delete this.tabs[path];
    }
    removeTab(path) {
        delete this.tabs[path];
    }
    constructor(){
        this.stacks = [];
        this.backDelta = 0;
        this.tabs = {};
        this.methodName = "";
    }
};
var stacks = new Stacks();
var stack_default = stacks;
// node_modules/@tarojs/router/dist/api.js
var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function processNavigateUrl(option) {
    var _a;
    const pathPieces = parsePath(option.url);
    if ((_a = pathPieces.pathname) === null || _a === void 0 ? void 0 : _a.includes("./")) {
        const parts = routesAlias.getOrigin(history.location.pathname).split("/");
        parts.pop();
        pathPieces.pathname.split("/").forEach((item)=>{
            if (item === ".") {
                return;
            }
            item === ".." ? parts.pop() : parts.push(item);
        });
        pathPieces.pathname = parts.join("/");
    }
    pathPieces.pathname = routesAlias.getAlias(addLeadingSlash(pathPieces.pathname));
    pathPieces.pathname = prependBasename(pathPieces.pathname);
    if (!pathPieces.search) pathPieces.search = "";
    return pathPieces;
}
function navigate(option, method) {
    return __awaiter(this, void 0, void 0, function*() {
        return new Promise((resolve, reject)=>{
            stack_default.method = method;
            const { success , complete , fail  } = option;
            const unListen = history.listen(()=>{
                const res = {
                    errMsg: `${method}:ok`
                };
                success === null || success === void 0 ? void 0 : success(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                resolve(res);
                unListen();
            });
            try {
                if ("url" in option) {
                    const pathPieces = processNavigateUrl(option);
                    const state = {
                        timestamp: Date.now()
                    };
                    if (method === "navigateTo") {
                        history.push(pathPieces, state);
                    } else if (method === "redirectTo" || method === "switchTab") {
                        history.replace(pathPieces, state);
                    } else if (method === "reLaunch") {
                        stack_default.delta = stack_default.length;
                        history.replace(pathPieces, state);
                    }
                } else if (method === "navigateBack") {
                    stack_default.delta = option.delta;
                    history.go(-option.delta);
                }
            } catch (error) {
                const res = {
                    errMsg: `${method}:fail ${error.message || error}`
                };
                fail === null || fail === void 0 ? void 0 : fail(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                reject(res);
            }
        });
    });
}
function navigateTo(option) {
    return navigate(option, "navigateTo");
}
function redirectTo(option) {
    return navigate(option, "redirectTo");
}
function navigateBack(option = {
    delta: 1
}) {
    if (!option.delta || option.delta < 1) {
        option.delta = 1;
    }
    return navigate(option, "navigateBack");
}
function switchTab(option) {
    return navigate(option, "switchTab");
}
function reLaunch(option) {
    return navigate(option, "reLaunch");
}
function getCurrentPages() {
    if (RouterConfig.mode === "multi") {
        console.warn("\u591A\u9875\u9762\u8DEF\u7531\u6A21\u5F0F\u4E0D\u652F\u6301\u4F7F\u7528 getCurrentPages \u65B9\u6CD5\uFF01");
    }
    const pages = stack_default.get();
    return pages.map((e)=>{
        var _a;
        return Object.assign(Object.assign({}, e), {
            route: ((_a = e.path) === null || _a === void 0 ? void 0 : _a.replace(/\?.*/g, "")) || ""
        });
    });
}
// node_modules/@tarojs/router/dist/utils/navigate.js
var import_mobile_detect = __toESM(require_mobile_detect());
var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var md;
var preTitle = document.title;
function getMobileDetect() {
    if (!md) {
        md = new import_mobile_detect.default(navigator.userAgent);
    }
    return md;
}
function setTitle(title) {
    return __awaiter2(this, void 0, void 0, function*() {
        if (preTitle === title) return title;
        document.title = title;
        preTitle = title;
        if (false) {
            if (!isLoadDdEntry) {
                isLoadDdEntry = true;
            }
            const setDingTitle = null.default;
            setDingTitle({
                title
            });
        }
        return title;
    });
}
// node_modules/@tarojs/router/dist/router/multi-page.js
var import_query_string4 = __toESM(require_query_string());
// node_modules/@tarojs/router/dist/events/resize.js
var pageResizeFn;
function bindPageResize(page) {
    pageResizeFn && window.removeEventListener("resize", pageResizeFn);
    pageResizeFn = function() {
        page.onResize && page.onResize({
            size: {
                windowHeight: window.innerHeight,
                windowWidth: window.innerWidth
            }
        });
    };
    window.addEventListener("resize", pageResizeFn, false);
}
// node_modules/@tarojs/router/dist/events/scroll.js
var pageScrollFn = {};
var pageDOM = window;
function bindPageScroll(page, pageEl, distance = 50) {
    var _a;
    const pagePath = page ? page === null || page === void 0 ? void 0 : page.path : (_a = Current.router) === null || _a === void 0 ? void 0 : _a.path;
    pageScrollFn[pagePath] && pageEl.removeEventListener("scroll", pageScrollFn[pagePath]);
    pageDOM = pageEl;
    let isReachBottom = false;
    pageScrollFn[pagePath] = function() {
        var _a2;
        (_a2 = page.onPageScroll) === null || _a2 === void 0 ? void 0 : _a2.call(page, {
            scrollTop: pageDOM instanceof Window ? window.scrollY : pageDOM.scrollTop
        });
        if (isReachBottom && getOffset() > distance) {
            isReachBottom = false;
        }
        if (page.onReachBottom && !isReachBottom && getOffset() < distance) {
            isReachBottom = true;
            page.onReachBottom();
        }
    };
    pageDOM.addEventListener("scroll", pageScrollFn[pagePath], false);
}
function getOffset() {
    if (pageDOM instanceof Window) {
        return document.documentElement.scrollHeight - window.scrollY - window.innerHeight;
    } else {
        return pageDOM.scrollHeight - pageDOM.scrollTop - pageDOM.clientHeight;
    }
}
// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
    } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
}
// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread2(target) {
    for(var i2 = 1; i2 < arguments.length; i2++){
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
    for(var i2 = 0; i2 < props.length; i2++){
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
// node_modules/@tarojs/api/dist/index.esm.js
function isFunction2(x) {
    return typeof x === "function";
}
function isUndefined(x) {
    return typeof x === "undefined";
}
function isObject(x) {
    return x && _typeof(x) === "object";
}
var isBadObj = function isBadObj2(x) {
    return !isObject(x);
};
function throwTypeError(s) {
    throw new TypeError(s);
}
if (!isFunction2(Object.assign)) {
    Object.assign = function(target) {
        if (target == null) {
            throwTypeError("Cannot convert undefined or null to object");
        }
        var to = Object(target);
        for(var index2 = 1; index2 < arguments.length; index2++){
            var nextSource = arguments[index2];
            if (nextSource != null) {
                for(var nextKey in nextSource){
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };
}
if (!isFunction2(Object.defineProperties)) {
    Object.defineProperties = function(obj, properties) {
        function convertToDescriptor(desc) {
            function hasProperty(obj2, prop) {
                return Object.prototype.hasOwnProperty.call(obj2, prop);
            }
            if (isBadObj(desc)) {
                throwTypeError("bad desc");
            }
            var d = {};
            if (hasProperty(desc, "enumerable")) d.enumerable = !!desc.enumerable;
            if (hasProperty(desc, "configurable")) {
                d.configurable = !!desc.configurable;
            }
            if (hasProperty(desc, "value")) d.value = desc.value;
            if (hasProperty(desc, "writable")) d.writable = !!desc.writable;
            if (hasProperty(desc, "get")) {
                var g = desc.get;
                if (!isFunction2(g) && !isUndefined(g)) {
                    throwTypeError("bad get");
                }
                d.get = g;
            }
            if (hasProperty(desc, "set")) {
                var s = desc.set;
                if (!isFunction2(s) && !isUndefined(s)) {
                    throwTypeError("bad set");
                }
                d.set = s;
            }
            if (("get" in d || "set" in d) && ("value" in d || "writable" in d)) {
                throwTypeError("identity-confused descriptor");
            }
            return d;
        }
        if (isBadObj(obj)) throwTypeError("bad obj");
        properties = Object(properties);
        var keys = Object.keys(properties);
        var descs = [];
        for(var i2 = 0; i2 < keys.length; i2++){
            descs.push([
                keys[i2],
                convertToDescriptor(properties[keys[i2]])
            ]);
        }
        for(var _i = 0; _i < descs.length; _i++){
            Object.defineProperty(obj, descs[_i][0], descs[_i][1]);
        }
        return obj;
    };
}
var ENV_TYPE = {
    WEAPP: "WEAPP",
    WEB: "WEB",
    RN: "RN",
    SWAN: "SWAN",
    ALIPAY: "ALIPAY",
    TT: "TT",
    QQ: "QQ",
    JD: "JD"
};
function getEnv() {
    if (false) {
        return ENV_TYPE.WEAPP;
    } else if (false) {
        return ENV_TYPE.ALIPAY;
    } else if (false) {
        return ENV_TYPE.SWAN;
    } else if (false) {
        return ENV_TYPE.TT;
    } else if (false) {
        return ENV_TYPE.JD;
    } else if (false) {
        return ENV_TYPE.QQ;
    } else if (true) {
        return ENV_TYPE.WEB;
    } else if (false) {
        return ENV_TYPE.RN;
    } else {
        return "h5";
    }
}
var Chain = function() {
    function Chain2(requestParams, interceptors3, index2) {
        _classCallCheck(this, Chain2);
        this.index = index2 || 0;
        this.requestParams = requestParams;
        this.interceptors = interceptors3 || [];
    }
    _createClass(Chain2, [
        {
            key: "proceed",
            value: function proceed(requestParams) {
                this.requestParams = requestParams;
                if (this.index >= this.interceptors.length) {
                    throw new Error("chain \u53C2\u6570\u9519\u8BEF, \u8BF7\u52FF\u76F4\u63A5\u4FEE\u6539 request.chain");
                }
                var nextInterceptor = this._getNextInterceptor();
                var nextChain = this._getNextChain();
                var p = nextInterceptor(nextChain);
                var res = p.catch(function(err) {
                    return Promise.reject(err);
                });
                Object.keys(p).forEach(function(k) {
                    return isFunction2(p[k]) && (res[k] = p[k]);
                });
                return res;
            }
        },
        {
            key: "_getNextInterceptor",
            value: function _getNextInterceptor() {
                return this.interceptors[this.index];
            }
        },
        {
            key: "_getNextChain",
            value: function _getNextChain() {
                return new Chain2(this.requestParams, this.interceptors, this.index + 1);
            }
        }
    ]);
    return Chain2;
}();
var Link = function() {
    function Link4(interceptor) {
        _classCallCheck(this, Link4);
        this.taroInterceptor = interceptor;
        this.chain = new Chain();
    }
    _createClass(Link4, [
        {
            key: "request",
            value: function request2(requestParams) {
                var chain = this.chain;
                var taroInterceptor2 = this.taroInterceptor;
                chain.interceptors = chain.interceptors.filter(function(interceptor) {
                    return interceptor !== taroInterceptor2;
                }).concat(taroInterceptor2);
                return chain.proceed(_objectSpread2({}, requestParams));
            }
        },
        {
            key: "addInterceptor",
            value: function addInterceptor2(interceptor) {
                this.chain.interceptors.push(interceptor);
            }
        },
        {
            key: "cleanInterceptors",
            value: function cleanInterceptors() {
                this.chain = new Chain();
            }
        }
    ]);
    return Link4;
}();
function timeoutInterceptor(chain) {
    var requestParams = chain.requestParams;
    var p;
    var res = new Promise(function(resolve, reject) {
        var timeout = setTimeout(function() {
            timeout = null;
            reject(new Error("\u7F51\u7EDC\u94FE\u63A5\u8D85\u65F6,\u8BF7\u7A0D\u540E\u518D\u8BD5\uFF01"));
        }, requestParams && requestParams.timeout || 6e4);
        p = chain.proceed(requestParams);
        p.then(function(res2) {
            if (!timeout) return;
            clearTimeout(timeout);
            resolve(res2);
        }).catch(function(err) {
            timeout && clearTimeout(timeout);
            reject(err);
        });
    });
    if (!isUndefined(p) && isFunction2(p.abort)) res.abort = p.abort;
    return res;
}
function logInterceptor(chain) {
    var requestParams = chain.requestParams;
    var method = requestParams.method, data = requestParams.data, url = requestParams.url;
    if (true) {
        console.log("http ".concat(method || "GET", " --> ").concat(url, " data: "), data);
    }
    var p = chain.proceed(requestParams);
    var res = p.then(function(res2) {
        if (true) {
            console.log("http <-- ".concat(url, " result:"), res2);
        }
        return res2;
    });
    if (isFunction2(p.abort)) res.abort = p.abort;
    return res;
}
var interceptors = Object.freeze({
    __proto__: null,
    timeoutInterceptor,
    logInterceptor
});
function Behavior(options3) {
    return options3;
}
function getPreload(current) {
    return function(key, val) {
        current.preloadData = isObject(key) ? key : _defineProperty({}, key, val);
    };
}
var defaultDesignWidth = 750;
var defaultDesignRatio = {
    640: 2.34 / 2,
    750: 1,
    828: 1.81 / 2
};
var defaultBaseFontSize = 20;
function getInitPxTransform(taro2) {
    return function(config) {
        var _config$designWidth = config.designWidth, designWidth = _config$designWidth === void 0 ? defaultDesignWidth : _config$designWidth, _config$deviceRatio = config.deviceRatio, deviceRatio = _config$deviceRatio === void 0 ? defaultDesignRatio : _config$deviceRatio, _config$baseFontSize = config.baseFontSize, baseFontSize = _config$baseFontSize === void 0 ? defaultBaseFontSize : _config$baseFontSize;
        taro2.config = taro2.config || {};
        taro2.config.designWidth = designWidth;
        taro2.config.deviceRatio = deviceRatio;
        taro2.config.baseFontSize = baseFontSize;
    };
}
function getPxTransform(taro2) {
    return function(size) {
        var config = taro2.config || {};
        var deviceRatio = config.deviceRatio || defaultDesignRatio;
        var designWidth = function() {
            var input = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return isFunction2(config.designWidth) ? config.designWidth(input) : config.designWidth || defaultDesignWidth;
        }(size);
        if (!(designWidth in deviceRatio)) {
            throw new Error("deviceRatio \u914D\u7F6E\u4E2D\u4E0D\u5B58\u5728 ".concat(designWidth, " \u7684\u8BBE\u7F6E\uFF01"));
        }
        return parseInt(size, 10) * deviceRatio[designWidth] + "rpx";
    };
}
var Taro = {
    Behavior,
    getEnv,
    ENV_TYPE,
    Link,
    interceptors,
    Current,
    getCurrentInstance,
    options,
    nextTick,
    eventCenter,
    Events,
    getInitPxTransform
};
Taro.initPxTransform = getInitPxTransform(Taro);
Taro.preload = getPreload(Current);
Taro.pxTransform = getPxTransform(Taro);
// node_modules/universal-router/module.js
var import_path_to_regexp = __toESM(require_path_to_regexp());
var hasOwnProperty = Object.prototype.hasOwnProperty;
var cache = /* @__PURE__ */ new Map();
function decodeParam(val) {
    try {
        return decodeURIComponent(val);
    } catch (err) {
        return val;
    }
}
function matchPath(route, pathname, parentKeys, parentParams) {
    var end = !route.children;
    var cacheKey = (route.path || "") + "|" + end;
    var regexp = cache.get(cacheKey);
    if (!regexp) {
        var keys = [];
        regexp = {
            keys,
            pattern: (0, import_path_to_regexp.default)(route.path || "", keys, {
                end
            })
        };
        cache.set(cacheKey, regexp);
    }
    var m = regexp.pattern.exec(pathname);
    if (!m) {
        return null;
    }
    var path = m[0];
    var params = Object.assign({}, parentParams);
    for(var i2 = 1; i2 < m.length; i2++){
        var key = regexp.keys[i2 - 1];
        var prop = key.name;
        var value = m[i2];
        if (value !== void 0 || !hasOwnProperty.call(params, prop)) {
            if (key.repeat) {
                params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];
            } else {
                params[prop] = value ? decodeParam(value) : value;
            }
        }
    }
    return {
        path: !end && path.charAt(path.length - 1) === "/" ? path.substr(1) : path,
        keys: parentKeys.concat(regexp.keys),
        params
    };
}
function matchRoute(route, baseUrl, pathname, parentKeys, parentParams) {
    var match;
    var childMatches;
    var childIndex = 0;
    return {
        next: function next2(routeToSkip) {
            if (route === routeToSkip) {
                return {
                    done: true
                };
            }
            if (!match) {
                match = matchPath(route, pathname, parentKeys, parentParams);
                if (match) {
                    return {
                        done: false,
                        value: {
                            route,
                            baseUrl,
                            path: match.path,
                            keys: match.keys,
                            params: match.params
                        }
                    };
                }
            }
            if (match && route.children) {
                while(childIndex < route.children.length){
                    if (!childMatches) {
                        var childRoute = route.children[childIndex];
                        childRoute.parent = route;
                        childMatches = matchRoute(childRoute, baseUrl + match.path, pathname.substr(match.path.length), match.keys, match.params);
                    }
                    var childMatch = childMatches.next(routeToSkip);
                    if (!childMatch.done) {
                        return {
                            done: false,
                            value: childMatch.value
                        };
                    }
                    childMatches = null;
                    childIndex++;
                }
            }
            return {
                done: true
            };
        }
    };
}
function resolveRoute(context, params) {
    if (typeof context.route.action === "function") {
        return context.route.action(context, params);
    }
    return void 0;
}
function isChildRoute(parentRoute, childRoute) {
    var route = childRoute;
    while(route){
        route = route.parent;
        if (route === parentRoute) {
            return true;
        }
    }
    return false;
}
var UniversalRouter = function() {
    function UniversalRouter2(routes, options3) {
        if (options3 === void 0) {
            options3 = {};
        }
        if (!routes || typeof routes !== "object") {
            throw new TypeError("Invalid routes");
        }
        this.baseUrl = options3.baseUrl || "";
        this.errorHandler = options3.errorHandler;
        this.resolveRoute = options3.resolveRoute || resolveRoute;
        this.context = Object.assign({
            router: this
        }, options3.context);
        this.root = Array.isArray(routes) ? {
            path: "",
            children: routes,
            parent: null
        } : routes;
        this.root.parent = null;
    }
    var _proto = UniversalRouter2.prototype;
    _proto.resolve = function resolve(pathnameOrContext) {
        var _this = this;
        var context = Object.assign({}, this.context, {}, typeof pathnameOrContext === "string" ? {
            pathname: pathnameOrContext
        } : pathnameOrContext);
        var match = matchRoute(this.root, this.baseUrl, context.pathname.substr(this.baseUrl.length), [], null);
        var resolve2 = this.resolveRoute;
        var matches = null;
        var nextMatches = null;
        var currentContext = context;
        function next2(resume, parent2, prevResult) {
            if (parent2 === void 0) {
                parent2 = matches.value.route;
            }
            var routeToSkip = prevResult === null && !matches.done && matches.value.route;
            matches = nextMatches || match.next(routeToSkip);
            nextMatches = null;
            if (!resume) {
                if (matches.done || !isChildRoute(parent2, matches.value.route)) {
                    nextMatches = matches;
                    return Promise.resolve(null);
                }
            }
            if (matches.done) {
                var error = new Error("Route not found");
                error.status = 404;
                return Promise.reject(error);
            }
            currentContext = Object.assign({}, context, {}, matches.value);
            return Promise.resolve(resolve2(currentContext, matches.value.params)).then(function(result) {
                if (result !== null && result !== void 0) {
                    return result;
                }
                return next2(resume, parent2, result);
            });
        }
        context.next = next2;
        return Promise.resolve().then(function() {
            return next2(true, _this.root);
        })["catch"](function(error) {
            if (_this.errorHandler) {
                return _this.errorHandler(error, currentContext);
            }
            throw error;
        });
    };
    return UniversalRouter2;
}();
UniversalRouter.pathToRegexp = import_path_to_regexp.default;
var module_default = UniversalRouter;
// node_modules/@tarojs/router/dist/router/page.js
var import_query_string = __toESM(require_query_string());
// node_modules/@tarojs/router/dist/animation.js
function loadAnimateStyle(ms = 300) {
    const css2 = `
.taro_router .taro_page {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: #fff;
  transform: translate(100%, 0);
  transition: transform ${ms}ms;
  z-index: 0;
}

.taro_router .taro_page.taro_tabbar_page,
.taro_router .taro_page.taro_page_show.taro_page_stationed {
  transform: none;
}

.taro_router .taro_page.taro_page_show {
  transform: translate(0, 0);
}`;
    const style = document.createElement("style");
    style.innerHTML = css2;
    document.getElementsByTagName("head")[0].appendChild(style);
}
// node_modules/@tarojs/router/dist/router/page.js
function setDisplay(el, type = "") {
    if (el) {
        el.style.display = type;
    }
}
var PageHandler = class {
    get currentPage() {
        const routePath = getCurrentPage(this.routerMode, this.basename);
        return routePath === "/" ? this.homePage : routePath;
    }
    get appId() {
        return this.config.appId || "app";
    }
    get router() {
        return this.config.router || {};
    }
    get routerMode() {
        return this.router.mode || "hash";
    }
    get customRoutes() {
        return this.router.customRoutes || {};
    }
    get routes() {
        return this.config.routes || [];
    }
    get tabBarList() {
        var _a;
        return ((_a = this.config.tabBar) === null || _a === void 0 ? void 0 : _a.list) || [];
    }
    get PullDownRefresh() {
        return this.config.PullDownRefresh;
    }
    get animation() {
        var _a, _b;
        return (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.animation) !== null && _b !== void 0 ? _b : this.defaultAnimation;
    }
    get animationDelay() {
        var _a;
        return (typeof this.animation === "object" ? this.animation.delay : this.animation ? (_a = this.defaultAnimation) === null || _a === void 0 ? void 0 : _a.delay : 0) || 0;
    }
    get animationDuration() {
        var _a;
        return (typeof this.animation === "object" ? this.animation.duration : this.animation ? (_a = this.defaultAnimation) === null || _a === void 0 ? void 0 : _a.duration : 0) || 0;
    }
    set pathname(p) {
        this.router.pathname = p;
    }
    get pathname() {
        return this.router.pathname;
    }
    get basename() {
        return this.router.basename || "";
    }
    get pageConfig() {
        const routePath = addLeadingSlash(stripBasename(this.pathname, this.basename));
        const homePage = addLeadingSlash(this.homePage);
        return this.routes.find((r)=>{
            var _a;
            const pagePath = addLeadingSlash(r.path);
            return [
                pagePath,
                homePage
            ].includes(routePath) || ((_a = routesAlias.getConfig(pagePath)) === null || _a === void 0 ? void 0 : _a.includes(routePath));
        });
    }
    isTabBar(pathname) {
        var _a;
        const routePath = addLeadingSlash(stripBasename(pathname, this.basename)).split("?")[0];
        const pagePath = ((_a = Object.entries(this.customRoutes).find(([, target])=>{
            if (typeof target === "string") {
                return target === routePath;
            } else if ((target === null || target === void 0 ? void 0 : target.length) > 0) {
                return target.includes(routePath);
            }
            return false;
        })) === null || _a === void 0 ? void 0 : _a[0]) || routePath;
        return !!pagePath && this.tabBarList.some((t)=>stripTrailing(t.pagePath) === pagePath);
    }
    isSamePage(page) {
        const routePath = stripBasename(this.pathname, this.basename);
        const pagePath = stripBasename(page === null || page === void 0 ? void 0 : page.path, this.basename);
        return pagePath.startsWith(routePath + "?");
    }
    get search() {
        let search = "?";
        if (this.routerMode === "hash") {
            const idx = location.hash.indexOf("?");
            if (idx > -1) {
                search = location.hash.slice(idx);
            }
        } else {
            search = location.search;
        }
        return search.substring(1);
    }
    getQuery(stamp = "", search = "", options3 = {}) {
        search = search ? `${search}&${this.search}` : this.search;
        const query = search ? import_query_string.default.parse(search, {
            decode: false
        }) : {};
        query.stamp = stamp;
        return Object.assign(Object.assign({}, query), options3);
    }
    mount() {
        setHistoryMode(this.routerMode, this.router.basename);
        this.animation && loadAnimateStyle(this.animationDuration);
        const appId = this.appId;
        let app = document.getElementById(appId);
        if (!app) {
            app = document.createElement("div");
            app.id = appId;
        }
        app.classList.add("taro_router");
        if (this.tabBarList.length > 1) {
            const container = document.createElement("div");
            container.classList.add("taro-tabbar__container");
            container.id = "container";
            const panel = document.createElement("div");
            panel.classList.add("taro-tabbar__panel");
            panel.appendChild(app);
            container.appendChild(panel);
            document.body.appendChild(container);
            initTabbar(this.config);
        } else {
            document.body.appendChild(app);
        }
    }
    onReady(page, onLoad = true) {
        var _a, _b;
        const pageEl = this.getPageContainer(page);
        if (pageEl && !(pageEl === null || pageEl === void 0 ? void 0 : pageEl["__isReady"])) {
            const el = pageEl.firstElementChild;
            (_b = (_a = el === null || el === void 0 ? void 0 : el["componentOnReady"]) === null || _a === void 0 ? void 0 : _a.call(el)) === null || _b === void 0 ? void 0 : _b.then(()=>{
                _raf(()=>{
                    var _a2;
                    (_a2 = page.onReady) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                    pageEl["__isReady"] = true;
                });
            });
            onLoad && (pageEl["__page"] = page);
        }
    }
    load(page, pageConfig = {}, stampId, pageNo = 0) {
        var _a, _b;
        if (!page) return;
        stack_default.push(page);
        const param = this.getQuery(stampId, "", page.options);
        let pageEl = this.getPageContainer(page);
        if (pageEl) {
            setDisplay(pageEl);
            this.isTabBar(this.pathname) && pageEl.classList.add("taro_tabbar_page");
            this.addAnimation(pageEl, pageNo === 0);
            (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
            this.bindPageEvents(page, pageEl, pageConfig);
        } else {
            (_b = page.onLoad) === null || _b === void 0 ? void 0 : _b.call(page, param, ()=>{
                var _a2;
                pageEl = this.getPageContainer(page);
                this.isTabBar(this.pathname) && (pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_tabbar_page"));
                this.addAnimation(pageEl, pageNo === 0);
                this.onReady(page, true);
                (_a2 = page.onShow) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                this.bindPageEvents(page, pageEl, pageConfig);
            });
        }
    }
    unload(page, delta = 1, top = false) {
        var _a, _b, _c;
        if (!page) return;
        stack_default.delta = --delta;
        stack_default.pop();
        if (this.animation && top) {
            if (this.unloadTimer) {
                clearTimeout(this.unloadTimer);
                (_b = (_a = this.lastUnloadPage) === null || _a === void 0 ? void 0 : _a.onUnload) === null || _b === void 0 ? void 0 : _b.call(_a);
                this.unloadTimer = null;
            }
            this.lastUnloadPage = page;
            const pageEl = this.getPageContainer(page);
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_stationed");
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_show");
            this.unloadTimer = setTimeout(()=>{
                var _a2, _b2;
                this.unloadTimer = null;
                (_b2 = (_a2 = this.lastUnloadPage) === null || _a2 === void 0 ? void 0 : _a2.onUnload) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
            }, this.animationDuration);
        } else {
            const pageEl = this.getPageContainer(page);
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_stationed");
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_show");
            (_c = page === null || page === void 0 ? void 0 : page.onUnload) === null || _c === void 0 ? void 0 : _c.call(page);
        }
        if (delta >= 1) this.unload(stack_default.last, delta);
    }
    show(page, pageConfig = {}, pageNo = 0) {
        var _a, _b;
        if (!page) return;
        const param = this.getQuery(page["$taroParams"]["stamp"], "", page.options);
        let pageEl = this.getPageContainer(page);
        if (pageEl) {
            setDisplay(pageEl);
            this.addAnimation(pageEl, pageNo === 0);
            (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
            this.bindPageEvents(page, pageEl, pageConfig);
        } else {
            (_b = page.onLoad) === null || _b === void 0 ? void 0 : _b.call(page, param, ()=>{
                var _a2;
                pageEl = this.getPageContainer(page);
                this.addAnimation(pageEl, pageNo === 0);
                this.onReady(page, false);
                (_a2 = page.onShow) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                this.bindPageEvents(page, pageEl, pageConfig);
            });
        }
    }
    hide(page) {
        var _a;
        if (!page) return;
        const pageEl = this.getPageContainer(page);
        if (pageEl) {
            if (this.hideTimer) {
                clearTimeout(this.hideTimer);
                this.hideTimer = null;
                setDisplay(this.lastHidePage, "none");
            }
            this.lastHidePage = pageEl;
            this.hideTimer = setTimeout(()=>{
                this.hideTimer = null;
                setDisplay(this.lastHidePage, "none");
            }, this.animationDuration + this.animationDelay);
            (_a = page.onHide) === null || _a === void 0 ? void 0 : _a.call(page);
        } else {
            setTimeout(()=>this.hide(page), 0);
        }
    }
    addAnimation(pageEl, first = false) {
        if (!pageEl) return;
        if (this.animation && !first) {
            setTimeout(()=>{
                pageEl.classList.add("taro_page_show");
                setTimeout(()=>{
                    pageEl.classList.add("taro_page_stationed");
                }, this.animationDuration);
            }, this.animationDelay);
        } else {
            pageEl.classList.add("taro_page_show");
            pageEl.classList.add("taro_page_stationed");
        }
    }
    getPageContainer(page) {
        var _a;
        const path = page ? page === null || page === void 0 ? void 0 : page.path : (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path;
        const id = path === null || path === void 0 ? void 0 : path.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, "\\$1");
        if (page) {
            return document.querySelector(`.taro_page#${id}`);
        }
        const el = id ? document.querySelector(`.taro_page#${id}`) : document.querySelector(".taro_page") || document.querySelector(".taro_router");
        return el || window;
    }
    bindPageEvents(page, pageEl, config = {}) {
        var _a;
        if (!pageEl) {
            pageEl = this.getPageContainer();
        }
        const distance = config.onReachBottomDistance || ((_a = this.config.window) === null || _a === void 0 ? void 0 : _a.onReachBottomDistance) || 50;
        bindPageScroll(page, pageEl, distance);
        bindPageResize(page);
    }
    constructor(config){
        this.defaultAnimation = {
            duration: 300,
            delay: 50
        };
        this.config = config;
        this.homePage = getHomePage(this.routes[0].path, this.basename, this.customRoutes, this.config.entryPagePath);
        this.mount();
    }
};
// node_modules/@tarojs/router/dist/router/spa.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var createStampId = incrementId();
var launchStampId = createStampId();
function createRouter(app, config, framework) {
    var _a, _b;
    RouterConfig.config = config;
    const handler = new PageHandler(config);
    routesAlias.set(handler.router.customRoutes);
    const basename2 = handler.router.basename;
    const routes = handler.routes.map((route)=>{
        const routePath2 = addLeadingSlash(route.path);
        const paths = routesAlias.getAll(routePath2);
        return {
            path: paths.length < 1 ? routePath2 : paths,
            action: route.load
        };
    });
    const router = new module_default(routes, {
        baseUrl: basename2 || ""
    });
    const launchParam = {
        path: handler.currentPage,
        query: handler.getQuery(launchStampId),
        scene: 0,
        shareTicket: "",
        referrerInfo: {}
    };
    eventCenter.trigger("__taroRouterLaunch", launchParam);
    (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, launchParam);
    app.onError && window.addEventListener("error", (e)=>{
        var _a2;
        return (_a2 = app.onError) === null || _a2 === void 0 ? void 0 : _a2.call(app, e.message);
    });
    const render2 = ({ location: location2 , action  })=>__awaiter3(this, void 0, void 0, function*() {
            var _c, _d, _e, _f, _g;
            handler.pathname = decodeURI(location2.pathname);
            eventCenter.trigger("__taroRouterChange", {
                toLocation: {
                    path: handler.pathname
                }
            });
            let element, params;
            try {
                const result = yield router.resolve(handler.router.forcePath || handler.pathname);
                [element, , params] = yield Promise.all(result);
            } catch (error) {
                if (error.status === 404) {
                    (_c = app.onPageNotFound) === null || _c === void 0 ? void 0 : _c.call(app, {
                        path: handler.pathname
                    });
                } else if (/Loading hot update .* failed./.test(error.message)) {
                    window.location.reload();
                } else {
                    throw new Error(error);
                }
            }
            if (!element) return;
            const pageConfig = handler.pageConfig;
            let enablePullDownRefresh = ((_d = config === null || config === void 0 ? void 0 : config.window) === null || _d === void 0 ? void 0 : _d.enablePullDownRefresh) || false;
            if (pageConfig) {
                setTitle((_e = pageConfig.navigationBarTitleText) !== null && _e !== void 0 ? _e : document.title);
                if (typeof pageConfig.enablePullDownRefresh === "boolean") {
                    enablePullDownRefresh = pageConfig.enablePullDownRefresh;
                }
            }
            const currentPage = Current.page;
            const pathname = handler.pathname;
            const methodName = (_f = stack_default.method) !== null && _f !== void 0 ? _f : "";
            const cacheTabs = stack_default.getTabs();
            let shouldLoad = false;
            stack_default.method = "";
            if (methodName === "reLaunch") {
                handler.unload(currentPage, stack_default.length);
                for(const key in cacheTabs){
                    if (cacheTabs[key]) {
                        handler.unload(cacheTabs[key]);
                        stack_default.removeTab(key);
                    }
                }
                shouldLoad = true;
            } else if (currentPage && handler.isTabBar(handler.pathname)) {
                if (handler.isSamePage(currentPage)) return;
                if (handler.isTabBar(currentPage.path)) {
                    handler.hide(currentPage);
                    stack_default.pushTab(currentPage.path.split("?")[0]);
                } else if (stack_default.length > 0) {
                    const firstIns = stack_default.getItem(0);
                    if (handler.isTabBar(firstIns.path)) {
                        handler.unload(currentPage, stack_default.length - 1);
                        stack_default.pushTab(firstIns.path.split("?")[0]);
                    } else {
                        handler.unload(currentPage, stack_default.length);
                    }
                }
                if (cacheTabs[handler.pathname]) {
                    stack_default.popTab(handler.pathname);
                    return handler.show(stack_default.getItem(0), pageConfig, 0);
                }
                shouldLoad = true;
            } else if (action === "POP") {
                const prevIndex = stack_default.getPrevIndex(pathname);
                const delta = stack_default.getDelta(pathname);
                if (currentPage !== stack_default.getItem(prevIndex)) {
                    handler.unload(currentPage, delta, prevIndex > -1);
                    if (prevIndex > -1) {
                        handler.show(stack_default.getItem(prevIndex), pageConfig, prevIndex);
                    } else {
                        shouldLoad = true;
                    }
                }
            } else if (action === "REPLACE") {
                const delta = stack_default.getDelta(pathname);
                handler.unload(currentPage, delta);
                shouldLoad = true;
            } else if (action === "PUSH") {
                handler.hide(currentPage);
                shouldLoad = true;
            }
            if (shouldLoad || stack_default.length < 1) {
                const el = (_g = element.default) !== null && _g !== void 0 ? _g : element;
                const loadConfig = Object.assign({}, pageConfig);
                const stacksIndex = stack_default.length;
                delete loadConfig["path"];
                delete loadConfig["load"];
                let pageStampId = "";
                if (launchStampId) {
                    pageStampId = launchStampId;
                    launchStampId = "";
                } else {
                    pageStampId = createStampId();
                }
                const page = createPageConfig(enablePullDownRefresh ? hooks.call("createPullDownComponent", el, location2.pathname, framework, handler.PullDownRefresh) : el, pathname + stringify(handler.getQuery(pageStampId)), {}, loadConfig);
                if (params) page.options = params;
                handler.load(page, pageConfig, pageStampId, stacksIndex);
            }
            eventCenter.trigger("__afterTaroRouterChange", {
                toLocation: {
                    path: handler.pathname
                }
            });
        });
    const routePath = addLeadingSlash(stripBasename(history.location.pathname, handler.basename));
    if (routePath === "/") {
        history.replace(prependBasename(handler.homePage + history.location.search));
    }
    render2({
        location: history.location,
        action: Action.Push
    });
    (_b = app.onShow) === null || _b === void 0 ? void 0 : _b.call(app, launchParam);
    return history.listen(render2);
}
// node_modules/@tarojs/taro-h5/dist/utils/handler.js
var MethodHandler = class {
    success(res = {}, promise = {}) {
        if (!res.errMsg) {
            res.errMsg = `${this.methodName}:ok`;
        }
        isFunction(this.__success) && this.__success(res);
        isFunction(this.__complete) && this.__complete(res);
        const { resolve =Promise.resolve.bind(Promise)  } = promise;
        return resolve(res);
    }
    fail(res = {}, promise = {}) {
        if (!res.errMsg) {
            res.errMsg = `${this.methodName}:fail`;
        } else {
            res.errMsg = `${this.methodName}:fail ${res.errMsg}`;
        }
        if (true) {
            console.error(res.errMsg);
        }
        isFunction(this.__fail) && this.__fail(res);
        isFunction(this.__complete) && this.__complete(res);
        const { resolve =Promise.resolve.bind(Promise) , reject =Promise.reject.bind(Promise)  } = promise;
        return this.isHandlerError ? resolve(res) : reject(res);
    }
    constructor({ name , success , fail , complete  }){
        this.isHandlerError = false;
        this.methodName = name;
        this.__success = success;
        this.__fail = fail;
        this.__complete = complete;
        this.isHandlerError = isFunction(this.__complete) || isFunction(this.__fail);
    }
};
var CallbackManager = class {
    constructor(){
        this.callbacks = [];
        this.add = (opt)=>{
            if (opt) this.callbacks.push(opt);
        };
        this.remove = (opt)=>{
            if (opt) {
                let pos = -1;
                this.callbacks.forEach((callback, k)=>{
                    if (callback === opt) {
                        pos = k;
                    }
                });
                if (pos > -1) {
                    this.callbacks.splice(pos, 1);
                }
            }
        };
        this.count = ()=>{
            return this.callbacks.length;
        };
        this.trigger = (...args)=>{
            this.callbacks.forEach((opt)=>{
                if (isFunction(opt)) {
                    opt(...args);
                } else {
                    const { callback , ctx  } = opt;
                    isFunction(callback) && callback.call(ctx, ...args);
                }
            });
        };
    }
};
// node_modules/@tarojs/taro-h5/dist/utils/animation.js
var easeInOut = (t)=>t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
var getTimingFunc = (easeFunc, frameCnt)=>{
    return (x)=>{
        if (frameCnt <= 1) {
            return easeFunc(1);
        }
        const t = x / (frameCnt - 1);
        return easeFunc(t);
    };
};
// node_modules/@tarojs/taro-h5/dist/utils/lodash.js
function throttle(fn, threshold = 250, scope) {
    let lastTime = 0;
    let deferTimer;
    return function(...args) {
        const context = scope || this;
        const now2 = Date.now();
        if (now2 - lastTime > threshold) {
            fn.apply(this, args);
            lastTime = now2;
        } else {
            clearTimeout(deferTimer);
            deferTimer = setTimeout(()=>{
                lastTime = now2;
                fn.apply(context, args);
            }, threshold);
        }
    };
}
// node_modules/@tarojs/taro-h5/dist/utils/valid.js
var VALID_COLOR_REG = /^#[0-9a-fA-F]{6}$/;
var isValidColor = (color)=>{
    return VALID_COLOR_REG.test(color);
};
// node_modules/@tarojs/taro-h5/dist/utils/index.js
function shouldBeObject(target) {
    if (target && typeof target === "object") return {
        flag: true
    };
    return {
        flag: false,
        msg: getParameterError({
            correct: "Object",
            wrong: target
        })
    };
}
function findDOM(inst) {
    if (inst && hooks.isExist("getDOMNode")) {
        return hooks.call("getDOMNode", inst);
    }
    const page = Current.page;
    const path = page === null || page === void 0 ? void 0 : page.path;
    const msg = "\u6CA1\u6709\u627E\u5230\u5DF2\u7ECF\u52A0\u8F7D\u4E86\u7684\u9875\u9762\uFF0C\u8BF7\u5728\u9875\u9762\u52A0\u8F7D\u5B8C\u6210\u540E\u65F6\u5019\u6B64 API\u3002";
    if (path == null) {
        throw new Error(msg);
    }
    const el = document.getElementById(path);
    if (el == null) {
        throw new Error("\u5728\u5DF2\u52A0\u8F7D\u9875\u9762\u4E2D\u6CA1\u6709\u627E\u5230\u5BF9\u5E94\u7684\u5BB9\u5668\u5143\u7D20\u3002");
    }
    return el;
}
function getParameterError({ name ="" , para , correct , wrong  }) {
    const parameter = para ? `parameter.${para}` : "parameter";
    const errorType = upperCaseFirstLetter(wrong === null ? "Null" : typeof wrong);
    if (name) {
        return `${name}:fail parameter error: ${parameter} should be ${correct} instead of ${errorType}`;
    } else {
        return `parameter error: ${parameter} should be ${correct} instead of ${errorType}`;
    }
}
function upperCaseFirstLetter(string) {
    if (typeof string !== "string") return string;
    string = string.replace(/^./, (match)=>match.toUpperCase());
    return string;
}
var toKebabCase = function(string) {
    return string.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
};
function inlineStyle(style) {
    let res = "";
    for(const attr2 in style)res += `${attr2}: ${style[attr2]};`;
    if (res.indexOf("display: flex;") >= 0) res += "display: -webkit-box;display: -webkit-flex;";
    res = res.replace(/transform:(.+?);/g, (s, $1)=>`${s}-webkit-transform:${$1};`);
    res = res.replace(/flex-direction:(.+?);/g, (s, $1)=>`${s}-webkit-flex-direction:${$1};`);
    return res;
}
function setTransform(el, val) {
    el.style.webkitTransform = val;
    el.style.transform = val;
}
function serializeParams(params) {
    if (!params) {
        return "";
    }
    return Object.keys(params).map((key)=>`${encodeURIComponent(key)}=${typeof params[key] === "object" ? encodeURIComponent(JSON.stringify(params[key])) : encodeURIComponent(params[key])}`).join("&");
}
function temporarilyNotSupport(name = "") {
    return (option = {}, ...args)=>{
        const { success , fail , complete  } = option;
        const handle3 = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        const errMsg = "\u6682\u65F6\u4E0D\u652F\u6301 API";
        Taro.eventCenter.trigger("__taroNotSupport", {
            name,
            args: [
                option,
                ...args
            ],
            type: "method",
            category: "temporarily"
        });
        if (false) {
            console.warn(errMsg);
            return handle3.success({
                errMsg
            });
        } else {
            return handle3.fail({
                errMsg
            });
        }
    };
}
function weixinCorpSupport(name) {
    return (option = {}, ...args)=>{
        const { success , fail , complete  } = option;
        const handle3 = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        const errMsg = "h5 \u7AEF\u5F53\u524D\u4EC5\u5728\u5FAE\u4FE1\u516C\u4F17\u53F7 JS-SDK \u73AF\u5883\u4E0B\u652F\u6301\u6B64 API";
        Taro.eventCenter.trigger("__taroNotSupport", {
            name,
            args: [
                option,
                ...args
            ],
            type: "method",
            category: "weixin_corp"
        });
        if (false) {
            console.warn(errMsg);
            return handle3.success({
                errMsg
            });
        } else {
            return handle3.fail({
                errMsg
            });
        }
    };
}
function permanentlyNotSupport(name = "") {
    return (option = {}, ...args)=>{
        const { success , fail , complete  } = option;
        const handle3 = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        const errMsg = "\u4E0D\u652F\u6301 API";
        Taro.eventCenter.trigger("__taroNotSupport", {
            name,
            args: [
                option,
                ...args
            ],
            type: "method",
            category: "permanently"
        });
        if (false) {
            console.warn(errMsg);
            return handle3.success({
                errMsg
            });
        } else {
            return handle3.fail({
                errMsg
            });
        }
    };
}
function processOpenApi({ name , defaultOptions , standardMethod , formatOptions =(options3)=>options3 , formatResult =(res)=>res  }) {
    const notSupported = weixinCorpSupport(name);
    return (options3 = {}, ...args)=>{
        var _a;
        const targetApi = (_a = window === null || window === void 0 ? void 0 : window.wx) === null || _a === void 0 ? void 0 : _a[name];
        const opts = formatOptions(Object.assign({}, defaultOptions, options3));
        if (isFunction(targetApi)) {
            return new Promise((resolve, reject)=>{
                [
                    "fail",
                    "success",
                    "complete"
                ].forEach((k)=>{
                    opts[k] = (preRef)=>{
                        const res = formatResult(preRef);
                        options3[k] && options3[k](res);
                        if (k === "success") {
                            resolve(res);
                        } else if (k === "fail") {
                            reject(res);
                        }
                    };
                    return targetApi(opts);
                });
            });
        } else if (isFunction(standardMethod)) {
            return standardMethod(opts);
        } else {
            return notSupported(options3, ...args);
        }
    };
}
function getCurrentPath() {
    var _a, _b, _c, _d, _e, _f;
    const appConfig = window.__taroAppConfig || {};
    const routePath = getCurrentPage((_a = appConfig.router) === null || _a === void 0 ? void 0 : _a.mode, (_b = appConfig.router) === null || _b === void 0 ? void 0 : _b.basename);
    const homePath = getHomePage((_d = (_c = appConfig.routes) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.path, (_e = appConfig.router) === null || _e === void 0 ? void 0 : _e.basename, (_f = appConfig.router) === null || _f === void 0 ? void 0 : _f.customRoutes, appConfig.entryPagePath);
    return `${routePath === "/" ? homePath : routePath}?stamp=1`;
}
// node_modules/@tarojs/taro-h5/dist/api/ad/index.js
var createRewardedVideoAd = temporarilyNotSupport("createRewardedVideoAd");
var createInterstitialAd = temporarilyNotSupport("createInterstitialAd");
// node_modules/@tarojs/taro-h5/dist/api/ai/facial.js
var stopFaceDetect = temporarilyNotSupport("stopFaceDetect");
var initFaceDetect = temporarilyNotSupport("initFaceDetect");
var faceDetect = temporarilyNotSupport("faceDetect");
// node_modules/@tarojs/taro-h5/dist/api/ai/visual.js
var isVKSupport = temporarilyNotSupport("isVKSupport");
var createVKSession = temporarilyNotSupport("createVKSession");
// node_modules/@tarojs/taro-h5/dist/api/alipay/index.js
var getOpenUserInfo = temporarilyNotSupport("getOpenUserInfo");
// node_modules/@tarojs/taro-h5/dist/api/base/index.js
var import_base64_js = __toESM(require_base64_js());
// node_modules/@tarojs/taro-h5/dist/api/base/crypto.js
var getUserCryptoManager = temporarilyNotSupport("getUserCryptoManager");
// node_modules/@tarojs/taro-h5/dist/api/base/debug.js
var setEnableDebug = temporarilyNotSupport("setEnableDebug");
var getRealtimeLogManager = temporarilyNotSupport("getRealtimeLogManager");
var getLogManager = temporarilyNotSupport("getLogManager");
// node_modules/@tarojs/taro-h5/dist/api/base/performance.js
var reportPerformance = temporarilyNotSupport("reportPerformance");
var getPerformance = temporarilyNotSupport("getPerformance");
// node_modules/@tarojs/taro-h5/dist/node_modules/.pnpm/registry.npmjs.org_tslib@1.14.1/node_modules/tslib/tslib.es6.js
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++){
        if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2])) t[p[i2]] = s[p[i2]];
    }
    return t;
}
function __awaiter4(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
// node_modules/@tarojs/taro-h5/dist/api/base/system.js
var openSystemBluetoothSetting = temporarilyNotSupport("openSystemBluetoothSetting");
var openAppAuthorizeSetting = temporarilyNotSupport("openAppAuthorizeSetting");
var getWindowInfo = ()=>{
    const info = {
        pixelRatio: window.devicePixelRatio,
        screenWidth: window.screen.width,
        screenHeight: window.screen.height,
        windowWidth: document.documentElement.clientWidth,
        windowHeight: document.documentElement.clientHeight,
        statusBarHeight: NaN,
        safeArea: {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        }
    };
    return info;
};
var getSystemSetting = ()=>{
    const isLandscape = window.screen.width >= window.screen.height;
    const info = {
        bluetoothEnabled: false,
        locationEnabled: false,
        wifiEnabled: false,
        deviceOrientation: isLandscape ? "landscape" : "portrait"
    };
    return info;
};
var getDeviceInfo = ()=>{
    const md2 = getMobileDetect();
    const info = {
        abi: "",
        deviceAbi: "",
        benchmarkLevel: -1,
        brand: md2.mobile() || "",
        model: md2.mobile() || "",
        system: md2.os(),
        platform: navigator.platform,
        CPUType: ""
    };
    return info;
};
var getAppBaseInfo = ()=>{
    var _a;
    let isDarkMode = false;
    if ((_a = window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, "(prefers-color-scheme: dark)").matches) {
        isDarkMode = true;
    }
    const info = {
        SDKVersion: "",
        enableDebug: true,
        language: navigator.language,
        version: "",
        theme: isDarkMode ? "dark" : "light"
    };
    return info;
};
var getAppAuthorizeSetting = ()=>{
    const info = {
        albumAuthorized: "not determined",
        bluetoothAuthorized: "not determined",
        cameraAuthorized: "not determined",
        locationAuthorized: "not determined",
        locationReducedAccuracy: false,
        microphoneAuthorized: "not determined",
        notificationAuthorized: "not determined",
        notificationAlertAuthorized: "not determined",
        notificationBadgeAuthorized: "not determined",
        notificationSoundAuthorized: "not determined",
        phoneCalendarAuthorized: "not determined"
    };
    return info;
};
var getSystemInfoSync = ()=>{
    const windowInfo = getWindowInfo();
    const systemSetting = getSystemSetting();
    const deviceInfo = getDeviceInfo();
    const appBaseInfo = getAppBaseInfo();
    const appAuthorizeSetting = getAppAuthorizeSetting();
    delete deviceInfo.abi;
    const info = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, windowInfo), systemSetting), deviceInfo), appBaseInfo), {
        fontSizeSetting: NaN,
        albumAuthorized: appAuthorizeSetting.albumAuthorized === "authorized",
        cameraAuthorized: appAuthorizeSetting.cameraAuthorized === "authorized",
        locationAuthorized: appAuthorizeSetting.locationAuthorized === "authorized",
        microphoneAuthorized: appAuthorizeSetting.microphoneAuthorized === "authorized",
        notificationAuthorized: appAuthorizeSetting.notificationAuthorized === "authorized",
        notificationAlertAuthorized: appAuthorizeSetting.notificationAlertAuthorized === "authorized",
        notificationBadgeAuthorized: appAuthorizeSetting.notificationBadgeAuthorized === "authorized",
        notificationSoundAuthorized: appAuthorizeSetting.notificationSoundAuthorized === "authorized",
        phoneCalendarAuthorized: appAuthorizeSetting.phoneCalendarAuthorized === "authorized",
        locationReducedAccuracy: appAuthorizeSetting.locationReducedAccuracy,
        environment: ""
    });
    return info;
};
var getSystemInfoAsync = (options3 = {})=>__awaiter4(void 0, void 0, void 0, function*() {
        const { success , fail , complete  } = options3;
        const handle3 = new MethodHandler({
            name: "getSystemInfoAsync",
            success,
            fail,
            complete
        });
        try {
            const info = yield getSystemInfoSync();
            return handle3.success(info);
        } catch (error) {
            return handle3.fail({
                errMsg: error
            });
        }
    });
var getSystemInfo = (options3 = {})=>__awaiter4(void 0, void 0, void 0, function*() {
        const { success , fail , complete  } = options3;
        const handle3 = new MethodHandler({
            name: "getSystemInfo",
            success,
            fail,
            complete
        });
        try {
            const info = yield getSystemInfoSync();
            return handle3.success(info);
        } catch (error) {
            return handle3.fail({
                errMsg: error
            });
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/base/update.js
var updateWeChatApp = temporarilyNotSupport("updateWeChatApp");
var getUpdateManager = temporarilyNotSupport("getUpdateManager");
// node_modules/@tarojs/taro-h5/dist/api/base/weapp/app-event.js
var import_query_string2 = __toESM(require_query_string());
var appShowCallbackManager = new CallbackManager();
var appHideCallbackManager = new CallbackManager();
var getApp = ()=>{
    var _a;
    const path = (_a = Taro.Current.page) === null || _a === void 0 ? void 0 : _a.path;
    return {
        path: path === null || path === void 0 ? void 0 : path.substring(0, path.indexOf("?")),
        query: (0, import_query_string2.parse)(location.search),
        referrerInfo: {},
        scene: 0,
        shareTicket: ""
    };
};
var appShowListener = ()=>{
    if (document.visibilityState !== "hidden") {
        appShowCallbackManager.trigger(getApp());
    }
};
var appHideListener = ()=>{
    if (document.visibilityState === "hidden") {
        appHideCallbackManager.trigger(getApp());
    }
};
var onUnhandledRejection = temporarilyNotSupport("onUnhandledRejection");
var onThemeChange = temporarilyNotSupport("onThemeChange");
var onPageNotFound = temporarilyNotSupport("onPageNotFound");
var onError = temporarilyNotSupport("onError");
var onAudioInterruptionEnd = temporarilyNotSupport("onAudioInterruptionEnd");
var onAudioInterruptionBegin = temporarilyNotSupport("onAudioInterruptionBegin");
var onAppShow = (callback)=>{
    appShowCallbackManager.add(callback);
    if (appShowCallbackManager.count() === 1) {
        window.addEventListener("visibilitychange", appShowListener);
    }
};
var onAppHide = (callback)=>{
    appHideCallbackManager.add(callback);
    if (appHideCallbackManager.count() === 1) {
        window.addEventListener("visibilitychange", appHideListener);
    }
};
var offUnhandledRejection = temporarilyNotSupport("offUnhandledRejection");
var offThemeChange = temporarilyNotSupport("offThemeChange");
var offPageNotFound = temporarilyNotSupport("offPageNotFound");
var offError = temporarilyNotSupport("offError");
var offAudioInterruptionEnd = temporarilyNotSupport("offAudioInterruptionEnd");
var offAudioInterruptionBegin = temporarilyNotSupport("offAudioInterruptionBegin");
var offAppShow = (callback)=>{
    appShowCallbackManager.remove(callback);
    if (appShowCallbackManager.count() === 0) {
        window.removeEventListener("visibilitychange", appShowListener);
    }
};
var offAppHide = (callback)=>{
    appHideCallbackManager.remove(callback);
    if (appHideCallbackManager.count() === 0) {
        window.removeEventListener("visibilitychange", appHideListener);
    }
};
// node_modules/@tarojs/taro-h5/dist/api/base/weapp/life-cycle.js
var launchOptions = {
    path: "",
    query: {},
    scene: 0,
    shareTicket: "",
    referrerInfo: {}
};
function initLaunchOptions(options3 = {}) {
    Object.assign(launchOptions, options3);
}
Taro.eventCenter.once("__taroRouterLaunch", initLaunchOptions);
var getLaunchOptionsSync = ()=>launchOptions;
var getEnterOptionsSync = ()=>launchOptions;
// node_modules/@tarojs/taro-h5/dist/api/base/index.js
var env = {
    FRAMEWORK: "react",
    TARO_ENV: "h5",
    TARO_VERSION: "3.6.2"
};
var canIUse = temporarilyNotSupport("canIUse");
function arrayBufferToBase64(arrayBuffer) {
    return (0, import_base64_js.fromByteArray)(arrayBuffer);
}
function base64ToArrayBuffer(base64) {
    return (0, import_base64_js.toByteArray)(base64);
}
// node_modules/@tarojs/taro-h5/dist/api/canvas/CanvasContext.js
var TextBaseLineMap = {
    top: "top",
    bottom: "bottom",
    middle: "middle",
    normal: "alphabetic"
};
var CanvasContext = class {
    set ctx(e) {
        this.__raw__ = e;
    }
    get ctx() {
        return this.__raw__ || {};
    }
    emptyActions() {
        this.actions.length = 0;
    }
    enqueueActions(func, ...args) {
        this.actions.push({
            func,
            args
        });
    }
    set fillStyle(e) {
        this.enqueueActions(()=>{
            this.ctx.fillStyle = e;
        });
    }
    get fillStyle() {
        return this.ctx.fillStyle;
    }
    set font(e) {
        this.ctx.font = e;
    }
    get font() {
        return this.ctx.font;
    }
    set globalAlpha(e) {
        this.enqueueActions(()=>{
            this.ctx.globalAlpha = e;
        });
    }
    get globalAlpha() {
        return this.ctx.globalAlpha;
    }
    set globalCompositeOperation(e) {
        this.enqueueActions(()=>{
            this.ctx.globalCompositeOperation = e;
        });
    }
    get globalCompositeOperation() {
        return this.ctx.globalCompositeOperation;
    }
    set lineCap(e) {
        this.enqueueActions(()=>{
            this.ctx.lineCap = e;
        });
    }
    get lineCap() {
        return this.ctx.lineCap;
    }
    set lineDashOffset(e) {
        this.enqueueActions(()=>{
            this.ctx.lineDashOffset = e;
        });
    }
    get lineDashOffset() {
        return this.ctx.lineDashOffset;
    }
    set lineJoin(e) {
        this.enqueueActions(()=>{
            this.ctx.lineJoin = e;
        });
    }
    get lineJoin() {
        return this.ctx.lineJoin;
    }
    set lineWidth(e) {
        this.enqueueActions(()=>{
            this.ctx.lineWidth = e;
        });
    }
    get lineWidth() {
        return this.ctx.lineWidth;
    }
    set miterLimit(e) {
        this.enqueueActions(()=>{
            this.ctx.miterLimit = e;
        });
    }
    get miterLimit() {
        return this.ctx.miterLimit;
    }
    set shadowBlur(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowBlur = e;
        });
    }
    get shadowBlur() {
        return this.ctx.shadowBlur;
    }
    set shadowColor(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowColor = e;
        });
    }
    get shadowColor() {
        return this.ctx.shadowColor;
    }
    set shadowOffsetX(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowOffsetX = e;
        });
    }
    get shadowOffsetX() {
        return this.ctx.shadowOffsetX;
    }
    set shadowOffsetY(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowOffsetY = e;
        });
    }
    get shadowOffsetY() {
        return this.ctx.shadowOffsetY;
    }
    set strokeStyle(e) {
        this.enqueueActions(()=>{
            this.ctx.strokeStyle = e;
        });
    }
    get strokeStyle() {
        return this.ctx.strokeStyle;
    }
    set textAlign(e) {
        this.ctx.textAlign = e;
    }
    get textAlign() {
        return this.ctx.textAlign;
    }
    set textBaseline(e) {
        this.ctx.textBaseline = e;
    }
    get textBaseline() {
        return this.ctx.textBaseline;
    }
    set direction(e) {
        this.ctx.direction = e;
    }
    get direction() {
        return this.ctx.direction;
    }
    set imageSmoothingEnabled(e) {
        this.enqueueActions(()=>{
            this.ctx.imageSmoothingEnabled = e;
        });
    }
    get imageSmoothingEnabled() {
        return this.ctx.imageSmoothingEnabled;
    }
    set imageSmoothingQuality(e) {
        this.enqueueActions(()=>{
            this.ctx.imageSmoothingQuality = e;
        });
    }
    get imageSmoothingQuality() {
        return this.ctx.imageSmoothingQuality;
    }
    set filter(e) {
        this.enqueueActions(()=>{
            this.ctx.filter = e;
        });
    }
    get filter() {
        return this.ctx.filter;
    }
    arc(...args) {
        return this.enqueueActions(this.ctx.arc, ...args);
    }
    arcTo(...args) {
        return this.enqueueActions(this.ctx.arcTo, ...args);
    }
    beginPath(...args) {
        return this.enqueueActions(this.ctx.beginPath, ...args);
    }
    bezierCurveTo(...args) {
        return this.enqueueActions(this.ctx.bezierCurveTo, ...args);
    }
    clearRect(...args) {
        return this.enqueueActions(this.ctx.clearRect, ...args);
    }
    clip(...args) {
        return this.enqueueActions(this.ctx.clip, ...args);
    }
    closePath(...args) {
        return this.enqueueActions(this.ctx.closePath, ...args);
    }
    createPattern(image, repetition) {
        return this.createPattern(image, repetition);
    }
    draw(reserve, callback) {
        return __awaiter4(this, void 0, void 0, function*() {
            try {
                if (!reserve) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                for (const { func , args  } of this.actions){
                    yield func.apply(this.ctx, args);
                }
                this.emptyActions();
                callback && callback();
            } catch (e) {
                throw {
                    errMsg: e.message
                };
            }
        });
    }
    drawImage(imageResource, ...extra) {
        this.enqueueActions(()=>{
            if (typeof imageResource === "string") {
                const img = new Image();
                img.src = imageResource;
                return new Promise((resolve, reject)=>{
                    img.onload = ()=>{
                        this.ctx.drawImage(img, ...extra);
                        resolve();
                    };
                    img.onerror = reject;
                });
            }
            this.ctx.drawImage(imageResource, ...extra);
        });
    }
    fill(...args) {
        return this.enqueueActions(this.ctx.fill, ...args);
    }
    fillRect(...args) {
        return this.enqueueActions(this.ctx.fillRect, ...args);
    }
    fillText(...args) {
        return this.enqueueActions(this.ctx.fillText, ...args);
    }
    lineTo(...args) {
        return this.enqueueActions(this.ctx.lineTo, ...args);
    }
    moveTo(...args) {
        return this.enqueueActions(this.ctx.moveTo, ...args);
    }
    quadraticCurveTo(...args) {
        return this.enqueueActions(this.ctx.quadraticCurveTo, ...args);
    }
    rect(...args) {
        return this.enqueueActions(this.ctx.rect, ...args);
    }
    restore(...args) {
        return this.enqueueActions(this.ctx.restore, ...args);
    }
    rotate(...args) {
        return this.enqueueActions(this.ctx.rotate, ...args);
    }
    save(...args) {
        return this.enqueueActions(this.ctx.save, ...args);
    }
    scale(...args) {
        return this.enqueueActions(this.ctx.scale, ...args);
    }
    setFillStyle(color) {
        this.enqueueActions(()=>{
            this.ctx.fillStyle = color;
        });
    }
    setFontSize(fontSize) {
        this.font = `${fontSize}px`;
    }
    setGlobalAlpha(alpha) {
        this.globalAlpha = alpha;
    }
    setLineCap(lineCap) {
        this.lineCap = lineCap;
    }
    setLineDash(pattern, offset2) {
        this.enqueueActions(()=>{
            this.ctx.setLineDash(pattern);
            this.ctx.lineDashOffset = offset2;
        });
    }
    setLineJoin(lineJoin) {
        this.lineJoin = lineJoin;
    }
    setLineWidth(lineWidth) {
        this.lineWidth = lineWidth;
    }
    setMiterLimit(miterLimit) {
        this.miterLimit = miterLimit;
    }
    setShadow(offsetX, offsetY, blur, color) {
        this.enqueueActions(()=>{
            this.ctx.shadowOffsetX = offsetX;
            this.ctx.shadowOffsetY = offsetY;
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = blur;
        });
    }
    setStrokeStyle(color) {
        this.enqueueActions(()=>{
            this.ctx.strokeStyle = color;
        });
    }
    setTextAlign(align) {
        this.textAlign = align;
    }
    setTextBaseline(textBaseline) {
        this.textBaseline = TextBaseLineMap[textBaseline] || "alphabetic";
    }
    setTransform(...args) {
        return this.enqueueActions(this.ctx.setTransform, ...args);
    }
    stroke(...args) {
        return this.enqueueActions(this.ctx.stroke, ...args);
    }
    strokeRect(...args) {
        return this.enqueueActions(this.ctx.strokeRect, ...args);
    }
    strokeText(...args) {
        return this.enqueueActions(this.ctx.strokeText, ...args);
    }
    transform(...args) {
        return this.enqueueActions(this.ctx.transform, ...args);
    }
    translate(...args) {
        return this.enqueueActions(this.ctx.translate, ...args);
    }
    measureText(text2) {
        return this.ctx.measureText(text2);
    }
    createCircularGradient(x, y, r) {
        const radialGradient = this.ctx.createRadialGradient(x, y, 0, x, y, r);
        return radialGradient;
    }
    createLinearGradient(x0, y0, x1, y1) {
        return this.ctx.createLinearGradient(x0, y0, x1, y1);
    }
    constructor(canvas, ctx){
        this.actions = [];
        this.canvas = canvas;
        this.ctx = ctx;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/createCanvasContext.js
var createCanvasContext = (canvasId, inst)=>{
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext("2d");
    const context = new CanvasContext(canvas, ctx);
    if (!ctx) return context;
    context.canvas = canvas;
    context.ctx = ctx;
    return context;
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/canvasToTempFilePath.js
var canvasToTempFilePath = ({ canvasId , fileType , quality , success , fail , complete  }, inst)=>{
    const handle3 = new MethodHandler({
        name: "canvasToTempFilePath",
        success,
        fail,
        complete
    });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const dataURL = canvas === null || canvas === void 0 ? void 0 : canvas.toDataURL(`image/${(fileType === "jpg" ? "jpeg" : fileType) || "png"}`, quality);
        return handle3.success({
            tempFilePath: dataURL
        });
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/canvasPutImageData.js
var canvasPutImageData = ({ canvasId , data , x , y , success , fail , complete  }, inst)=>{
    const handle3 = new MethodHandler({
        name: "canvasPutImageData",
        success,
        fail,
        complete
    });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const ctx = canvas.getContext("2d");
        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(data, x, y);
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/canvasGetImageData.js
var canvasGetImageData = ({ canvasId , success , fail , complete , x , y , width , height  }, inst)=>{
    const handle3 = new MethodHandler({
        name: "canvasGetImageData",
        success,
        fail,
        complete
    });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext("2d");
        const data = ctx === null || ctx === void 0 ? void 0 : ctx.getImageData(x, y, width, height);
        return handle3.success({
            width,
            height,
            data
        });
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/index.js
var createOffscreenCanvas = temporarilyNotSupport("createOffscreenCanvas");
// node_modules/@tarojs/taro-h5/dist/api/cloud/index.js
var cloud = class {
    constructor(){
        this.init = temporarilyNotSupport("cloud.init");
        this.CloudID = temporarilyNotSupport("cloud.CloudID");
        this.callFunction = temporarilyNotSupport("cloud.callFunction");
        this.uploadFile = temporarilyNotSupport("cloud.uploadFile");
        this.downloadFile = temporarilyNotSupport("cloud.downloadFile");
        this.getTempFileURL = temporarilyNotSupport("cloud.getTempFileURL");
        this.deleteFile = temporarilyNotSupport("cloud.deleteFile");
        this.database = temporarilyNotSupport("cloud.database");
        this.callContainer = temporarilyNotSupport("cloud.callContainer");
    }
};
// node_modules/@tarojs/taro-h5/dist/api/data-analysis/index.js
var reportMonitor = temporarilyNotSupport("reportMonitor");
var reportAnalytics = temporarilyNotSupport("reportAnalytics");
var reportEvent = temporarilyNotSupport("reportEvent");
var getExptInfoSync = temporarilyNotSupport("getExptInfoSync");
// node_modules/@tarojs/taro-h5/dist/api/device/accelerometer.js
var callbackManager = new CallbackManager();
var devicemotionListener;
var stopAccelerometer = ({ success , fail , complete  } = {})=>{
    const res = {};
    const handle3 = new MethodHandler({
        name: "stopAccelerometer",
        success,
        fail,
        complete
    });
    try {
        window.removeEventListener("devicemotion", devicemotionListener, true);
        return handle3.success(res);
    } catch (e) {
        res.errMsg = e.message;
        return handle3.fail(res);
    }
};
var INTERVAL_MAP = {
    game: {
        interval: 20,
        frequency: 50
    },
    ui: {
        interval: 60,
        frequency: 16.67
    },
    normal: {
        interval: 200,
        frequency: 5
    }
};
var startAccelerometer = ({ interval ="normal" , success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "startAccelerometer",
        success,
        fail,
        complete
    });
    try {
        if (window.DeviceMotionEvent) {
            const intervalObj = INTERVAL_MAP[interval];
            if (devicemotionListener) {
                stopAccelerometer();
            }
            devicemotionListener = throttle((evt)=>{
                var _a, _b, _c;
                callbackManager.trigger({
                    x: ((_a = evt.acceleration) === null || _a === void 0 ? void 0 : _a.x) || 0,
                    y: ((_b = evt.acceleration) === null || _b === void 0 ? void 0 : _b.y) || 0,
                    z: ((_c = evt.acceleration) === null || _c === void 0 ? void 0 : _c.z) || 0
                });
            }, intervalObj.interval);
            window.addEventListener("devicemotion", devicemotionListener, true);
        } else {
            throw new Error("accelerometer is not supported");
        }
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var onAccelerometerChange = (callback)=>{
    callbackManager.add(callback);
};
var offAccelerometerChange = (callback)=>{
    callbackManager.remove(callback);
};
// node_modules/@tarojs/taro-h5/dist/api/device/accessibility.js
var checkIsOpenAccessibility = temporarilyNotSupport("checkIsOpenAccessibility");
// node_modules/@tarojs/taro-h5/dist/api/device/battery.js
var getBatteryInfoSync = temporarilyNotSupport("getBatteryInfoSync");
var getBatteryInfo = ({ success , fail , complete  } = {})=>__awaiter4(void 0, void 0, void 0, function*() {
        var _a;
        const handle3 = new MethodHandler({
            name: "getBatteryInfo",
            success,
            fail,
            complete
        });
        try {
            const battery = yield (_a = navigator.getBattery) === null || _a === void 0 ? void 0 : _a.call(navigator);
            return handle3.success({
                isCharging: battery.charging,
                level: Number(battery.level || 0) * 100
            });
        } catch (error) {
            return handle3.fail({
                errMsg: (error === null || error === void 0 ? void 0 : error.message) || error
            });
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/device/bluetooth.js
var stopBluetoothDevicesDiscovery = temporarilyNotSupport("stopBluetoothDevicesDiscovery");
var startBluetoothDevicesDiscovery = temporarilyNotSupport("startBluetoothDevicesDiscovery");
var openBluetoothAdapter = temporarilyNotSupport("openBluetoothAdapter");
var onBluetoothDeviceFound = temporarilyNotSupport("onBluetoothDeviceFound");
var onBluetoothAdapterStateChange = temporarilyNotSupport("onBluetoothAdapterStateChange");
var offBluetoothDeviceFound = temporarilyNotSupport("offBluetoothDeviceFound");
var offBluetoothAdapterStateChange = temporarilyNotSupport("offBluetoothAdapterStateChange");
var makeBluetoothPair = temporarilyNotSupport("makeBluetoothPair");
var isBluetoothDevicePaired = temporarilyNotSupport("isBluetoothDevicePaired");
var getConnectedBluetoothDevices = temporarilyNotSupport("getConnectedBluetoothDevices");
var getBluetoothDevices = temporarilyNotSupport("getBluetoothDevices");
var getBluetoothAdapterState = temporarilyNotSupport("getBluetoothAdapterState");
var closeBluetoothAdapter = temporarilyNotSupport("closeBluetoothAdapter");
// node_modules/@tarojs/taro-h5/dist/api/device/bluetooth-ble.js
var writeBLECharacteristicValue = temporarilyNotSupport("writeBLECharacteristicValue");
var setBLEMTU = temporarilyNotSupport("setBLEMTU");
var readBLECharacteristicValue = temporarilyNotSupport("readBLECharacteristicValue");
var onBLEMTUChange = temporarilyNotSupport("onBLEMTUChange");
var onBLEConnectionStateChange = temporarilyNotSupport("onBLEConnectionStateChange");
var onBLECharacteristicValueChange = temporarilyNotSupport("onBLECharacteristicValueChange");
var offBLEMTUChange = temporarilyNotSupport("offBLEMTUChange");
var offBLEConnectionStateChange = temporarilyNotSupport("offBLEConnectionStateChange");
var offBLECharacteristicValueChange = temporarilyNotSupport("offBLECharacteristicValueChange");
var notifyBLECharacteristicValueChange = temporarilyNotSupport("notifyBLECharacteristicValueChange");
var getBLEMTU = temporarilyNotSupport("getBLEMTU");
var getBLEDeviceServices = temporarilyNotSupport("getBLEDeviceServices");
var getBLEDeviceRSSI = temporarilyNotSupport("getBLEDeviceRSSI");
var getBLEDeviceCharacteristics = temporarilyNotSupport("getBLEDeviceCharacteristics");
var createBLEConnection = temporarilyNotSupport("createBLEConnection");
var closeBLEConnection = temporarilyNotSupport("closeBLEConnection");
// node_modules/@tarojs/taro-h5/dist/api/device/bluetooth-peripheral.js
var onBLEPeripheralConnectionStateChanged = temporarilyNotSupport("onBLEPeripheralConnectionStateChanged");
var offBLEPeripheralConnectionStateChanged = temporarilyNotSupport("offBLEPeripheralConnectionStateChanged");
var createBLEPeripheralServer = temporarilyNotSupport("createBLEPeripheralServer");
// node_modules/@tarojs/taro-h5/dist/api/device/calendar.js
var addPhoneRepeatCalendar = temporarilyNotSupport("addPhoneRepeatCalendar");
var addPhoneCalendar = temporarilyNotSupport("addPhoneCalendar");
// node_modules/@tarojs/taro-h5/dist/api/storage/background-fetch.js
var setBackgroundFetchToken = temporarilyNotSupport("setBackgroundFetchToken");
var onBackgroundFetchData = temporarilyNotSupport("onBackgroundFetchData");
var getBackgroundFetchToken = temporarilyNotSupport("getBackgroundFetchToken");
var getBackgroundFetchData = temporarilyNotSupport("getBackgroundFetchData");
// node_modules/@tarojs/taro-h5/dist/api/storage/index.js
function getItem(key) {
    let item;
    try {
        item = JSON.parse(localStorage.getItem(key) || "");
    } catch (e) {}
    if (item && typeof item === "object" && item.hasOwnProperty("data")) {
        return {
            result: true,
            data: item.data
        };
    } else {
        return {
            result: false
        };
    }
}
var setStorageSync = (key, data = "")=>{
    if (typeof key !== "string") {
        console.error(getParameterError({
            name: "setStorage",
            correct: "String",
            wrong: key
        }));
        return;
    }
    const type = typeof data;
    let obj = {};
    if (type === "symbol") {
        obj = {
            data: ""
        };
    } else {
        obj = {
            data
        };
    }
    localStorage.setItem(key, JSON.stringify(obj));
};
var setStorage = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `setStorage:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key , data , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "setStorage",
        success,
        fail,
        complete
    });
    if (typeof key !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "key",
                correct: "String",
                wrong: key
            })
        });
    }
    setStorageSync(key, data);
    return handle3.success();
};
var revokeBufferURL = temporarilyNotSupport("revokeBufferURL");
var removeStorageSync = (key)=>{
    if (typeof key !== "string") {
        console.error(getParameterError({
            name: "removeStorage",
            correct: "String",
            wrong: key
        }));
        return;
    }
    localStorage.removeItem(key);
};
var removeStorage = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `removeStorage:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "removeStorage",
        success,
        fail,
        complete
    });
    if (typeof key !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "key",
                correct: "String",
                wrong: key
            })
        });
    }
    removeStorageSync(key);
    return handle3.success();
};
var getStorageSync = (key)=>{
    if (typeof key !== "string") {
        console.error(getParameterError({
            name: "getStorageSync",
            correct: "String",
            wrong: key
        }));
        return;
    }
    const res = getItem(key);
    if (res.result) return res.data;
    return "";
};
var getStorageInfoSync = ()=>{
    const res = {
        keys: Object.keys(localStorage),
        limitSize: NaN,
        currentSize: NaN
    };
    return res;
};
var getStorageInfo = ({ success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "getStorageInfo",
        success,
        fail,
        complete
    });
    return handle3.success(getStorageInfoSync());
};
var getStorage = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `getStorage:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "getStorage",
        success,
        fail,
        complete
    });
    if (typeof key !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "key",
                correct: "String",
                wrong: key
            })
        });
    }
    const { result , data  } = getItem(key);
    if (result) {
        return handle3.success({
            data
        });
    } else {
        return handle3.fail({
            errMsg: "data not found"
        });
    }
};
var createBufferURL = temporarilyNotSupport("createBufferURL");
var clearStorageSync = ()=>{
    localStorage.clear();
};
var clearStorage = ({ success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "clearStorage",
        success,
        fail,
        complete
    });
    clearStorageSync();
    return handle3.success();
};
// node_modules/@tarojs/taro-h5/dist/api/device/clipboard.js
var CLIPBOARD_STORAGE_NAME = "taro_clipboard";
document.addEventListener("copy", ()=>{
    var _a;
    setStorage({
        key: CLIPBOARD_STORAGE_NAME,
        data: (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.toString()
    }).catch((e)=>{
        console.error(e);
    });
});
var setClipboardData = ({ data , success , fail , complete  })=>__awaiter4(void 0, void 0, void 0, function*() {
        const handle3 = new MethodHandler({
            name: "setClipboardData",
            success,
            fail,
            complete
        });
        try {
            setStorageSync(CLIPBOARD_STORAGE_NAME, data);
            if (isFunction(document.execCommand)) {
                const textarea = document.createElement("textarea");
                textarea.readOnly = true;
                textarea.value = data;
                textarea.style.position = "absolute";
                textarea.style.width = "100px";
                textarea.style.left = "-10000px";
                document.body.appendChild(textarea);
                textarea.select();
                textarea.setSelectionRange(0, textarea.value.length);
                document.execCommand("copy");
                document.body.removeChild(textarea);
            } else {
                throw new Error("Unsupported Function: 'document.execCommand'.");
            }
            return handle3.success();
        } catch (e) {
            return handle3.fail({
                errMsg: e.message
            });
        }
    });
var getClipboardData = ({ success , fail , complete  } = {})=>__awaiter4(void 0, void 0, void 0, function*() {
        const handle3 = new MethodHandler({
            name: "getClipboardData",
            success,
            fail,
            complete
        });
        try {
            const data = getStorageSync(CLIPBOARD_STORAGE_NAME);
            return handle3.success({
                data
            });
        } catch (e) {
            return handle3.fail({
                errMsg: e.message
            });
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/device/compass.js
var callbackManager2 = new CallbackManager();
var compassListener;
var deviceorientationEventName = [
    "absolutedeviceorientation",
    "deviceorientationabsolute",
    "deviceorientation"
].find((item)=>{
    if ("on" + item in window) {
        return item;
    }
}) || "";
var stopCompass = ({ success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "stopCompass",
        success,
        fail,
        complete
    });
    try {
        window.removeEventListener(deviceorientationEventName, compassListener, true);
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var CompassChangeTrigger = false;
var startCompass = ({ success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "startCompass",
        success,
        fail,
        complete
    });
    try {
        if (deviceorientationEventName !== "") {
            if (compassListener) {
                stopCompass();
            }
            compassListener = throttle((evt)=>{
                const isAndroid = getDeviceInfo().system === "AndroidOS";
                if (isAndroid && !evt.absolute && !CompassChangeTrigger) {
                    CompassChangeTrigger = true;
                    console.warn("Warning: In 'onCompassChange', your browser is not supported to get the orientation relative to the earth, the orientation data will be related to the initial orientation of the device .");
                }
                const alpha = evt.alpha || 0;
                const accuracy = isAndroid ? evt.absolute ? "high" : "medium" : alpha;
                callbackManager2.trigger({
                    direction: 360 - alpha,
                    accuracy
                });
            }, 5e3);
            window.addEventListener(deviceorientationEventName, compassListener, true);
        } else {
            throw new Error("compass is not supported");
        }
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var onCompassChange = (callback)=>{
    callbackManager2.add(callback);
};
var offCompassChange = (callback)=>{
    callbackManager2.remove(callback);
};
// node_modules/@tarojs/taro-h5/dist/api/device/contact.js
var chooseContact = temporarilyNotSupport("chooseContact");
var addPhoneContact = temporarilyNotSupport("addPhoneContact");
// node_modules/@tarojs/taro-h5/dist/api/device/crypto.js
var getRandomValues = temporarilyNotSupport("getRandomValues");
// node_modules/@tarojs/taro-h5/dist/api/device/gyroscope.js
var stopGyroscope = temporarilyNotSupport("stopGyroscope");
var startGyroscope = temporarilyNotSupport("startGyroscope");
var onGyroscopeChange = temporarilyNotSupport("onGyroscopeChange");
var offGyroscopeChange = temporarilyNotSupport("offGyroscopeChange");
// node_modules/@tarojs/taro-h5/dist/api/device/iBeacon.js
var stopBeaconDiscovery = temporarilyNotSupport("stopBeaconDiscovery");
var startBeaconDiscovery = temporarilyNotSupport("startBeaconDiscovery");
var onBeaconUpdate = temporarilyNotSupport("onBeaconUpdate");
var onBeaconServiceChange = temporarilyNotSupport("onBeaconServiceChange");
var offBeaconUpdate = temporarilyNotSupport("offBeaconUpdate");
var offBeaconServiceChange = temporarilyNotSupport("offBeaconServiceChange");
var getBeacons = temporarilyNotSupport("getBeacons");
// node_modules/@tarojs/taro-h5/dist/api/device/keyboard.js
var onKeyboardHeightChange = temporarilyNotSupport("onKeyboardHeightChange");
var offKeyboardHeightChange = temporarilyNotSupport("offKeyboardHeightChange");
var hideKeyboard = temporarilyNotSupport("hideKeyboard");
var getSelectedTextRange = temporarilyNotSupport("getSelectedTextRange");
// node_modules/@tarojs/taro-h5/dist/api/device/memory.js
var onMemoryWarning = temporarilyNotSupport("onMemoryWarning");
var offMemoryWarning = temporarilyNotSupport("offMemoryWarning");
// node_modules/@tarojs/taro-h5/dist/api/device/motion.js
var callbackManager3 = new CallbackManager();
var deviceMotionListener;
var INTERVAL_MAP2 = {
    game: {
        interval: 20,
        frequency: 50
    },
    ui: {
        interval: 60,
        frequency: 16.67
    },
    normal: {
        interval: 200,
        frequency: 5
    }
};
var stopDeviceMotionListening = ({ success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "stopDeviceMotionListening",
        success,
        fail,
        complete
    });
    try {
        window.removeEventListener("deviceorientation", deviceMotionListener, true);
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var startDeviceMotionListening = ({ interval ="normal" , success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "startDeviceMotionListening",
        success,
        fail,
        complete
    });
    try {
        const intervalObj = INTERVAL_MAP2[interval];
        if (window.DeviceOrientationEvent) {
            if (deviceMotionListener) {
                stopDeviceMotionListening();
            }
            deviceMotionListener = throttle((evt)=>{
                callbackManager3.trigger({
                    alpha: evt.alpha,
                    beta: evt.beta,
                    gamma: evt.gamma
                });
            }, intervalObj.interval);
            window.addEventListener("deviceorientation", deviceMotionListener, true);
        } else {
            throw new Error("deviceMotion is not supported");
        }
        return handle3.success();
    } catch (e) {
        return handle3.fail({
            errMsg: e.message
        });
    }
};
var onDeviceMotionChange = (callback)=>{
    callbackManager3.add(callback);
};
var offDeviceMotionChange = (callback)=>{
    callbackManager3.remove(callback);
};
// node_modules/@tarojs/taro-h5/dist/api/device/network.js
function getConnection() {
    return navigator.connection || navigator.mozConnection || navigator.webkitConnection || navigator.msConnection;
}
var getNetworkType = (options3 = {})=>{
    const connection = getConnection();
    const { success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "getNetworkType",
        success,
        fail,
        complete
    });
    let networkType = "unknown";
    if (!connection) {
        return handle3.success({
            networkType
        });
    }
    if (!isNaN(Number(connection.type))) {
        switch(connection.type){
            case connection.WIFI:
                networkType = "wifi";
                break;
            case connection.CELL_3G:
                networkType = "3g";
                break;
            case connection.CELL_2G:
                networkType = "2g";
                break;
            default:
                networkType = "unknown";
        }
    } else if (connection.type) {
        networkType = connection.type;
    } else if (connection.effectiveType) {
        networkType = connection.effectiveType;
    }
    return handle3.success({
        networkType
    });
};
var networkStatusManager = new CallbackManager();
var networkStatusListener = ()=>__awaiter4(void 0, void 0, void 0, function*() {
        const { networkType  } = yield getNetworkType();
        const isConnected = networkType !== "none";
        const obj = {
            isConnected,
            networkType
        };
        networkStatusManager.trigger(obj);
    });
var onNetworkWeakChange = temporarilyNotSupport("onNetworkWeakChange");
var onNetworkStatusChange = (callback)=>{
    networkStatusManager.add(callback);
    const connection = getConnection();
    if (connection && networkStatusManager.count() === 1) {
        connection.addEventListener("change", networkStatusListener);
    }
};
var offNetworkWeakChange = temporarilyNotSupport("offNetworkStatusChange");
var offNetworkStatusChange = (callback)=>{
    networkStatusManager.remove(callback);
    const connection = getConnection();
    if (connection && networkStatusManager.count() === 0) {
        connection.removeEventListener("change", networkStatusListener);
    }
};
var getLocalIPAddress = temporarilyNotSupport("getLocalIPAddress");
// node_modules/@tarojs/taro-h5/dist/api/device/nfc.js
var stopHCE = temporarilyNotSupport("stopHCE");
var startHCE = temporarilyNotSupport("startHCE");
var sendHCEMessage = temporarilyNotSupport("sendHCEMessage");
var onHCEMessage = temporarilyNotSupport("onHCEMessage");
var offHCEMessage = temporarilyNotSupport("offHCEMessage");
var getNFCAdapter = temporarilyNotSupport("getNFCAdapter");
var getHCEState = temporarilyNotSupport("getHCEState");
// node_modules/@tarojs/taro-h5/dist/api/device/phone.js
var makePhoneCall = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `makePhoneCall:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { phoneNumber , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "makePhoneCall",
        success,
        fail,
        complete
    });
    if (typeof phoneNumber !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "phoneNumber",
                correct: "String",
                wrong: phoneNumber
            })
        });
    }
    window.location.href = `tel:${phoneNumber}`;
    return handle3.success();
};
// node_modules/@tarojs/taro-h5/dist/api/device/scan.js
var scanCode = processOpenApi({
    name: "scanQRCode",
    defaultOptions: {
        needResult: 1
    },
    formatResult: (res)=>({
            errMsg: res.errMsg === "scanQRCode:ok" ? "scanCode:ok" : res.errMsg,
            result: res.resultStr
        })
});
// node_modules/@tarojs/taro-h5/dist/api/device/screen.js
var setVisualEffectOnCapture = temporarilyNotSupport("setVisualEffectOnCapture");
var setScreenBrightness = temporarilyNotSupport("setScreenBrightness");
var setKeepScreenOn = temporarilyNotSupport("setKeepScreenOn");
var onUserCaptureScreen = temporarilyNotSupport("onUserCaptureScreen");
var offUserCaptureScreen = temporarilyNotSupport("offUserCaptureScreen");
var getScreenBrightness = temporarilyNotSupport("getScreenBrightness");
// node_modules/@tarojs/taro-h5/dist/api/device/vibrate.js
var vibrator = function vibrator2(mm) {
    try {
        return window.navigator.vibrate(mm);
    } catch (e) {
        console.warn("\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 vibrate\u3002");
    }
};
var vibrateShort = ({ success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "vibrateShort",
        success,
        fail,
        complete
    });
    if (vibrator(15)) {
        return handle3.success();
    } else {
        return handle3.fail({
            errMsg: "style is not support"
        });
    }
};
var vibrateLong = ({ success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "vibrateLong",
        success,
        fail,
        complete
    });
    if (vibrator(400)) {
        return handle3.success();
    } else {
        return handle3.fail({
            errMsg: "style is not support"
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/device/wifi.js
var stopWifi = temporarilyNotSupport("stopWifi");
var startWifi = temporarilyNotSupport("startWifi");
var setWifiList = temporarilyNotSupport("setWifiList");
var onWifiConnectedWithPartialInfo = temporarilyNotSupport("onWifiConnectedWithPartialInfo");
var onWifiConnected = temporarilyNotSupport("onWifiConnected");
var onGetWifiList = temporarilyNotSupport("onGetWifiList");
var offWifiConnected = temporarilyNotSupport("offWifiConnected");
var offGetWifiList = temporarilyNotSupport("offGetWifiList");
var getWifiList = temporarilyNotSupport("getWifiList");
var getConnectedWifi = temporarilyNotSupport("getConnectedWifi");
var connectWifi = temporarilyNotSupport("connectWifi");
// node_modules/@tarojs/taro-h5/dist/api/ext/index.js
var getExtConfigSync = temporarilyNotSupport("getExtConfigSync");
var getExtConfig = temporarilyNotSupport("getExtConfig");
// node_modules/@tarojs/taro-h5/dist/api/files/index.js
var saveFileToDisk = temporarilyNotSupport("saveFileToDisk");
var saveFile = temporarilyNotSupport("saveFile");
var removeSavedFile = temporarilyNotSupport("removeSavedFile");
var openDocument = temporarilyNotSupport("openDocument");
var getSavedFileList = temporarilyNotSupport("getSavedFileList");
var getSavedFileInfo = temporarilyNotSupport("getSavedFileInfo");
var getFileSystemManager = temporarilyNotSupport("getFileSystemManager");
var getFileInfo = temporarilyNotSupport("getFileInfo");
// node_modules/@tarojs/taro-h5/dist/api/framework/index.js
var getApp2 = function() {
    return Taro.getCurrentInstance().app;
};
var getCurrentInstance2 = Taro.getCurrentInstance;
// node_modules/@tarojs/taro-h5/dist/api/location/getLocation.js
var getLocationByW3CApi = (options3)=>{
    var _a;
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `getLocation:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "getLocation",
        success,
        fail,
        complete
    });
    const positionOptions = {
        enableHighAccuracy: options3.isHighAccuracy || options3.altitude != null,
        timeout: options3.highAccuracyExpireTime
    };
    if (((_a = options3.type) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== "WGS84") {
        return handle3.fail({
            errMsg: "This coordinate system type is not temporarily supported"
        });
    }
    const geolocationSupported = navigator.geolocation;
    if (!geolocationSupported) {
        return handle3.fail({
            errMsg: "The current browser does not support this feature"
        });
    }
    return new Promise((resolve, reject)=>{
        navigator.geolocation.getCurrentPosition((position)=>{
            const result = {
                accuracy: position.coords.accuracy,
                altitude: position.coords.altitude,
                horizontalAccuracy: position.coords.accuracy,
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                speed: position.coords.speed,
                verticalAccuracy: position.coords.altitudeAccuracy || 0,
                errMsg: ""
            };
            handle3.success(result, {
                resolve,
                reject
            });
        }, (error)=>{
            handle3.fail({
                errMsg: error.message
            }, {
                resolve,
                reject
            });
        }, positionOptions);
    });
};
var getLocation = processOpenApi({
    name: "getLocation",
    standardMethod: getLocationByW3CApi
});
// node_modules/@tarojs/taro-h5/dist/node_modules/.pnpm/registry.npmjs.org_style-inject@0.3.0/node_modules/style-inject/dist/style-inject.es.js
function styleInject(css2, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;
    if (!css2 || typeof document === "undefined") {
        return;
    }
    var head2 = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";
    if (insertAt === "top") {
        if (head2.firstChild) {
            head2.insertBefore(style, head2.firstChild);
        } else {
            head2.appendChild(style);
        }
    } else {
        head2.appendChild(style);
    }
    if (style.styleSheet) {
        style.styleSheet.cssText = css2;
    } else {
        style.appendChild(document.createTextNode(css2));
    }
}
// node_modules/@tarojs/taro-h5/dist/api/location/style.scss.js
var css_248z = '.taro_choose_location {\n  display: flex;\n  position: fixed;\n  top: 100%;\n  z-index: 1;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n  background-color: #fff;\n  transition: ease top 0.3s; }\n  .taro_choose_location_bar {\n    display: flex;\n    flex: 0 95px;\n    height: 95px;\n    background-color: #ededed;\n    color: #090909; }\n  .taro_choose_location_back {\n    position: relative;\n    flex: 0 45px;\n    margin-top: 30px;\n    width: 33px;\n    height: 30px; }\n    .taro_choose_location_back::before {\n      display: block;\n      position: absolute;\n      left: 0;\n      top: 0;\n      border: solid 15px;\n      border-color: transparent #090909 transparent transparent;\n      width: 0;\n      height: 0;\n      content: ""; }\n    .taro_choose_location_back::after {\n      display: block;\n      position: absolute;\n      left: 3px;\n      top: 0;\n      border: solid 15px;\n      border-color: transparent #ededed transparent transparent;\n      width: 0;\n      height: 0;\n      content: ""; }\n  .taro_choose_location_title {\n    flex: 1;\n    padding-left: 30px;\n    line-height: 95px; }\n  .taro_choose_location_submit {\n    margin: 18px 30px 0 0;\n    padding: 0;\n    border: none;\n    width: 110px;\n    height: 60px;\n    background-color: #08bf62;\n    line-height: 60px;\n    font-size: 28px;\n    color: #fff; }\n  .taro_choose_location_frame {\n    flex: 1; }\n';
styleInject(css_248z, {
    "insertAt": "top"
});
// node_modules/@tarojs/taro-h5/dist/api/location/chooseLocation.js
var import_query_string3 = __toESM(require_query_string());
function createLocationChooser(handler, key = LOCATION_APIKEY, mapOpt = {}) {
    var _a, _b, _c;
    const { latitude , longitude  } = mapOpt, opts = __rest(mapOpt, [
        "latitude",
        "longitude"
    ]);
    const query = Object.assign({
        key,
        type: 1,
        coord: ((_a = mapOpt.coord) !== null && _a !== void 0 ? _a : [
            latitude,
            longitude
        ].every((e)=>Number(e) >= 0)) ? `${latitude},${longitude}` : void 0,
        referer: "myapp"
    }, opts);
    const html2 = `
<div class='taro_choose_location'>
  <div class='taro_choose_location_bar'>
    <div class='taro_choose_location_back'></div>
    <p class='taro_choose_location_title'>\u4F4D\u7F6E</p>
    <button class='taro_choose_location_submit'>\u5B8C\u6210</button>
  </div>
  <iframe class='taro_choose_location_frame' frameborder='0' src="https://apis.map.qq.com/tools/locpicker?${(0, import_query_string3.stringify)(query, {
        arrayFormat: "comma",
        skipNull: true
    })}" />
</div>
`;
    const container = document.createElement("div");
    container.innerHTML = html2;
    const main = container.querySelector(".taro_choose_location");
    function show() {
        setTimeout(()=>{
            main.style.top = "0";
        });
    }
    function hide() {
        main.style.top = "100%";
    }
    function back() {
        hide();
        handler({
            errMsg: "cancel"
        });
    }
    function submit() {
        hide();
        handler();
    }
    function remove3() {
        container.remove();
        window.removeEventListener("popstate", back);
    }
    (_b = container.querySelector(".taro_choose_location_back")) === null || _b === void 0 ? void 0 : _b.addEventListener("click", back);
    (_c = container.querySelector(".taro_choose_location_submit")) === null || _c === void 0 ? void 0 : _c.addEventListener("click", submit);
    window.addEventListener("popstate", back);
    return {
        show,
        remove: remove3,
        container
    };
}
var chooseLocation = ({ success , fail , complete , mapOpts  } = {})=>{
    const key = LOCATION_APIKEY;
    const handle3 = new MethodHandler({
        name: "chooseLocation",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        const chooseLocation2 = {};
        if (!key) {
            console.warn("chooseLocation api \u4F9D\u8D56\u817E\u8BAF\u5730\u56FE\u5B9A\u4F4Dapi\uFF0C\u9700\u8981\u5728 defineConstants \u4E2D\u914D\u7F6E LOCATION_APIKEY");
            return handle3.fail({
                errMsg: "LOCATION_APIKEY needed"
            }, {
                resolve,
                reject
            });
        }
        const onMessage = (event2)=>{
            const loc = event2.data;
            if (!loc || loc.module !== "locationPicker") return;
            chooseLocation2.name = loc.poiname;
            chooseLocation2.address = loc.poiaddress;
            chooseLocation2.latitude = loc.latlng.lat;
            chooseLocation2.longitude = loc.latlng.lng;
        };
        const chooser = createLocationChooser((res)=>{
            window.removeEventListener("message", onMessage, false);
            setTimeout(()=>{
                chooser.remove();
            }, 300);
            if (res) {
                return handle3.fail(res, {
                    resolve,
                    reject
                });
            } else {
                if (chooseLocation2.latitude && chooseLocation2.longitude) {
                    return handle3.success(chooseLocation2, {
                        resolve,
                        reject
                    });
                } else {
                    return handle3.fail({}, {
                        resolve,
                        reject
                    });
                }
            }
        }, key, mapOpts);
        document.body.appendChild(chooser.container);
        window.addEventListener("message", onMessage, false);
        chooser.show();
    });
};
// node_modules/@tarojs/taro-h5/dist/api/location/index.js
var stopLocationUpdate = temporarilyNotSupport("stopLocationUpdate");
var startLocationUpdateBackground = temporarilyNotSupport("startLocationUpdateBackground");
var startLocationUpdate = temporarilyNotSupport("startLocationUpdate");
var openLocation = processOpenApi({
    name: "openLocation",
    defaultOptions: {
        scale: 18
    }
});
var onLocationChangeError = temporarilyNotSupport("onLocationChangeError");
var onLocationChange = temporarilyNotSupport("onLocationChange");
var offLocationChangeError = temporarilyNotSupport("offLocationChangeError");
var offLocationChange = temporarilyNotSupport("offLocationChange");
var choosePoi = temporarilyNotSupport("choosePoi");
var getFuzzyLocation = temporarilyNotSupport("getFuzzyLocation");
// node_modules/@tarojs/taro-h5/dist/api/media/audio/InnerAudioContext.js
var InnerAudioContext = class {
    set autoplay(e) {
        this.setProperty("autoplay", e);
    }
    get autoplay() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.autoplay) || false;
    }
    get buffered() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.buffered.length) || 0;
    }
    get currentTime() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.currentTime) || 0;
    }
    get duration() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.duration) || 0;
    }
    set loop(e) {
        this.setProperty("loop", e);
    }
    get loop() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.loop) || false;
    }
    get paused() {
        var _a, _b;
        return (_b = (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.paused) !== null && _b !== void 0 ? _b : true;
    }
    set src(e) {
        this.setProperty("src", e);
    }
    get src() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.src) || "";
    }
    set volume(e) {
        this.setProperty("volume", e);
    }
    get volume() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.volume) || 0;
    }
    set playbackRate(e) {
        this.setProperty("playbackRate", e);
    }
    get playbackRate() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.playbackRate) || 0;
    }
    set obeyMuteSwitch(_e) {
        permanentlyNotSupport("InnerAudioContext.obeyMuteSwitch")();
    }
    get obeyMuteSwitch() {
        return true;
    }
    set startTime(e) {
        this.__startTime = e;
    }
    get startTime() {
        return this.__startTime || 0;
    }
    set referrerPolicy(e) {
        var _a;
        (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.setAttribute("referrerpolicy", e);
    }
    get referrerPolicy() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.getAttribute("referrerpolicy")) || "origin";
    }
    setProperty(key, value) {
        if (this.Instance) {
            this.Instance[key] = value;
        }
    }
    constructor(){
        this.__startTime = 0;
        this.play = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.play();
        };
        this.pause = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.pause();
        };
        this.stop = ()=>{
            this.pause();
            this.seek(0);
            this.stopStack.trigger();
        };
        this.seek = (position)=>{
            if (this.Instance) {
                this.Instance.currentTime = position;
            }
        };
        this.destroy = ()=>{
            this.stop();
            if (this.Instance) {
                document.body.removeChild(this.Instance);
                this.Instance = void 0;
            }
        };
        this.onCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("canplay", callback);
        };
        this.onPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("play", callback);
        };
        this.onPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("pause", callback);
        };
        this.onStop = (callback = ()=>{})=>this.stopStack.add(callback);
        this.onEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("ended", callback);
        };
        this.onTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("timeupdate", callback);
        };
        this.onError = (callback)=>this.errorStack.add(callback);
        this.onWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("waiting", callback);
        };
        this.onSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeking", callback);
        };
        this.onSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeked", callback);
        };
        this.offCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("canplay", callback);
        };
        this.offPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("play", callback);
        };
        this.offPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("pause", callback);
        };
        this.offStop = (callback = ()=>{})=>this.stopStack.remove(callback);
        this.offEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("ended", callback);
        };
        this.offTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("timeupdate", callback);
        };
        this.offError = (callback = ()=>{})=>this.errorStack.remove(callback);
        this.offWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("waiting", callback);
        };
        this.offSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeking", callback);
        };
        this.offSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeked", callback);
        };
        this.Instance = new Audio();
        this.errorStack = new CallbackManager();
        this.stopStack = new CallbackManager();
        Taro.eventCenter.on("__taroRouterChange", ()=>{
            this.stop();
        });
        this.onPlay(()=>{
            if (this.currentTime !== this.startTime) {
                this.seek(this.startTime);
            }
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/media/audio/index.js
var stopVoice = temporarilyNotSupport("stopVoice");
var setInnerAudioOption = temporarilyNotSupport("setInnerAudioOption");
var playVoice = temporarilyNotSupport("playVoice");
var pauseVoice = temporarilyNotSupport("pauseVoice");
var getAvailableAudioSources = temporarilyNotSupport("getAvailableAudioSources");
var createWebAudioContext = temporarilyNotSupport("createWebAudioContext");
var createMediaAudioPlayer = temporarilyNotSupport("createMediaAudioPlayer");
var createInnerAudioContext = ()=>new InnerAudioContext();
var createAudioContext = temporarilyNotSupport("createAudioContext");
// node_modules/@tarojs/taro-h5/dist/api/media/background-audio/BackgroundAudioManager.js
var BackgroundAudioManager = class {
    set src(e) {
        this.setProperty("src", e);
    }
    get src() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.src) || "";
    }
    set startTime(e) {
        this.__startTime = e;
    }
    get startTime() {
        return this.__startTime || 0;
    }
    set title(e) {
        this.dataset("title", e);
    }
    get title() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.title) || "";
    }
    set epname(e) {
        this.dataset("epname", e);
    }
    get epname() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.epname) || "";
    }
    set singer(e) {
        this.dataset("singer", e);
    }
    get singer() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.singer) || "";
    }
    set coverImgUrl(e) {
        this.dataset("coverImgUrl", e);
    }
    get coverImgUrl() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.coverImgUrl) || "";
    }
    set webUrl(e) {
        this.dataset("webUrl", e);
    }
    get webUrl() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.webUrl) || "";
    }
    set protocol(e) {
        this.dataset("protocol", e);
    }
    get protocol() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.protocol) || "";
    }
    set playbackRate(e) {
        this.setProperty("playbackRate", e);
    }
    get playbackRate() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.playbackRate) || 0;
    }
    get duration() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.duration) || 0;
    }
    get currentTime() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.currentTime) || 0;
    }
    get paused() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.paused) || false;
    }
    get buffered() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.buffered.length) || 0;
    }
    set referrerPolicy(e) {
        var _a;
        (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.setAttribute("referrerpolicy", e);
    }
    get referrerPolicy() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.getAttribute("referrerpolicy")) || "origin";
    }
    setProperty(key, value) {
        if (this.Instance) {
            this.Instance[key] = value;
        }
    }
    dataset(key, value) {
        if (this.Instance) {
            this.Instance.dataset[key] = value;
        }
    }
    constructor(){
        this.__startTime = 0;
        this.play = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.play();
        };
        this.pause = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.pause();
        };
        this.seek = (position)=>{
            if (this.Instance) {
                this.Instance.currentTime = position;
            }
        };
        this.stop = ()=>{
            this.pause();
            this.seek(0);
            this.stopStack.trigger();
        };
        this.onCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("canplay", callback);
        };
        this.onWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("waiting", callback);
        };
        this.onError = (callback)=>this.errorStack.add(callback);
        this.onPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("play", callback);
        };
        this.onPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("pause", callback);
        };
        this.onSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeking", callback);
        };
        this.onSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeked", callback);
        };
        this.onEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("ended", callback);
        };
        this.onStop = (callback = ()=>{})=>this.stopStack.add(callback);
        this.onTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("timeupdate", callback);
        };
        this.onPrev = permanentlyNotSupport("BackgroundAudioManager.onPrev");
        this.onNext = permanentlyNotSupport("BackgroundAudioManager.onNext");
        this.offCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("canplay", callback);
        };
        this.offWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("waiting", callback);
        };
        this.offError = (callback = ()=>{})=>this.errorStack.remove(callback);
        this.offPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("play", callback);
        };
        this.offPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("pause", callback);
        };
        this.offSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeking", callback);
        };
        this.offSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeked", callback);
        };
        this.offEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("ended", callback);
        };
        this.offStop = (callback = ()=>{})=>this.stopStack.remove(callback);
        this.offTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("timeupdate", callback);
        };
        this.offPrev = permanentlyNotSupport("BackgroundAudioManager.offPrev");
        this.offNext = permanentlyNotSupport("BackgroundAudioManager.offNext");
        this.Instance = new Audio();
        this.errorStack = new CallbackManager();
        this.stopStack = new CallbackManager();
        this.Instance.autoplay = true;
        this.onPlay(()=>{
            if (this.currentTime !== this.startTime) {
                this.seek(this.startTime);
            }
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/media/background-audio/index.js
var stopBackgroundAudio = temporarilyNotSupport("stopBackgroundAudio");
var seekBackgroundAudio = temporarilyNotSupport("seekBackgroundAudio");
var playBackgroundAudio = temporarilyNotSupport("playBackgroundAudio");
var pauseBackgroundAudio = temporarilyNotSupport("pauseBackgroundAudio");
var onBackgroundAudioStop = temporarilyNotSupport("onBackgroundAudioStop");
var onBackgroundAudioPlay = temporarilyNotSupport("onBackgroundAudioPlay");
var onBackgroundAudioPause = temporarilyNotSupport("onBackgroundAudioPause");
var getBackgroundAudioPlayerState = temporarilyNotSupport("getBackgroundAudioPlayerState");
var getBackgroundAudioManager = ()=>new BackgroundAudioManager();
// node_modules/@tarojs/taro-h5/dist/api/media/camera.js
var createCameraContext = temporarilyNotSupport("createCameraContext");
// node_modules/@tarojs/taro-h5/dist/api/media/image/getImageInfo.js
var getImageInfo = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `getImageInfo:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const getBase64Image = (image)=>{
        try {
            const canvas = document.createElement("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext("2d");
            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, image.width, image.height);
            return canvas.toDataURL("image/png");
        } catch (e) {
            console.error("getImageInfo:get base64 fail", e);
        }
    };
    const { src , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "getImageInfo",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        const image = new Image();
        image.crossOrigin = "";
        image.onload = ()=>{
            handle3.success({
                width: image.naturalWidth,
                height: image.naturalHeight,
                path: getBase64Image(image) || src
            }, {
                resolve,
                reject
            });
        };
        image.onerror = (e)=>{
            handle3.fail({
                errMsg: e.message
            }, {
                resolve,
                reject
            });
        };
        image.src = src;
    });
};
// node_modules/@stencil/core/internal/app-data/index.js
var BUILD = {
    allRenderFn: false,
    cmpDidLoad: true,
    cmpDidUnload: false,
    cmpDidUpdate: true,
    cmpDidRender: true,
    cmpWillLoad: true,
    cmpWillUpdate: true,
    cmpWillRender: true,
    connectedCallback: true,
    disconnectedCallback: true,
    element: true,
    event: true,
    hasRenderFn: true,
    lifecycle: true,
    hostListener: true,
    hostListenerTargetWindow: true,
    hostListenerTargetDocument: true,
    hostListenerTargetBody: true,
    hostListenerTargetParent: false,
    hostListenerTarget: true,
    member: true,
    method: true,
    mode: true,
    observeAttribute: true,
    prop: true,
    propMutable: true,
    reflect: true,
    scoped: true,
    shadowDom: true,
    slot: true,
    cssAnnotations: true,
    state: true,
    style: true,
    svg: true,
    updatable: true,
    vdomAttribute: true,
    vdomXlink: true,
    vdomClass: true,
    vdomFunctional: true,
    vdomKey: true,
    vdomListener: true,
    vdomRef: true,
    vdomPropOrAttr: true,
    vdomRender: true,
    vdomStyle: true,
    vdomText: true,
    watchCallback: true,
    taskQueue: true,
    hotModuleReplacement: false,
    isDebug: false,
    isDev: false,
    isTesting: false,
    hydrateServerSide: false,
    hydrateClientSide: false,
    lifecycleDOMEvents: false,
    lazyLoad: false,
    profile: false,
    slotRelocation: true,
    appendChildSlotFix: false,
    cloneNodeFix: false,
    hydratedAttribute: false,
    hydratedClass: true,
    safari10: false,
    scriptDataOpts: false,
    scopedSlotTextContentFix: false,
    shadowDomShim: false,
    slotChildNodesFix: false,
    invisiblePrehydration: true,
    propBoolean: true,
    propNumber: true,
    propString: true,
    cssVarShim: false,
    constructableCSS: true,
    cmpShouldUpdate: true,
    devTools: false,
    dynamicImportShim: false,
    shadowDelegatesFocus: true,
    initializeNextTick: false,
    asyncLoading: false,
    asyncQueue: false,
    transformTagName: false,
    attachStyles: true
};
var NAMESPACE = "app";
// node_modules/@stencil/core/internal/client/index.js
var scopeId;
var contentRef;
var hostTagName;
var customError;
var i = 0;
var useNativeShadowDom = false;
var checkSlotFallbackVisibility = false;
var checkSlotRelocate = false;
var isSvgMode = false;
var renderingRef = null;
var queueCongestion = 0;
var queuePending = false;
var Build = {
    isDev: BUILD.isDev ? true : false,
    isBrowser: true,
    isServer: false,
    isTesting: BUILD.isTesting ? true : false
};
var createTime = (fnName, tagName = "")=>{
    if (BUILD.profile && performance.mark) {
        const key = `st:${fnName}:${tagName}:${i++}`;
        performance.mark(key);
        return ()=>performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);
    } else {
        return ()=>{
            return;
        };
    }
};
var uniqueTime = (key, measureText)=>{
    if (BUILD.profile && performance.mark) {
        if (performance.getEntriesByName(key, "mark").length === 0) {
            performance.mark(key);
        }
        return ()=>{
            if (performance.getEntriesByName(measureText, "measure").length === 0) {
                performance.measure(measureText, key);
            }
        };
    } else {
        return ()=>{
            return;
        };
    }
};
var CONTENT_REF_ID = "r";
var ORG_LOCATION_ID = "o";
var SLOT_NODE_ID = "s";
var TEXT_NODE_ID = "t";
var HYDRATE_ID = "s-id";
var HYDRATED_STYLE_ID = "sty-id";
var HYDRATE_CHILD_ID = "c-id";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var EMPTY_OBJ = {};
var SVG_NS = "http://www.w3.org/2000/svg";
var HTML_NS = "http://www.w3.org/1999/xhtml";
var isDef = (v)=>v != null;
var isComplexType = (o)=>{
    o = typeof o;
    return o === "object" || o === "function";
};
function queryNonceMetaTagContent(doc3) {
    var _a, _b, _c;
    return (_c = (_b = (_a = doc3.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute("content")) !== null && _c !== void 0 ? _c : void 0;
}
var h = (nodeName, vnodeData, ...children2)=>{
    let child = null;
    let key = null;
    let slotName = null;
    let simple = false;
    let lastSimple = false;
    const vNodeChildren = [];
    const walk = (c)=>{
        for(let i2 = 0; i2 < c.length; i2++){
            child = c[i2];
            if (Array.isArray(child)) {
                walk(child);
            } else if (child != null && typeof child !== "boolean") {
                if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
                    child = String(child);
                } else if (BUILD.isDev && typeof nodeName !== "function" && child.$flags$ === void 0) {
                    consoleDevError(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`);
                }
                if (simple && lastSimple) {
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                } else {
                    vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children2);
    if (vnodeData) {
        if (BUILD.isDev && nodeName === "input") {
            validateInputProperties(vnodeData);
        }
        if (BUILD.vdomKey && vnodeData.key) {
            key = vnodeData.key;
        }
        if (BUILD.slotRelocation && vnodeData.name) {
            slotName = vnodeData.name;
        }
        if (BUILD.vdomClass) {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k)=>classData[k]).join(" ");
            }
        }
    }
    if (BUILD.isDev && vNodeChildren.some(isHost)) {
        consoleDevError(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);
    }
    if (BUILD.vdomFunctional && typeof nodeName === "function") {
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
    }
    const vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    if (BUILD.vdomKey) {
        vnode.$key$ = key;
    }
    if (BUILD.slotRelocation) {
        vnode.$name$ = slotName;
    }
    return vnode;
};
var newVNode = (tag, text2)=>{
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text2,
        $elm$: null,
        $children$: null
    };
    if (BUILD.vdomAttribute) {
        vnode.$attrs$ = null;
    }
    if (BUILD.vdomKey) {
        vnode.$key$ = null;
    }
    if (BUILD.slotRelocation) {
        vnode.$name$ = null;
    }
    return vnode;
};
var Host = {};
var isHost = (node)=>node && node.$tag$ === Host;
var vdomFnUtils = {
    forEach: (children2, cb)=>children2.map(convertToPublic).forEach(cb),
    map: (children2, cb)=>children2.map(convertToPublic).map(cb).map(convertToPrivate)
};
var convertToPublic = (node)=>({
        vattrs: node.$attrs$,
        vchildren: node.$children$,
        vkey: node.$key$,
        vname: node.$name$,
        vtag: node.$tag$,
        vtext: node.$text$
    });
var convertToPrivate = (node)=>{
    if (typeof node.vtag === "function") {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
            vnodeData.key = node.vkey;
        }
        if (node.vname) {
            vnodeData.name = node.vname;
        }
        return h(node.vtag, vnodeData, ...node.vchildren || []);
    }
    const vnode = newVNode(node.vtag, node.vtext);
    vnode.$attrs$ = node.vattrs;
    vnode.$children$ = node.vchildren;
    vnode.$key$ = node.vkey;
    vnode.$name$ = node.vname;
    return vnode;
};
var validateInputProperties = (inputElm)=>{
    const props = Object.keys(inputElm);
    const value = props.indexOf("value");
    if (value === -1) {
        return;
    }
    const typeIndex = props.indexOf("type");
    const minIndex = props.indexOf("min");
    const maxIndex = props.indexOf("max");
    const stepIndex = props.indexOf("step");
    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {
        consoleDevWarn(`The "value" prop of <input> should be set after "min", "max", "type" and "step"`);
    }
};
var initializeClientHydrate = (hostElm, tagName, hostId, hostRef)=>{
    const endHydrate = createTime("hydrateClient", tagName);
    const shadowRoot = hostElm.shadowRoot;
    const childRenderNodes = [];
    const slotNodes = [];
    const shadowRootNodes = BUILD.shadowDom && shadowRoot ? [] : null;
    const vnode = hostRef.$vnode$ = newVNode(tagName, null);
    if (!plt.$orgLocNodes$) {
        initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = /* @__PURE__ */ new Map());
    }
    hostElm[HYDRATE_ID] = hostId;
    hostElm.removeAttribute(HYDRATE_ID);
    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
    childRenderNodes.map((c)=>{
        const orgLocationId = c.$hostId$ + "." + c.$nodeId$;
        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
        const node = c.$elm$;
        if (orgLocationNode && supportsShadow && orgLocationNode["s-en"] === "") {
            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
        }
        if (!shadowRoot) {
            node["s-hn"] = tagName;
            if (orgLocationNode) {
                node["s-ol"] = orgLocationNode;
                node["s-ol"]["s-nr"] = node;
            }
        }
        plt.$orgLocNodes$.delete(orgLocationId);
    });
    if (BUILD.shadowDom && shadowRoot) {
        shadowRootNodes.map((shadowRootNode)=>{
            if (shadowRootNode) {
                shadowRoot.appendChild(shadowRootNode);
            }
        });
    }
    endHydrate();
};
var clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId)=>{
    let childNodeType;
    let childIdSplt;
    let childVNode;
    let i2;
    if (node.nodeType === 1) {
        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
        if (childNodeType) {
            childIdSplt = childNodeType.split(".");
            if (childIdSplt[0] === hostId || childIdSplt[0] === "0") {
                childVNode = {
                    $flags$: 0,
                    $hostId$: childIdSplt[0],
                    $nodeId$: childIdSplt[1],
                    $depth$: childIdSplt[2],
                    $index$: childIdSplt[3],
                    $tag$: node.tagName.toLowerCase(),
                    $elm$: node,
                    $attrs$: null,
                    $children$: null,
                    $key$: null,
                    $name$: null,
                    $text$: null
                };
                childRenderNodes.push(childVNode);
                node.removeAttribute(HYDRATE_CHILD_ID);
                if (!parentVNode.$children$) {
                    parentVNode.$children$ = [];
                }
                parentVNode.$children$[childVNode.$index$] = childVNode;
                parentVNode = childVNode;
                if (shadowRootNodes && childVNode.$depth$ === "0") {
                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                }
            }
        }
        for(i2 = node.childNodes.length - 1; i2 >= 0; i2--){
            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i2], hostId);
        }
        if (node.shadowRoot) {
            for(i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--){
                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i2], hostId);
            }
        }
    } else if (node.nodeType === 8) {
        childIdSplt = node.nodeValue.split(".");
        if (childIdSplt[1] === hostId || childIdSplt[1] === "0") {
            childNodeType = childIdSplt[0];
            childVNode = {
                $flags$: 0,
                $hostId$: childIdSplt[1],
                $nodeId$: childIdSplt[2],
                $depth$: childIdSplt[3],
                $index$: childIdSplt[4],
                $elm$: node,
                $attrs$: null,
                $children$: null,
                $key$: null,
                $name$: null,
                $tag$: null,
                $text$: null
            };
            if (childNodeType === TEXT_NODE_ID) {
                childVNode.$elm$ = node.nextSibling;
                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3) {
                    childVNode.$text$ = childVNode.$elm$.textContent;
                    childRenderNodes.push(childVNode);
                    node.remove();
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                    if (shadowRootNodes && childVNode.$depth$ === "0") {
                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                    }
                }
            } else if (childVNode.$hostId$ === hostId) {
                if (childNodeType === SLOT_NODE_ID) {
                    childVNode.$tag$ = "slot";
                    if (childIdSplt[5]) {
                        node["s-sn"] = childVNode.$name$ = childIdSplt[5];
                    } else {
                        node["s-sn"] = "";
                    }
                    node["s-sr"] = true;
                    if (BUILD.shadowDom && shadowRootNodes) {
                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);
                        if (childVNode.$name$) {
                            childVNode.$elm$.setAttribute("name", childVNode.$name$);
                        }
                        node.parentNode.insertBefore(childVNode.$elm$, node);
                        node.remove();
                        if (childVNode.$depth$ === "0") {
                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                        }
                    }
                    slotNodes.push(childVNode);
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                } else if (childNodeType === CONTENT_REF_ID) {
                    if (BUILD.shadowDom && shadowRootNodes) {
                        node.remove();
                    } else if (BUILD.slotRelocation) {
                        hostElm["s-cr"] = node;
                        node["s-cn"] = true;
                    }
                }
            }
        }
    } else if (parentVNode && parentVNode.$tag$ === "style") {
        const vnode = newVNode(null, node.textContent);
        vnode.$elm$ = node;
        vnode.$index$ = "0";
        parentVNode.$children$ = [
            vnode
        ];
    }
};
var initializeDocumentHydrate = (node, orgLocNodes)=>{
    if (node.nodeType === 1) {
        let i2 = 0;
        for(; i2 < node.childNodes.length; i2++){
            initializeDocumentHydrate(node.childNodes[i2], orgLocNodes);
        }
        if (node.shadowRoot) {
            for(i2 = 0; i2 < node.shadowRoot.childNodes.length; i2++){
                initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);
            }
        }
    } else if (node.nodeType === 8) {
        const childIdSplt = node.nodeValue.split(".");
        if (childIdSplt[0] === ORG_LOCATION_ID) {
            orgLocNodes.set(childIdSplt[1] + "." + childIdSplt[2], node);
            node.nodeValue = "";
            node["s-en"] = childIdSplt[3];
        }
    }
};
var computeMode = (elm)=>modeResolutionChain.map((h2)=>h2(elm)).find((m)=>!!m);
var parsePropertyValue = (propValue, propType)=>{
    if (propValue != null && !isComplexType(propValue)) {
        if (BUILD.propBoolean && propType & 4) {
            return propValue === "false" ? false : propValue === "" || !!propValue;
        }
        if (BUILD.propNumber && propType & 2) {
            return parseFloat(propValue);
        }
        if (BUILD.propString && propType & 1) {
            return String(propValue);
        }
        return propValue;
    }
    return propValue;
};
var getElement = (ref)=>BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref;
var createEvent = (ref, name, flags)=>{
    const elm = getElement(ref);
    return {
        emit: (detail)=>{
            if (BUILD.isDev && !elm.isConnected) {
                consoleDevWarn(`The "${name}" event was emitted, but the dispatcher node is no longer connected to the dom.`);
            }
            return emitEvent(elm, name, {
                bubbles: !!(flags & 4),
                composed: !!(flags & 2),
                cancelable: !!(flags & 1),
                detail
            });
        }
    };
};
var emitEvent = (elm, name, opts)=>{
    const ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
};
var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
var registerStyle = (scopeId2, cssText, allowCS)=>{
    let style = styles.get(scopeId2);
    if (supportsConstructableStylesheets && allowCS) {
        style = style || new CSSStyleSheet();
        if (typeof style === "string") {
            style = cssText;
        } else {
            style.replaceSync(cssText);
        }
    } else {
        style = cssText;
    }
    styles.set(scopeId2, style);
};
var addStyle = (styleContainerNode, cmpMeta, mode, hostElm)=>{
    var _a;
    let scopeId2 = getScopeId(cmpMeta, mode);
    const style = styles.get(scopeId2);
    if (!BUILD.attachStyles) {
        return scopeId2;
    }
    styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
    if (style) {
        if (typeof style === "string") {
            styleContainerNode = styleContainerNode.head || styleContainerNode;
            let appliedStyles = rootAppliedStyles.get(styleContainerNode);
            let styleElm;
            if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
            }
            if (!appliedStyles.has(scopeId2)) {
                if (BUILD.hydrateClientSide && styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId2}"]`))) {
                    styleElm.innerHTML = style;
                } else {
                    if (BUILD.cssVarShim && plt.$cssShim$) {
                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId2, style, !!(cmpMeta.$flags$ & 10));
                        const newScopeId = styleElm["s-sc"];
                        if (newScopeId) {
                            scopeId2 = newScopeId;
                            appliedStyles = null;
                        }
                    } else {
                        styleElm = doc.createElement("style");
                        styleElm.innerHTML = style;
                    }
                    const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
                    if (nonce != null) {
                        styleElm.setAttribute("nonce", nonce);
                    }
                    if (BUILD.hydrateServerSide || BUILD.hotModuleReplacement) {
                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId2);
                    }
                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
                }
                if (appliedStyles) {
                    appliedStyles.add(scopeId2);
                }
            }
        } else if (BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {
            styleContainerNode.adoptedStyleSheets = [
                ...styleContainerNode.adoptedStyleSheets,
                style
            ];
        }
    }
    return scopeId2;
};
var attachStyles = (hostRef)=>{
    const cmpMeta = hostRef.$cmpMeta$;
    const elm = hostRef.$hostElement$;
    const flags = cmpMeta.$flags$;
    const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
    const scopeId2 = addStyle(BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);
    if ((BUILD.shadowDom || BUILD.scoped) && BUILD.cssAnnotations && flags & 10) {
        elm["s-sc"] = scopeId2;
        elm.classList.add(scopeId2 + "-h");
        if (BUILD.scoped && flags & 2) {
            elm.classList.add(scopeId2 + "-s");
        }
    }
    endAttachStyles();
};
var getScopeId = (cmp, mode)=>"sc-" + (BUILD.mode && mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags)=>{
    if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (BUILD.vdomClass && memberName === "class") {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            const newClasses = parseClassList(newValue);
            classList.remove(...oldClasses.filter((c)=>c && !newClasses.includes(c)));
            classList.add(...newClasses.filter((c)=>c && !oldClasses.includes(c)));
        } else if (BUILD.vdomStyle && memberName === "style") {
            if (BUILD.updatable) {
                for(const prop in oldValue){
                    if (!newValue || newValue[prop] == null) {
                        if (!BUILD.hydrateServerSide && prop.includes("-")) {
                            elm.style.removeProperty(prop);
                        } else {
                            elm.style[prop] = "";
                        }
                    }
                }
            }
            for(const prop in newValue){
                if (!oldValue || newValue[prop] !== oldValue[prop]) {
                    if (!BUILD.hydrateServerSide && prop.includes("-")) {
                        elm.style.setProperty(prop, newValue[prop]);
                    } else {
                        elm.style[prop] = newValue[prop];
                    }
                }
            }
        } else if (BUILD.vdomKey && memberName === "key") ;
        else if (BUILD.vdomRef && memberName === "ref") {
            if (newValue) {
                newValue(elm);
            }
        } else if (BUILD.vdomListener && (BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) && memberName[0] === "o" && memberName[1] === "n") {
            if (memberName[2] === "-") {
                memberName = memberName.slice(3);
            } else if (isMemberInElement(win, ln)) {
                memberName = ln.slice(2);
            } else {
                memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue) {
                plt.rel(elm, memberName, oldValue, false);
            }
            if (newValue) {
                plt.ael(elm, memberName, newValue, false);
            }
        } else if (BUILD.vdomPropOrAttr) {
            const isComplex = isComplexType(newValue);
            if ((isProp || isComplex && newValue !== null) && !isSvg) {
                try {
                    if (!elm.tagName.includes("-")) {
                        const n = newValue == null ? "" : newValue;
                        if (memberName === "list") {
                            isProp = false;
                        } else if (oldValue == null || elm[memberName] != n) {
                            elm[memberName] = n;
                        }
                    } else {
                        elm[memberName] = newValue;
                    }
                } catch (e) {}
            }
            let xlink = false;
            if (BUILD.vdomXlink) {
                if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
                    memberName = ln;
                    xlink = true;
                }
            }
            if (newValue == null || newValue === false) {
                if (newValue !== false || elm.getAttribute(memberName) === "") {
                    if (BUILD.vdomXlink && xlink) {
                        elm.removeAttributeNS(XLINK_NS, memberName);
                    } else {
                        elm.removeAttribute(memberName);
                    }
                }
            } else if ((!isProp || flags & 4 || isSvg) && !isComplex) {
                newValue = newValue === true ? "" : newValue;
                if (BUILD.vdomXlink && xlink) {
                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
                } else {
                    elm.setAttribute(memberName, newValue);
                }
            }
        }
    }
};
var parseClassListRegex = /\s/;
var parseClassList = (value)=>!value ? [] : value.split(parseClassListRegex);
var updateElement = (oldVnode, newVnode, isSvgMode2, memberName)=>{
    const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
    const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    if (BUILD.updatable) {
        for(memberName in oldVnodeAttrs){
            if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
            }
        }
    }
    for(memberName in newVnodeAttrs){
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
    }
};
var createElm = (oldParentVNode, newParentVNode, childIndex, parentElm)=>{
    const newVNode2 = newParentVNode.$children$[childIndex];
    let i2 = 0;
    let elm;
    let childNode;
    let oldVNode;
    if (BUILD.slotRelocation && !useNativeShadowDom) {
        checkSlotRelocate = true;
        if (newVNode2.$tag$ === "slot") {
            if (scopeId) {
                parentElm.classList.add(scopeId + "-s");
            }
            newVNode2.$flags$ |= newVNode2.$children$ ? 2 : 1;
        }
    }
    if (BUILD.isDev && newVNode2.$elm$) {
        consoleDevError(`The JSX ${newVNode2.$text$ !== null ? `"${newVNode2.$text$}" text` : `"${newVNode2.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);
    }
    if (BUILD.vdomText && newVNode2.$text$ !== null) {
        elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
    } else if (BUILD.slotRelocation && newVNode2.$flags$ & 1) {
        elm = newVNode2.$elm$ = BUILD.isDebug || BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode2) : doc.createTextNode("");
    } else {
        if (BUILD.svg && !isSvgMode) {
            isSvgMode = newVNode2.$tag$ === "svg";
        }
        elm = newVNode2.$elm$ = BUILD.svg ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$) : doc.createElement(BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
        if (BUILD.svg && isSvgMode && newVNode2.$tag$ === "foreignObject") {
            isSvgMode = false;
        }
        if (BUILD.vdomAttribute) {
            updateElement(null, newVNode2, isSvgMode);
        }
        if ((BUILD.shadowDom || BUILD.scoped) && isDef(scopeId) && elm["s-si"] !== scopeId) {
            elm.classList.add(elm["s-si"] = scopeId);
        }
        if (newVNode2.$children$) {
            for(i2 = 0; i2 < newVNode2.$children$.length; ++i2){
                childNode = createElm(oldParentVNode, newVNode2, i2, elm);
                if (childNode) {
                    elm.appendChild(childNode);
                }
            }
        }
        if (BUILD.svg) {
            if (newVNode2.$tag$ === "svg") {
                isSvgMode = false;
            } else if (elm.tagName === "foreignObject") {
                isSvgMode = true;
            }
        }
    }
    if (BUILD.slotRelocation) {
        elm["s-hn"] = hostTagName;
        if (newVNode2.$flags$ & (2 | 1)) {
            elm["s-sr"] = true;
            elm["s-cr"] = contentRef;
            elm["s-sn"] = newVNode2.$name$ || "";
            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
            if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
                putBackInOriginalLocation(oldParentVNode.$elm$, false);
            }
        }
    }
    return elm;
};
var putBackInOriginalLocation = (parentElm, recursive)=>{
    plt.$flags$ |= 1;
    const oldSlotChildNodes = parentElm.childNodes;
    for(let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--){
        const childNode = oldSlotChildNodes[i2];
        if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
            childNode["s-ol"].remove();
            childNode["s-ol"] = void 0;
            checkSlotRelocate = true;
        }
        if (recursive) {
            putBackInOriginalLocation(childNode, recursive);
        }
    }
    plt.$flags$ &= ~1;
};
var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx)=>{
    let containerElm = BUILD.slotRelocation && parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
    let childNode;
    if (BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
    }
    for(; startIdx <= endIdx; ++startIdx){
        if (vnodes[startIdx]) {
            childNode = createElm(null, parentVNode, startIdx, parentElm);
            if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                containerElm.insertBefore(childNode, BUILD.slotRelocation ? referenceNode(before) : before);
            }
        }
    }
};
var removeVnodes = (vnodes, startIdx, endIdx, vnode, elm)=>{
    for(; startIdx <= endIdx; ++startIdx){
        if (vnode = vnodes[startIdx]) {
            elm = vnode.$elm$;
            callNodeRefs(vnode);
            if (BUILD.slotRelocation) {
                checkSlotFallbackVisibility = true;
                if (elm["s-ol"]) {
                    elm["s-ol"].remove();
                } else {
                    putBackInOriginalLocation(elm, true);
                }
            }
            elm.remove();
        }
    }
};
var updateChildren = (parentElm, oldCh, newVNode2, newCh)=>{
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let idxInOld = 0;
    let i2 = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let node;
    let elmToMove;
    while(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){
        if (oldStartVnode == null) {
            oldStartVnode = oldCh[++oldStartIdx];
        } else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
        } else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
        } else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newStartVnode)) {
            patch(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        } else if (isSameVnode(oldEndVnode, newEndVnode)) {
            patch(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newEndVnode)) {
            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
            }
            patch(oldStartVnode, newEndVnode);
            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldEndVnode, newStartVnode)) {
            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
            }
            patch(oldEndVnode, newStartVnode);
            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        } else {
            idxInOld = -1;
            if (BUILD.vdomKey) {
                for(i2 = oldStartIdx; i2 <= oldEndIdx; ++i2){
                    if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
                        idxInOld = i2;
                        break;
                    }
                }
            }
            if (BUILD.vdomKey && idxInOld >= 0) {
                elmToMove = oldCh[idxInOld];
                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                    node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
                } else {
                    patch(elmToMove, newStartVnode);
                    oldCh[idxInOld] = void 0;
                    node = elmToMove.$elm$;
                }
                newStartVnode = newCh[++newStartIdx];
            } else {
                node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
                newStartVnode = newCh[++newStartIdx];
            }
            if (node) {
                if (BUILD.slotRelocation) {
                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
                } else {
                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
                }
            }
        }
    }
    if (oldStartIdx > oldEndIdx) {
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
    } else if (BUILD.updatable && newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
};
var isSameVnode = (leftVNode, rightVNode)=>{
    if (leftVNode.$tag$ === rightVNode.$tag$) {
        if (BUILD.slotRelocation && leftVNode.$tag$ === "slot") {
            return leftVNode.$name$ === rightVNode.$name$;
        }
        if (BUILD.vdomKey) {
            return leftVNode.$key$ === rightVNode.$key$;
        }
        return true;
    }
    return false;
};
var referenceNode = (node)=>{
    return node && node["s-ol"] || node;
};
var parentReferenceNode = (node)=>(node["s-ol"] ? node["s-ol"] : node).parentNode;
var patch = (oldVNode, newVNode2)=>{
    const elm = newVNode2.$elm$ = oldVNode.$elm$;
    const oldChildren = oldVNode.$children$;
    const newChildren = newVNode2.$children$;
    const tag = newVNode2.$tag$;
    const text2 = newVNode2.$text$;
    let defaultHolder;
    if (!BUILD.vdomText || text2 === null) {
        if (BUILD.svg) {
            isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
        }
        if (BUILD.vdomAttribute || BUILD.reflect) {
            if (BUILD.slot && tag === "slot") ;
            else {
                updateElement(oldVNode, newVNode2, isSvgMode);
            }
        }
        if (BUILD.updatable && oldChildren !== null && newChildren !== null) {
            updateChildren(elm, oldChildren, newVNode2, newChildren);
        } else if (newChildren !== null) {
            if (BUILD.updatable && BUILD.vdomText && oldVNode.$text$ !== null) {
                elm.textContent = "";
            }
            addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
        } else if (BUILD.updatable && oldChildren !== null) {
            removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
        if (BUILD.svg && isSvgMode && tag === "svg") {
            isSvgMode = false;
        }
    } else if (BUILD.vdomText && BUILD.slotRelocation && (defaultHolder = elm["s-cr"])) {
        defaultHolder.parentNode.textContent = text2;
    } else if (BUILD.vdomText && oldVNode.$text$ !== text2) {
        elm.data = text2;
    }
};
var updateFallbackSlotVisibility = (elm)=>{
    const childNodes = elm.childNodes;
    let childNode;
    let i2;
    let ilen;
    let j;
    let slotNameAttr;
    let nodeType;
    for(i2 = 0, ilen = childNodes.length; i2 < ilen; i2++){
        childNode = childNodes[i2];
        if (childNode.nodeType === 1) {
            if (childNode["s-sr"]) {
                slotNameAttr = childNode["s-sn"];
                childNode.hidden = false;
                for(j = 0; j < ilen; j++){
                    nodeType = childNodes[j].nodeType;
                    if (childNodes[j]["s-hn"] !== childNode["s-hn"] || slotNameAttr !== "") {
                        if (nodeType === 1 && slotNameAttr === childNodes[j].getAttribute("slot")) {
                            childNode.hidden = true;
                            break;
                        }
                    } else {
                        if (nodeType === 1 || nodeType === 3 && childNodes[j].textContent.trim() !== "") {
                            childNode.hidden = true;
                            break;
                        }
                    }
                }
            }
            updateFallbackSlotVisibility(childNode);
        }
    }
};
var relocateNodes = [];
var relocateSlotContent = (elm)=>{
    let childNode;
    let node;
    let hostContentNodes;
    let slotNameAttr;
    let relocateNodeData;
    let j;
    let i2 = 0;
    const childNodes = elm.childNodes;
    const ilen = childNodes.length;
    for(; i2 < ilen; i2++){
        childNode = childNodes[i2];
        if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
            hostContentNodes = node.parentNode.childNodes;
            slotNameAttr = childNode["s-sn"];
            for(j = hostContentNodes.length - 1; j >= 0; j--){
                node = hostContentNodes[j];
                if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"]) {
                    if (isNodeLocatedInSlot(node, slotNameAttr)) {
                        relocateNodeData = relocateNodes.find((r)=>r.$nodeToRelocate$ === node);
                        checkSlotFallbackVisibility = true;
                        node["s-sn"] = node["s-sn"] || slotNameAttr;
                        if (relocateNodeData) {
                            relocateNodeData.$slotRefNode$ = childNode;
                        } else {
                            relocateNodes.push({
                                $slotRefNode$: childNode,
                                $nodeToRelocate$: node
                            });
                        }
                        if (node["s-sr"]) {
                            relocateNodes.map((relocateNode)=>{
                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                                    relocateNodeData = relocateNodes.find((r)=>r.$nodeToRelocate$ === node);
                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {
                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                                    }
                                }
                            });
                        }
                    } else if (!relocateNodes.some((r)=>r.$nodeToRelocate$ === node)) {
                        relocateNodes.push({
                            $nodeToRelocate$: node
                        });
                    }
                }
            }
        }
        if (childNode.nodeType === 1) {
            relocateSlotContent(childNode);
        }
    }
};
var isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr)=>{
    if (nodeToRelocate.nodeType === 1) {
        if (nodeToRelocate.getAttribute("slot") === null && slotNameAttr === "") {
            return true;
        }
        if (nodeToRelocate.getAttribute("slot") === slotNameAttr) {
            return true;
        }
        return false;
    }
    if (nodeToRelocate["s-sn"] === slotNameAttr) {
        return true;
    }
    return slotNameAttr === "";
};
var callNodeRefs = (vNode)=>{
    if (BUILD.vdomRef) {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.map(callNodeRefs);
    }
};
var renderVdom = (hostRef, renderFnResults)=>{
    const hostElm = hostRef.$hostElement$;
    const cmpMeta = hostRef.$cmpMeta$;
    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    if (BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {
        throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${hostTagName.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);
    }
    if (BUILD.reflect && cmpMeta.$attrsToReflect$) {
        rootVnode.$attrs$ = rootVnode.$attrs$ || {};
        cmpMeta.$attrsToReflect$.map(([propName, attribute])=>rootVnode.$attrs$[attribute] = hostElm[propName]);
    }
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm;
    if (BUILD.scoped || BUILD.shadowDom) {
        scopeId = hostElm["s-sc"];
    }
    if (BUILD.slotRelocation) {
        contentRef = hostElm["s-cr"];
        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1) !== 0;
        checkSlotFallbackVisibility = false;
    }
    patch(oldVNode, rootVnode);
    if (BUILD.slotRelocation) {
        plt.$flags$ |= 1;
        if (checkSlotRelocate) {
            relocateSlotContent(rootVnode.$elm$);
            let relocateData;
            let nodeToRelocate;
            let orgLocationNode;
            let parentNodeRef;
            let insertBeforeNode;
            let refNode;
            let i2 = 0;
            for(; i2 < relocateNodes.length; i2++){
                relocateData = relocateNodes[i2];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (!nodeToRelocate["s-ol"]) {
                    orgLocationNode = BUILD.isDebug || BUILD.hydrateServerSide ? originalLocationDebugNode(nodeToRelocate) : doc.createTextNode("");
                    orgLocationNode["s-nr"] = nodeToRelocate;
                    nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
                }
            }
            for(i2 = 0; i2 < relocateNodes.length; i2++){
                relocateData = relocateNodes[i2];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (relocateData.$slotRefNode$) {
                    parentNodeRef = relocateData.$slotRefNode$.parentNode;
                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
                    orgLocationNode = nodeToRelocate["s-ol"];
                    while(orgLocationNode = orgLocationNode.previousSibling){
                        refNode = orgLocationNode["s-nr"];
                        if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
                            refNode = refNode.nextSibling;
                            if (!refNode || !refNode["s-nr"]) {
                                insertBeforeNode = refNode;
                                break;
                            }
                        }
                    }
                    if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
                        if (nodeToRelocate !== insertBeforeNode) {
                            if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
                            }
                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
                        }
                    }
                } else {
                    if (nodeToRelocate.nodeType === 1) {
                        nodeToRelocate.hidden = true;
                    }
                }
            }
        }
        if (checkSlotFallbackVisibility) {
            updateFallbackSlotVisibility(rootVnode.$elm$);
        }
        plt.$flags$ &= ~1;
        relocateNodes.length = 0;
    }
};
var slotReferenceDebugNode = (slotVNode)=>doc.createComment(`<slot${slotVNode.$name$ ? ' name="' + slotVNode.$name$ + '"' : ""}> (host=${hostTagName.toLowerCase()})`);
var originalLocationDebugNode = (nodeToRelocate)=>doc.createComment(`org-location for ` + (nodeToRelocate.localName ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate["s-hn"]})` : `[${nodeToRelocate.textContent}]`));
var attachToAncestor = (hostRef, ancestorComponent)=>{
    if (BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
        ancestorComponent["s-p"].push(new Promise((r)=>hostRef.$onRenderResolve$ = r));
    }
};
var scheduleUpdate = (hostRef, isInitialLoad)=>{
    if (BUILD.taskQueue && BUILD.updatable) {
        hostRef.$flags$ |= 16;
    }
    if (BUILD.asyncLoading && hostRef.$flags$ & 4) {
        hostRef.$flags$ |= 512;
        return;
    }
    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
    const dispatch = ()=>dispatchHooks(hostRef, isInitialLoad);
    return BUILD.taskQueue ? writeTask(dispatch) : dispatch();
};
var dispatchHooks = (hostRef, isInitialLoad)=>{
    const elm = hostRef.$hostElement$;
    const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    let promise;
    if (isInitialLoad) {
        if (BUILD.lazyLoad && BUILD.hostListener) {
            hostRef.$flags$ |= 256;
            if (hostRef.$queuedListeners$) {
                hostRef.$queuedListeners$.map(([methodName, event2])=>safeCall(instance, methodName, event2));
                hostRef.$queuedListeners$ = null;
            }
        }
        emitLifecycleEvent(elm, "componentWillLoad");
        if (BUILD.cmpWillLoad) {
            promise = safeCall(instance, "componentWillLoad");
        }
    } else {
        emitLifecycleEvent(elm, "componentWillUpdate");
        if (BUILD.cmpWillUpdate) {
            promise = safeCall(instance, "componentWillUpdate");
        }
    }
    emitLifecycleEvent(elm, "componentWillRender");
    if (BUILD.cmpWillRender) {
        promise = then(promise, ()=>safeCall(instance, "componentWillRender"));
    }
    endSchedule();
    return then(promise, ()=>updateComponent(hostRef, instance, isInitialLoad));
};
var updateComponent = function() {
    var _ref = _asyncToGenerator(function*(hostRef, instance, isInitialLoad) {
        const elm = hostRef.$hostElement$;
        const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
        const rc = elm["s-rc"];
        if (BUILD.style && isInitialLoad) {
            attachStyles(hostRef);
        }
        const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
        if (BUILD.isDev) {
            hostRef.$flags$ |= 1024;
        }
        if (BUILD.hydrateServerSide) {
            yield callRender(hostRef, instance, elm);
        } else {
            callRender(hostRef, instance, elm);
        }
        if (BUILD.cssVarShim && plt.$cssShim$) {
            plt.$cssShim$.updateHost(elm);
        }
        if (BUILD.isDev) {
            hostRef.$renderCount$++;
            hostRef.$flags$ &= ~1024;
        }
        if (BUILD.hydrateServerSide) {
            try {
                serverSideConnected(elm);
                if (isInitialLoad) {
                    if (hostRef.$cmpMeta$.$flags$ & 1) {
                        elm["s-en"] = "";
                    } else if (hostRef.$cmpMeta$.$flags$ & 2) {
                        elm["s-en"] = "c";
                    }
                }
            } catch (e) {
                consoleError(e, elm);
            }
        }
        if (BUILD.asyncLoading && rc) {
            rc.map((cb)=>cb());
            elm["s-rc"] = void 0;
        }
        endRender();
        endUpdate();
        if (BUILD.asyncLoading) {
            const childrenPromises = elm["s-p"];
            const postUpdate = ()=>postUpdateComponent(hostRef);
            if (childrenPromises.length === 0) {
                postUpdate();
            } else {
                Promise.all(childrenPromises).then(postUpdate);
                hostRef.$flags$ |= 4;
                childrenPromises.length = 0;
            }
        } else {
            postUpdateComponent(hostRef);
        }
    });
    return function updateComponent(hostRef, instance, isInitialLoad) {
        return _ref.apply(this, arguments);
    };
}();
var callRender = (hostRef, instance, elm)=>{
    const allRenderFn = BUILD.allRenderFn ? true : false;
    const lazyLoad2 = BUILD.lazyLoad ? true : false;
    const taskQueue = BUILD.taskQueue ? true : false;
    const updatable = BUILD.updatable ? true : false;
    try {
        renderingRef = instance;
        instance = allRenderFn ? instance.render() : instance.render && instance.render();
        if (updatable && taskQueue) {
            hostRef.$flags$ &= ~16;
        }
        if (updatable || lazyLoad2) {
            hostRef.$flags$ |= 2;
        }
        if (BUILD.hasRenderFn || BUILD.reflect) {
            if (BUILD.vdomRender || BUILD.reflect) {
                if (BUILD.hydrateServerSide) {
                    return Promise.resolve(instance).then((value)=>renderVdom(hostRef, value));
                } else {
                    renderVdom(hostRef, instance);
                }
            } else {
                elm.textContent = instance;
            }
        }
    } catch (e) {
        consoleError(e, hostRef.$hostElement$);
    }
    renderingRef = null;
    return null;
};
var postUpdateComponent = (hostRef)=>{
    const tagName = hostRef.$cmpMeta$.$tagName$;
    const elm = hostRef.$hostElement$;
    const endPostUpdate = createTime("postUpdate", tagName);
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    const ancestorComponent = hostRef.$ancestorComponent$;
    if (BUILD.cmpDidRender) {
        if (BUILD.isDev) {
            hostRef.$flags$ |= 1024;
        }
        safeCall(instance, "componentDidRender");
        if (BUILD.isDev) {
            hostRef.$flags$ &= ~1024;
        }
    }
    emitLifecycleEvent(elm, "componentDidRender");
    if (!(hostRef.$flags$ & 64)) {
        hostRef.$flags$ |= 64;
        if (BUILD.asyncLoading && BUILD.cssAnnotations) {
            addHydratedFlag(elm);
        }
        if (BUILD.cmpDidLoad) {
            if (BUILD.isDev) {
                hostRef.$flags$ |= 2048;
            }
            safeCall(instance, "componentDidLoad");
            if (BUILD.isDev) {
                hostRef.$flags$ &= ~2048;
            }
        }
        emitLifecycleEvent(elm, "componentDidLoad");
        endPostUpdate();
        if (BUILD.asyncLoading) {
            hostRef.$onReadyResolve$(elm);
            if (!ancestorComponent) {
                appDidLoad(tagName);
            }
        }
    } else {
        if (BUILD.cmpDidUpdate) {
            if (BUILD.isDev) {
                hostRef.$flags$ |= 1024;
            }
            safeCall(instance, "componentDidUpdate");
            if (BUILD.isDev) {
                hostRef.$flags$ &= ~1024;
            }
        }
        emitLifecycleEvent(elm, "componentDidUpdate");
        endPostUpdate();
    }
    if (BUILD.hotModuleReplacement) {
        elm["s-hmr-load"] && elm["s-hmr-load"]();
    }
    if (BUILD.method && BUILD.lazyLoad) {
        hostRef.$onInstanceResolve$(elm);
    }
    if (BUILD.asyncLoading) {
        if (hostRef.$onRenderResolve$) {
            hostRef.$onRenderResolve$();
            hostRef.$onRenderResolve$ = void 0;
        }
        if (hostRef.$flags$ & 512) {
            nextTick2(()=>scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 | 512);
    }
};
var appDidLoad = (who)=>{
    if (BUILD.cssAnnotations) {
        addHydratedFlag(doc.documentElement);
    }
    if (BUILD.asyncQueue) {
        plt.$flags$ |= 2;
    }
    nextTick2(()=>emitEvent(win, "appload", {
            detail: {
                namespace: NAMESPACE
            }
        }));
    if (BUILD.profile && performance.measure) {
        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, "st:app:start");
    }
};
var safeCall = (instance, method, arg)=>{
    if (instance && instance[method]) {
        try {
            return instance[method](arg);
        } catch (e) {
            consoleError(e);
        }
    }
    return void 0;
};
var then = (promise, thenFn)=>{
    return promise && promise.then ? promise.then(thenFn) : thenFn();
};
var emitLifecycleEvent = (elm, lifecycleName)=>{
    if (BUILD.lifecycleDOMEvents) {
        emitEvent(elm, "stencil_" + lifecycleName, {
            bubbles: true,
            composed: true,
            detail: {
                namespace: NAMESPACE
            }
        });
    }
};
var addHydratedFlag = (elm)=>BUILD.hydratedClass ? elm.classList.add("hydrated") : BUILD.hydratedAttribute ? elm.setAttribute("hydrated", "") : void 0;
var serverSideConnected = (elm)=>{
    const children2 = elm.children;
    if (children2 != null) {
        for(let i2 = 0, ii = children2.length; i2 < ii; i2++){
            const childElm = children2[i2];
            if (typeof childElm.connectedCallback === "function") {
                childElm.connectedCallback();
            }
            serverSideConnected(childElm);
        }
    }
};
var getValue = (ref, propName)=>getHostRef(ref).$instanceValues$.get(propName);
var setValue = (ref, propName, newVal, cmpMeta)=>{
    const hostRef = getHostRef(ref);
    const elm = BUILD.lazyLoad ? hostRef.$hostElement$ : ref;
    const oldVal = hostRef.$instanceValues$.get(propName);
    const flags = hostRef.$flags$;
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
    const didValueChange = newVal !== oldVal && !areBothNaN;
    if ((!BUILD.lazyLoad || !(flags & 8) || oldVal === void 0) && didValueChange) {
        hostRef.$instanceValues$.set(propName, newVal);
        if (BUILD.isDev) {
            if (hostRef.$flags$ & 1024) {
                consoleDevWarn(`The state/prop "${propName}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, "\nElement", elm, "\nNew value", newVal, "\nOld value", oldVal);
            } else if (hostRef.$flags$ & 2048) {
                consoleDevWarn(`The state/prop "${propName}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`, "\nElement", elm, "\nNew value", newVal, "\nOld value", oldVal);
            }
        }
        if (!BUILD.lazyLoad || instance) {
            if (BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128) {
                const watchMethods = cmpMeta.$watchers$[propName];
                if (watchMethods) {
                    watchMethods.map((watchMethodName)=>{
                        try {
                            instance[watchMethodName](newVal, oldVal, propName);
                        } catch (e) {
                            consoleError(e, elm);
                        }
                    });
                }
            }
            if (BUILD.updatable && (flags & (2 | 16)) === 2) {
                if (BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {
                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
                        return;
                    }
                }
                scheduleUpdate(hostRef, false);
            }
        }
    }
};
var proxyComponent = (Cstr, cmpMeta, flags)=>{
    if (BUILD.member && cmpMeta.$members$) {
        if (BUILD.watchCallback && Cstr.watchers) {
            cmpMeta.$watchers$ = Cstr.watchers;
        }
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]])=>{
            if ((BUILD.prop || BUILD.state) && (memberFlags & 31 || (!BUILD.lazyLoad || flags & 2) && memberFlags & 32)) {
                Object.defineProperty(prototype, memberName, {
                    get () {
                        return getValue(this, memberName);
                    },
                    set (newValue) {
                        if (BUILD.isDev) {
                            const ref = getHostRef(this);
                            if ((flags & 1) === 0 && (ref.$flags$ & 8) === 0 && (memberFlags & 31) !== 0 && (memberFlags & 1024) === 0) {
                                consoleDevWarn(`@Prop() "${memberName}" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`);
                            }
                        }
                        setValue(this, memberName, newValue, cmpMeta);
                    },
                    configurable: true,
                    enumerable: true
                });
            } else if (BUILD.lazyLoad && BUILD.method && flags & 1 && memberFlags & 64) {
                Object.defineProperty(prototype, memberName, {
                    value (...args) {
                        const ref = getHostRef(this);
                        return ref.$onInstancePromise$.then(()=>ref.$lazyInstance$[memberName](...args));
                    }
                });
            }
        });
        if (BUILD.observeAttribute && (!BUILD.lazyLoad || flags & 1)) {
            const attrNameToPropName = /* @__PURE__ */ new Map();
            prototype.attributeChangedCallback = function(attrName, _oldValue, newValue) {
                plt.jmp(()=>{
                    const propName = attrNameToPropName.get(attrName);
                    if (this.hasOwnProperty(propName)) {
                        newValue = this[propName];
                        delete this[propName];
                    } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
                        return;
                    }
                    this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
                });
            };
            Cstr.observedAttributes = members.filter(([_, m])=>m[0] & 15).map(([propName, m])=>{
                const attrName = m[1] || propName;
                attrNameToPropName.set(attrName, propName);
                if (BUILD.reflect && m[0] & 512) {
                    cmpMeta.$attrsToReflect$.push([
                        propName,
                        attrName
                    ]);
                }
                return attrName;
            });
        }
    }
    return Cstr;
};
var initializeComponent = function() {
    var _ref = _asyncToGenerator(function*(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
        if ((BUILD.lazyLoad || BUILD.hydrateServerSide || BUILD.style) && (hostRef.$flags$ & 32) === 0) {
            if (BUILD.lazyLoad || BUILD.hydrateClientSide) {
                hostRef.$flags$ |= 32;
                Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);
                if (Cstr.then) {
                    const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);
                    Cstr = yield Cstr;
                    endLoad();
                }
                if ((BUILD.isDev || BUILD.isDebug) && !Cstr) {
                    throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
                }
                if (BUILD.member && !Cstr.isProxied) {
                    if (BUILD.watchCallback) {
                        cmpMeta.$watchers$ = Cstr.watchers;
                    }
                    proxyComponent(Cstr, cmpMeta, 2);
                    Cstr.isProxied = true;
                }
                const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
                if (BUILD.member) {
                    hostRef.$flags$ |= 8;
                }
                try {
                    new Cstr(hostRef);
                } catch (e) {
                    consoleError(e);
                }
                if (BUILD.member) {
                    hostRef.$flags$ &= ~8;
                }
                if (BUILD.watchCallback) {
                    hostRef.$flags$ |= 128;
                }
                endNewInstance();
                fireConnectedCallback(hostRef.$lazyInstance$);
            } else {
                Cstr = elm.constructor;
                hostRef.$flags$ |= 32;
                customElements.whenDefined(cmpMeta.$tagName$).then(()=>hostRef.$flags$ |= 128);
            }
            if (BUILD.style && Cstr.style) {
                let style = Cstr.style;
                if (BUILD.mode && typeof style !== "string") {
                    style = style[hostRef.$modeName$ = computeMode(elm)];
                    if (BUILD.hydrateServerSide && hostRef.$modeName$) {
                        elm.setAttribute("s-mode", hostRef.$modeName$);
                    }
                }
                const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
                if (!styles.has(scopeId2)) {
                    const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
                    if (!BUILD.hydrateServerSide && BUILD.shadowDom && BUILD.shadowDomShim && cmpMeta.$flags$ & 8) {
                        style = yield import("./shadow-css-YTDTKUFZ.js").then((m)=>m.scopeCss(style, scopeId2, false));
                    }
                    registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
                    endRegisterStyles();
                }
            }
        }
        const ancestorComponent = hostRef.$ancestorComponent$;
        const schedule = ()=>scheduleUpdate(hostRef, true);
        if (BUILD.asyncLoading && ancestorComponent && ancestorComponent["s-rc"]) {
            ancestorComponent["s-rc"].push(schedule);
        } else {
            schedule();
        }
    });
    return function initializeComponent(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
        return _ref.apply(this, arguments);
    };
}();
var fireConnectedCallback = (instance)=>{
    if (BUILD.lazyLoad && BUILD.connectedCallback) {
        safeCall(instance, "connectedCallback");
    }
};
var connectedCallback = (elm)=>{
    if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
        if (BUILD.hostListenerTargetParent) {
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);
        }
        if (!(hostRef.$flags$ & 1)) {
            hostRef.$flags$ |= 1;
            let hostId;
            if (BUILD.hydrateClientSide) {
                hostId = elm.getAttribute(HYDRATE_ID);
                if (hostId) {
                    if (BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1) {
                        const scopeId2 = BUILD.mode ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute("s-mode")) : addStyle(elm.shadowRoot, cmpMeta);
                        elm.classList.remove(scopeId2 + "-h", scopeId2 + "-s");
                    }
                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
                }
            }
            if (BUILD.slotRelocation && !hostId) {
                if (BUILD.hydrateServerSide || (BUILD.slot || BUILD.shadowDom) && cmpMeta.$flags$ & (4 | 8)) {
                    setContentReference(elm);
                }
            }
            if (BUILD.asyncLoading) {
                let ancestorComponent = elm;
                while(ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host){
                    if (BUILD.hydrateClientSide && ancestorComponent.nodeType === 1 && ancestorComponent.hasAttribute("s-id") && ancestorComponent["s-p"] || ancestorComponent["s-p"]) {
                        attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
                        break;
                    }
                }
            }
            if (BUILD.prop && !BUILD.hydrateServerSide && cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]])=>{
                    if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
                        const value = elm[memberName];
                        delete elm[memberName];
                        elm[memberName] = value;
                    }
                });
            }
            if (BUILD.initializeNextTick) {
                nextTick2(()=>initializeComponent(elm, hostRef, cmpMeta));
            } else {
                initializeComponent(elm, hostRef, cmpMeta);
            }
        } else {
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        endConnected();
    }
};
var setContentReference = (elm)=>{
    const contentRefElm = elm["s-cr"] = doc.createComment(BUILD.isDebug ? `content-ref (host=${elm.localName})` : "");
    contentRefElm["s-cn"] = true;
    elm.insertBefore(contentRefElm, elm.firstChild);
};
var disconnectedCallback = (elm)=>{
    if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
        if (BUILD.hostListener) {
            if (hostRef.$rmListeners$) {
                hostRef.$rmListeners$.map((rmListener)=>rmListener());
                hostRef.$rmListeners$ = void 0;
            }
        }
        if (BUILD.cssVarShim && plt.$cssShim$) {
            plt.$cssShim$.removeHost(elm);
        }
        if (BUILD.lazyLoad && BUILD.disconnectedCallback) {
            safeCall(instance, "disconnectedCallback");
        }
        if (BUILD.cmpDidUnload) {
            safeCall(instance, "componentDidUnload");
        }
    }
};
var proxyCustomElement = (Cstr, compactMeta)=>{
    const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1]
    };
    if (BUILD.member) {
        cmpMeta.$members$ = compactMeta[2];
    }
    if (BUILD.hostListener) {
        cmpMeta.$listeners$ = compactMeta[3];
    }
    if (BUILD.watchCallback) {
        cmpMeta.$watchers$ = Cstr.$watchers$;
    }
    if (BUILD.reflect) {
        cmpMeta.$attrsToReflect$ = [];
    }
    if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1) {
        cmpMeta.$flags$ |= 8;
    }
    const originalConnectedCallback = Cstr.prototype.connectedCallback;
    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
    Object.assign(Cstr.prototype, {
        __registerHost () {
            registerHost(this, cmpMeta);
        },
        connectedCallback () {
            connectedCallback(this);
            if (BUILD.connectedCallback && originalConnectedCallback) {
                originalConnectedCallback.call(this);
            }
        },
        disconnectedCallback () {
            disconnectedCallback(this);
            if (BUILD.disconnectedCallback && originalDisconnectedCallback) {
                originalDisconnectedCallback.call(this);
            }
        },
        __attachShadow () {
            if (supportsShadow) {
                if (BUILD.shadowDelegatesFocus) {
                    this.attachShadow({
                        mode: "open",
                        delegatesFocus: !!(cmpMeta.$flags$ & 16)
                    });
                } else {
                    this.attachShadow({
                        mode: "open"
                    });
                }
            } else {
                this.shadowRoot = this;
            }
        }
    });
    Cstr.is = cmpMeta.$tagName$;
    return proxyComponent(Cstr, cmpMeta, 1 | 2);
};
var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners)=>{
    if (BUILD.hostListener && listeners) {
        if (BUILD.hostListenerTargetParent) {
            if (attachParentListeners) {
                listeners = listeners.filter(([flags])=>flags & 32);
            } else {
                listeners = listeners.filter(([flags])=>!(flags & 32));
            }
        }
        listeners.map(([flags, name, method])=>{
            const target = BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;
            const handler = hostListenerProxy(hostRef, method);
            const opts = hostListenerOpts(flags);
            plt.ael(target, name, handler, opts);
            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(()=>plt.rel(target, name, handler, opts));
        });
    }
};
var hostListenerProxy = (hostRef, methodName)=>(ev)=>{
        try {
            if (BUILD.lazyLoad) {
                if (hostRef.$flags$ & 256) {
                    hostRef.$lazyInstance$[methodName](ev);
                } else {
                    (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([
                        methodName,
                        ev
                    ]);
                }
            } else {
                hostRef.$hostElement$[methodName](ev);
            }
        } catch (e) {
            consoleError(e);
        }
    };
var getHostListenerTarget = (elm, flags)=>{
    if (BUILD.hostListenerTargetDocument && flags & 4) return doc;
    if (BUILD.hostListenerTargetWindow && flags & 8) return win;
    if (BUILD.hostListenerTargetBody && flags & 16) return doc.body;
    if (BUILD.hostListenerTargetParent && flags & 32) return elm.parentElement;
    return elm;
};
var hostListenerOpts = (flags)=>supportsListenerOptions ? {
        passive: (flags & 1) !== 0,
        capture: (flags & 2) !== 0
    } : (flags & 2) !== 0;
var hostRefs = /* @__PURE__ */ new WeakMap();
var getHostRef = (ref)=>hostRefs.get(ref);
var registerHost = (elm, cmpMeta)=>{
    const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: /* @__PURE__ */ new Map()
    };
    if (BUILD.isDev) {
        hostRef.$renderCount$ = 0;
    }
    if (BUILD.method && BUILD.lazyLoad) {
        hostRef.$onInstancePromise$ = new Promise((r)=>hostRef.$onInstanceResolve$ = r);
    }
    if (BUILD.asyncLoading) {
        hostRef.$onReadyPromise$ = new Promise((r)=>hostRef.$onReadyResolve$ = r);
        elm["s-p"] = [];
        elm["s-rc"] = [];
    }
    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
    return hostRefs.set(elm, hostRef);
};
var isMemberInElement = (elm, memberName)=>memberName in elm;
var consoleError = (e, el)=>(customError || console.error)(e, el);
var STENCIL_DEV_MODE = BUILD.isTesting ? [
    "STENCIL:"
] : [
    "%cstencil",
    "color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"
];
var consoleDevError = (...m)=>console.error(...STENCIL_DEV_MODE, ...m);
var consoleDevWarn = (...m)=>console.warn(...STENCIL_DEV_MODE, ...m);
var cmpModules = /* @__PURE__ */ new Map();
var loadModule = (cmpMeta, hostRef, hmrVersionId)=>{
    const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
    const bundleId = cmpMeta.$lazyBundleId$;
    if (BUILD.isDev && typeof bundleId !== "string") {
        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode "${hostRef.$modeName$}", but it does not exist.`);
        return void 0;
    }
    const module = !BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;
    if (module) {
        return module[exportName];
    }
    return import(/* @vite-ignore */ /* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */ `./${bundleId}.entry.js${BUILD.hotModuleReplacement && hmrVersionId ? "?s-hmr=" + hmrVersionId : ""}`).then((importedModule)=>{
        if (!BUILD.hotModuleReplacement) {
            cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
    }, consoleError);
};
var styles = /* @__PURE__ */ new Map();
var modeResolutionChain = [];
var win = typeof window !== "undefined" ? window : {};
var CSS = BUILD.cssVarShim ? win.CSS : null;
var doc = win.document || {
    head: {}
};
var H = win.HTMLElement || class {
};
var plt = {
    $flags$: 0,
    $resourcesUrl$: "",
    jmp: (h2)=>h2(),
    raf: (h2)=>requestAnimationFrame(h2),
    ael: (el, eventName, listener, opts)=>el.addEventListener(eventName, listener, opts),
    rel: (el, eventName, listener, opts)=>el.removeEventListener(eventName, listener, opts),
    ce: (eventName, opts)=>new CustomEvent(eventName, opts)
};
var supportsShadow = BUILD.shadowDomShim && BUILD.shadowDom ? (()=>(doc.head.attachShadow + "").indexOf("[native") > -1)() : true;
var supportsListenerOptions = (()=>{
    let supportsListenerOptions2 = false;
    try {
        doc.addEventListener("e", null, Object.defineProperty({}, "passive", {
            get () {
                supportsListenerOptions2 = true;
            }
        }));
    } catch (e) {}
    return supportsListenerOptions2;
})();
var promiseResolve = (v)=>Promise.resolve(v);
var supportsConstructableStylesheets = BUILD.constructableCSS ? (()=>{
    try {
        new CSSStyleSheet();
        return typeof new CSSStyleSheet().replaceSync === "function";
    } catch (e) {}
    return false;
})() : false;
var queueDomReads = [];
var queueDomWrites = [];
var queueDomWritesLow = [];
var queueTask = (queue, write)=>(cb)=>{
        queue.push(cb);
        if (!queuePending) {
            queuePending = true;
            if (write && plt.$flags$ & 4) {
                nextTick2(flush);
            } else {
                plt.raf(flush);
            }
        }
    };
var consume = (queue)=>{
    for(let i2 = 0; i2 < queue.length; i2++){
        try {
            queue[i2](performance.now());
        } catch (e) {
            consoleError(e);
        }
    }
    queue.length = 0;
};
var consumeTimeout = (queue, timeout)=>{
    let i2 = 0;
    let ts = 0;
    while(i2 < queue.length && (ts = performance.now()) < timeout){
        try {
            queue[i2++](ts);
        } catch (e) {
            consoleError(e);
        }
    }
    if (i2 === queue.length) {
        queue.length = 0;
    } else if (i2 !== 0) {
        queue.splice(0, i2);
    }
};
var flush = ()=>{
    if (BUILD.asyncQueue) {
        queueCongestion++;
    }
    consume(queueDomReads);
    if (BUILD.asyncQueue) {
        const timeout = (plt.$flags$ & 6) === 2 ? performance.now() + 14 * Math.ceil(queueCongestion * (1 / 10)) : Infinity;
        consumeTimeout(queueDomWrites, timeout);
        consumeTimeout(queueDomWritesLow, timeout);
        if (queueDomWrites.length > 0) {
            queueDomWritesLow.push(...queueDomWrites);
            queueDomWrites.length = 0;
        }
        if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {
            plt.raf(flush);
        } else {
            queueCongestion = 0;
        }
    } else {
        consume(queueDomWrites);
        if (queuePending = queueDomReads.length > 0) {
            plt.raf(flush);
        }
    }
};
var nextTick2 = (cb)=>promiseResolve().then(cb);
var readTask = queueTask(queueDomReads, false);
var writeTask = queueTask(queueDomWrites, true);
// node_modules/@tarojs/components/dist/components/index2.js
function createCommonjsModule(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire();
        }
    }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var classnames = createCommonjsModule(function(module) {
    (function() {
        var hasOwn = {}.hasOwnProperty;
        function classNames() {
            var classes2 = [];
            for(var i2 = 0; i2 < arguments.length; i2++){
                var arg = arguments[i2];
                if (!arg) continue;
                var argType = typeof arg;
                if (argType === "string" || argType === "number") {
                    classes2.push(arg);
                } else if (Array.isArray(arg)) {
                    if (arg.length) {
                        var inner = classNames.apply(null, arg);
                        if (inner) {
                            classes2.push(inner);
                        }
                    }
                } else if (argType === "object") {
                    if (arg.toString === Object.prototype.toString) {
                        for(var key in arg){
                            if (hasOwn.call(arg, key) && arg[key]) {
                                classes2.push(key);
                            }
                        }
                    } else {
                        classes2.push(arg.toString());
                    }
                }
            }
            return classes2.join(" ");
        }
        if (module.exports) {
            classNames.default = classNames;
            module.exports = classNames;
        } else {
            window.classNames = classNames;
        }
    })();
});
// node_modules/@tarojs/components/dist/components/index3.js
function debounce2(fn, ms = 250, scope) {
    let timer2;
    return function(...args) {
        const context = scope || this;
        clearTimeout(timer2);
        timer2 = setTimeout(function() {
            fn.apply(context, args);
        }, ms);
    };
}
// node_modules/@tarojs/components/dist/components/taro-swiper-core.js
function isObject$1(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend$1(target, src) {
    if (target === void 0) {
        target = {};
    }
    if (src === void 0) {
        src = {};
    }
    Object.keys(src).forEach(function(key) {
        if (typeof target[key] === "undefined") target[key] = src[key];
        else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
            extend$1(target[key], src[key]);
        }
    });
}
var ssrDocument = {
    body: {},
    addEventListener: function() {},
    removeEventListener: function() {},
    activeElement: {
        blur: function() {},
        nodeName: ""
    },
    querySelector: function() {
        return null;
    },
    querySelectorAll: function() {
        return [];
    },
    getElementById: function() {
        return null;
    },
    createEvent: function() {
        return {
            initEvent: function() {}
        };
    },
    createElement: function() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function() {},
            getElementsByTagName: function() {
                return [];
            }
        };
    },
    createElementNS: function() {
        return {};
    },
    importNode: function() {
        return null;
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function getDocument() {
    var doc3 = typeof document !== "undefined" ? document : {};
    extend$1(doc3, ssrDocument);
    return doc3;
}
var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState: function() {},
        pushState: function() {},
        go: function() {},
        back: function() {}
    },
    CustomEvent: function CustomEvent2() {
        return this;
    },
    addEventListener: function() {},
    removeEventListener: function() {},
    getComputedStyle: function() {
        return {
            getPropertyValue: function() {
                return "";
            }
        };
    },
    Image: function() {},
    Date: function() {},
    screen: {},
    setTimeout: function() {},
    clearTimeout: function() {},
    matchMedia: function() {
        return {};
    },
    requestAnimationFrame: function(callback) {
        if (typeof setTimeout === "undefined") {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame: function(id) {
        if (typeof setTimeout === "undefined") {
            return;
        }
        clearTimeout(id);
    }
};
function getWindow() {
    var win3 = typeof window !== "undefined" ? window : {};
    extend$1(win3, ssrWindow);
    return win3;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
    };
    return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function _construct2(Parent2, args2, Class2) {
            var a = [
                null
            ];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2) _setPrototypeOf(instance, Class2.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class2)) return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self2) {
    if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
}
function makeReactive(obj) {
    var proto = obj.__proto__;
    Object.defineProperty(obj, "__proto__", {
        get: function get2() {
            return proto;
        },
        set: function set2(value) {
            proto.__proto__ = value;
        }
    });
}
var Dom7 = function(_Array) {
    _inheritsLoose(Dom72, _Array);
    function Dom72(items) {
        var _this;
        _this = _Array.call.apply(_Array, [
            this
        ].concat(items)) || this;
        makeReactive(_assertThisInitialized(_this));
        return _this;
    }
    return Dom72;
}(_wrapNativeSuper(Array));
function arrayFlat(arr) {
    if (arr === void 0) {
        arr = [];
    }
    var res = [];
    arr.forEach(function(el) {
        if (Array.isArray(el)) {
            res.push.apply(res, arrayFlat(el));
        } else {
            res.push(el);
        }
    });
    return res;
}
function arrayFilter(arr, callback) {
    return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
    var uniqueArray = [];
    for(var i2 = 0; i2 < arr.length; i2 += 1){
        if (uniqueArray.indexOf(arr[i2]) === -1) uniqueArray.push(arr[i2]);
    }
    return uniqueArray;
}
function qsa(selector, context) {
    if (typeof selector !== "string") {
        return [
            selector
        ];
    }
    var a = [];
    var res = context.querySelectorAll(selector);
    for(var i2 = 0; i2 < res.length; i2 += 1){
        a.push(res[i2]);
    }
    return a;
}
function $(selector, context) {
    var window2 = getWindow();
    var document2 = getDocument();
    var arr = [];
    if (!context && selector instanceof Dom7) {
        return selector;
    }
    if (!selector) {
        return new Dom7(arr);
    }
    if (typeof selector === "string") {
        var html2 = selector.trim();
        if (html2.indexOf("<") >= 0 && html2.indexOf(">") >= 0) {
            var toCreate = "div";
            if (html2.indexOf("<li") === 0) toCreate = "ul";
            if (html2.indexOf("<tr") === 0) toCreate = "tbody";
            if (html2.indexOf("<td") === 0 || html2.indexOf("<th") === 0) toCreate = "tr";
            if (html2.indexOf("<tbody") === 0) toCreate = "table";
            if (html2.indexOf("<option") === 0) toCreate = "select";
            var tempParent = document2.createElement(toCreate);
            tempParent.innerHTML = html2;
            for(var i2 = 0; i2 < tempParent.childNodes.length; i2 += 1){
                arr.push(tempParent.childNodes[i2]);
            }
        } else {
            arr = qsa(selector.trim(), context || document2);
        }
    } else if (selector.nodeType || selector === window2 || selector === document2) {
        arr.push(selector);
    } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
    }
    return new Dom7(arrayUnique(arr));
}
$.fn = Dom7.prototype;
function addClass() {
    for(var _len = arguments.length, classes2 = new Array(_len), _key = 0; _key < _len; _key++){
        classes2[_key] = arguments[_key];
    }
    var classNames = arrayFlat(classes2.map(function(c) {
        return c.split(" ");
    }));
    this.forEach(function(el) {
        var _el$classList;
        (_el$classList = el.classList).add.apply(_el$classList, classNames);
    });
    return this;
}
function removeClass() {
    for(var _len2 = arguments.length, classes2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
        classes2[_key2] = arguments[_key2];
    }
    var classNames = arrayFlat(classes2.map(function(c) {
        return c.split(" ");
    }));
    this.forEach(function(el) {
        var _el$classList2;
        (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
    });
    return this;
}
function toggleClass() {
    for(var _len3 = arguments.length, classes2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){
        classes2[_key3] = arguments[_key3];
    }
    var classNames = arrayFlat(classes2.map(function(c) {
        return c.split(" ");
    }));
    this.forEach(function(el) {
        classNames.forEach(function(className) {
            el.classList.toggle(className);
        });
    });
}
function hasClass() {
    for(var _len4 = arguments.length, classes2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){
        classes2[_key4] = arguments[_key4];
    }
    var classNames = arrayFlat(classes2.map(function(c) {
        return c.split(" ");
    }));
    return arrayFilter(this, function(el) {
        return classNames.filter(function(className) {
            return el.classList.contains(className);
        }).length > 0;
    }).length > 0;
}
function attr(attrs, value) {
    if (arguments.length === 1 && typeof attrs === "string") {
        if (this[0]) return this[0].getAttribute(attrs);
        return void 0;
    }
    for(var i2 = 0; i2 < this.length; i2 += 1){
        if (arguments.length === 2) {
            this[i2].setAttribute(attrs, value);
        } else {
            for(var attrName in attrs){
                this[i2][attrName] = attrs[attrName];
                this[i2].setAttribute(attrName, attrs[attrName]);
            }
        }
    }
    return this;
}
function removeAttr(attr2) {
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].removeAttribute(attr2);
    }
    return this;
}
function transform(transform2) {
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].style.transform = transform2;
    }
    return this;
}
function transition$1(duration) {
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].style.transitionDuration = typeof duration !== "string" ? duration + "ms" : duration;
    }
    return this;
}
function on() {
    for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){
        args[_key5] = arguments[_key5];
    }
    var eventType = args[0], targetSelector = args[1], listener = args[2], capture = args[3];
    if (typeof args[1] === "function") {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = void 0;
    }
    if (!capture) capture = false;
    function handleLiveEvent(e) {
        var target = e.target;
        if (!target) return;
        var eventData = e.target.dom7EventData || [];
        if (eventData.indexOf(e) < 0) {
            eventData.unshift(e);
        }
        if ($(target).is(targetSelector)) listener.apply(target, eventData);
        else {
            var _parents = $(target).parents();
            for(var k = 0; k < _parents.length; k += 1){
                if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
            }
        }
    }
    function handleEvent(e) {
        var eventData = e && e.target ? e.target.dom7EventData || [] : [];
        if (eventData.indexOf(e) < 0) {
            eventData.unshift(e);
        }
        listener.apply(this, eventData);
    }
    var events2 = eventType.split(" ");
    var j;
    for(var i2 = 0; i2 < this.length; i2 += 1){
        var el = this[i2];
        if (!targetSelector) {
            for(j = 0; j < events2.length; j += 1){
                var event2 = events2[j];
                if (!el.dom7Listeners) el.dom7Listeners = {};
                if (!el.dom7Listeners[event2]) el.dom7Listeners[event2] = [];
                el.dom7Listeners[event2].push({
                    listener,
                    proxyListener: handleEvent
                });
                el.addEventListener(event2, handleEvent, capture);
            }
        } else {
            for(j = 0; j < events2.length; j += 1){
                var _event = events2[j];
                if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
                if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];
                el.dom7LiveListeners[_event].push({
                    listener,
                    proxyListener: handleLiveEvent
                });
                el.addEventListener(_event, handleLiveEvent, capture);
            }
        }
    }
    return this;
}
function off() {
    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
        args[_key6] = arguments[_key6];
    }
    var eventType = args[0], targetSelector = args[1], listener = args[2], capture = args[3];
    if (typeof args[1] === "function") {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = void 0;
    }
    if (!capture) capture = false;
    var events2 = eventType.split(" ");
    for(var i2 = 0; i2 < events2.length; i2 += 1){
        var event2 = events2[i2];
        for(var j = 0; j < this.length; j += 1){
            var el = this[j];
            var handlers = void 0;
            if (!targetSelector && el.dom7Listeners) {
                handlers = el.dom7Listeners[event2];
            } else if (targetSelector && el.dom7LiveListeners) {
                handlers = el.dom7LiveListeners[event2];
            }
            if (handlers && handlers.length) {
                for(var k = handlers.length - 1; k >= 0; k -= 1){
                    var handler = handlers[k];
                    if (listener && handler.listener === listener) {
                        el.removeEventListener(event2, handler.proxyListener, capture);
                        handlers.splice(k, 1);
                    } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                        el.removeEventListener(event2, handler.proxyListener, capture);
                        handlers.splice(k, 1);
                    } else if (!listener) {
                        el.removeEventListener(event2, handler.proxyListener, capture);
                        handlers.splice(k, 1);
                    }
                }
            }
        }
    }
    return this;
}
function trigger() {
    var window2 = getWindow();
    for(var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++){
        args[_key9] = arguments[_key9];
    }
    var events2 = args[0].split(" ");
    var eventData = args[1];
    for(var i2 = 0; i2 < events2.length; i2 += 1){
        var event2 = events2[i2];
        for(var j = 0; j < this.length; j += 1){
            var el = this[j];
            if (window2.CustomEvent) {
                var evt = new window2.CustomEvent(event2, {
                    detail: eventData,
                    bubbles: true,
                    cancelable: true
                });
                el.dom7EventData = args.filter(function(data, dataIndex) {
                    return dataIndex > 0;
                });
                el.dispatchEvent(evt);
                el.dom7EventData = [];
                delete el.dom7EventData;
            }
        }
    }
    return this;
}
function transitionEnd$1(callback) {
    var dom = this;
    function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off("transitionend", fireCallBack);
    }
    if (callback) {
        dom.on("transitionend", fireCallBack);
    }
    return this;
}
function outerWidth(includeMargins) {
    if (this.length > 0) {
        if (includeMargins) {
            var _styles = this.styles();
            return this[0].offsetWidth + parseFloat(_styles.getPropertyValue("margin-right")) + parseFloat(_styles.getPropertyValue("margin-left"));
        }
        return this[0].offsetWidth;
    }
    return null;
}
function outerHeight(includeMargins) {
    if (this.length > 0) {
        if (includeMargins) {
            var _styles2 = this.styles();
            return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue("margin-top")) + parseFloat(_styles2.getPropertyValue("margin-bottom"));
        }
        return this[0].offsetHeight;
    }
    return null;
}
function offset() {
    if (this.length > 0) {
        var window2 = getWindow();
        var document2 = getDocument();
        var el = this[0];
        var box = el.getBoundingClientRect();
        var body = document2.body;
        var clientTop = el.clientTop || body.clientTop || 0;
        var clientLeft = el.clientLeft || body.clientLeft || 0;
        var scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
        var scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
        return {
            top: box.top + scrollTop - clientTop,
            left: box.left + scrollLeft - clientLeft
        };
    }
    return null;
}
function styles2() {
    var window2 = getWindow();
    if (this[0]) return window2.getComputedStyle(this[0], null);
    return {};
}
function css(props, value) {
    var window2 = getWindow();
    var i2;
    if (arguments.length === 1) {
        if (typeof props === "string") {
            if (this[0]) return window2.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
            for(i2 = 0; i2 < this.length; i2 += 1){
                for(var _prop in props){
                    this[i2].style[_prop] = props[_prop];
                }
            }
            return this;
        }
    }
    if (arguments.length === 2 && typeof props === "string") {
        for(i2 = 0; i2 < this.length; i2 += 1){
            this[i2].style[props] = value;
        }
        return this;
    }
    return this;
}
function each(callback) {
    if (!callback) return this;
    this.forEach(function(el, index2) {
        callback.apply(el, [
            el,
            index2
        ]);
    });
    return this;
}
function filter(callback) {
    var result = arrayFilter(this, callback);
    return $(result);
}
function html(html2) {
    if (typeof html2 === "undefined") {
        return this[0] ? this[0].innerHTML : null;
    }
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].innerHTML = html2;
    }
    return this;
}
function text(text2) {
    if (typeof text2 === "undefined") {
        return this[0] ? this[0].textContent.trim() : null;
    }
    for(var i2 = 0; i2 < this.length; i2 += 1){
        this[i2].textContent = text2;
    }
    return this;
}
function is(selector) {
    var window2 = getWindow();
    var document2 = getDocument();
    var el = this[0];
    var compareWith;
    var i2;
    if (!el || typeof selector === "undefined") return false;
    if (typeof selector === "string") {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);
        for(i2 = 0; i2 < compareWith.length; i2 += 1){
            if (compareWith[i2] === el) return true;
        }
        return false;
    }
    if (selector === document2) {
        return el === document2;
    }
    if (selector === window2) {
        return el === window2;
    }
    if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [
            selector
        ] : selector;
        for(i2 = 0; i2 < compareWith.length; i2 += 1){
            if (compareWith[i2] === el) return true;
        }
        return false;
    }
    return false;
}
function index() {
    var child = this[0];
    var i2;
    if (child) {
        i2 = 0;
        while((child = child.previousSibling) !== null){
            if (child.nodeType === 1) i2 += 1;
        }
        return i2;
    }
    return void 0;
}
function eq(index2) {
    if (typeof index2 === "undefined") return this;
    var length = this.length;
    if (index2 > length - 1) {
        return $([]);
    }
    if (index2 < 0) {
        var returnIndex = length + index2;
        if (returnIndex < 0) return $([]);
        return $([
            this[returnIndex]
        ]);
    }
    return $([
        this[index2]
    ]);
}
function append() {
    var newChild;
    var document2 = getDocument();
    for(var k = 0; k < arguments.length; k += 1){
        newChild = k < 0 || arguments.length <= k ? void 0 : arguments[k];
        for(var i2 = 0; i2 < this.length; i2 += 1){
            if (typeof newChild === "string") {
                var tempDiv = document2.createElement("div");
                tempDiv.innerHTML = newChild;
                while(tempDiv.firstChild){
                    this[i2].appendChild(tempDiv.firstChild);
                }
            } else if (newChild instanceof Dom7) {
                for(var j = 0; j < newChild.length; j += 1){
                    this[i2].appendChild(newChild[j]);
                }
            } else {
                this[i2].appendChild(newChild);
            }
        }
    }
    return this;
}
function prepend(newChild) {
    var document2 = getDocument();
    var i2;
    var j;
    for(i2 = 0; i2 < this.length; i2 += 1){
        if (typeof newChild === "string") {
            var tempDiv = document2.createElement("div");
            tempDiv.innerHTML = newChild;
            for(j = tempDiv.childNodes.length - 1; j >= 0; j -= 1){
                this[i2].insertBefore(tempDiv.childNodes[j], this[i2].childNodes[0]);
            }
        } else if (newChild instanceof Dom7) {
            for(j = 0; j < newChild.length; j += 1){
                this[i2].insertBefore(newChild[j], this[i2].childNodes[0]);
            }
        } else {
            this[i2].insertBefore(newChild, this[i2].childNodes[0]);
        }
    }
    return this;
}
function next(selector) {
    if (this.length > 0) {
        if (selector) {
            if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                return $([
                    this[0].nextElementSibling
                ]);
            }
            return $([]);
        }
        if (this[0].nextElementSibling) return $([
            this[0].nextElementSibling
        ]);
        return $([]);
    }
    return $([]);
}
function nextAll(selector) {
    var nextEls = [];
    var el = this[0];
    if (!el) return $([]);
    while(el.nextElementSibling){
        var _next = el.nextElementSibling;
        if (selector) {
            if ($(_next).is(selector)) nextEls.push(_next);
        } else nextEls.push(_next);
        el = _next;
    }
    return $(nextEls);
}
function prev(selector) {
    if (this.length > 0) {
        var el = this[0];
        if (selector) {
            if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
                return $([
                    el.previousElementSibling
                ]);
            }
            return $([]);
        }
        if (el.previousElementSibling) return $([
            el.previousElementSibling
        ]);
        return $([]);
    }
    return $([]);
}
function prevAll(selector) {
    var prevEls = [];
    var el = this[0];
    if (!el) return $([]);
    while(el.previousElementSibling){
        var _prev = el.previousElementSibling;
        if (selector) {
            if ($(_prev).is(selector)) prevEls.push(_prev);
        } else prevEls.push(_prev);
        el = _prev;
    }
    return $(prevEls);
}
function parent(selector) {
    var parents2 = [];
    for(var i2 = 0; i2 < this.length; i2 += 1){
        if (this[i2].parentNode !== null) {
            if (selector) {
                if ($(this[i2].parentNode).is(selector)) parents2.push(this[i2].parentNode);
            } else {
                parents2.push(this[i2].parentNode);
            }
        }
    }
    return $(parents2);
}
function parents(selector) {
    var parents2 = [];
    for(var i2 = 0; i2 < this.length; i2 += 1){
        var _parent = this[i2].parentNode;
        while(_parent){
            if (selector) {
                if ($(_parent).is(selector)) parents2.push(_parent);
            } else {
                parents2.push(_parent);
            }
            _parent = _parent.parentNode;
        }
    }
    return $(parents2);
}
function closest(selector) {
    var closest2 = this;
    if (typeof selector === "undefined") {
        return $([]);
    }
    if (!closest2.is(selector)) {
        closest2 = closest2.parents(selector).eq(0);
    }
    return closest2;
}
function find(selector) {
    var foundElements = [];
    for(var i2 = 0; i2 < this.length; i2 += 1){
        var found = this[i2].querySelectorAll(selector);
        for(var j = 0; j < found.length; j += 1){
            foundElements.push(found[j]);
        }
    }
    return $(foundElements);
}
function children(selector) {
    var children2 = [];
    for(var i2 = 0; i2 < this.length; i2 += 1){
        var childNodes = this[i2].children;
        for(var j = 0; j < childNodes.length; j += 1){
            if (!selector || $(childNodes[j]).is(selector)) {
                children2.push(childNodes[j]);
            }
        }
    }
    return $(children2);
}
function remove() {
    for(var i2 = 0; i2 < this.length; i2 += 1){
        if (this[i2].parentNode) this[i2].parentNode.removeChild(this[i2]);
    }
    return this;
}
var Methods = {
    addClass,
    removeClass,
    hasClass,
    toggleClass,
    attr,
    removeAttr,
    transform,
    transition: transition$1,
    on,
    off,
    trigger,
    transitionEnd: transitionEnd$1,
    outerWidth,
    outerHeight,
    styles: styles2,
    offset,
    css,
    each,
    html,
    text,
    is,
    index,
    eq,
    append,
    prepend,
    next,
    nextAll,
    prev,
    prevAll,
    parent,
    parents,
    closest,
    find,
    children,
    filter,
    remove
};
Object.keys(Methods).forEach(function(methodName) {
    Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
    });
});
function deleteProps(obj) {
    var object = obj;
    Object.keys(object).forEach(function(key) {
        try {
            object[key] = null;
        } catch (e) {}
        try {
            delete object[key];
        } catch (e) {}
    });
}
function nextTick3(callback, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return setTimeout(callback, delay);
}
function now() {
    return Date.now();
}
function getComputedStyle$1(el) {
    var window2 = getWindow();
    var style;
    if (window2.getComputedStyle) {
        style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
        style = el.currentStyle;
    }
    if (!style) {
        style = el.style;
    }
    return style;
}
function getTranslate(el, axis) {
    if (axis === void 0) {
        axis = "x";
    }
    var window2 = getWindow();
    var matrix;
    var curTransform;
    var transformMatrix;
    var curStyle = getComputedStyle$1(el);
    if (window2.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(",").length > 6) {
            curTransform = curTransform.split(", ").map(function(a) {
                return a.replace(",", ".");
            }).join(", ");
        }
        transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
        matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
        if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
        else curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
        if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
        else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
}
function isObject2(o) {
    return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
}
function isNode(node) {
    if (typeof window !== "undefined") {
        return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend() {
    var to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
    var noExtend = [
        "__proto__",
        "constructor",
        "prototype"
    ];
    for(var i2 = 1; i2 < arguments.length; i2 += 1){
        var nextSource = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
        if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
            var keysArray = Object.keys(Object(nextSource)).filter(function(key) {
                return noExtend.indexOf(key) < 0;
            });
            for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){
                var nextKey = keysArray[nextIndex];
                var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                if (desc !== void 0 && desc.enumerable) {
                    if (isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
                        if (nextSource[nextKey].__swiper__) {
                            to[nextKey] = nextSource[nextKey];
                        } else {
                            extend(to[nextKey], nextSource[nextKey]);
                        }
                    } else if (!isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
                        to[nextKey] = {};
                        if (nextSource[nextKey].__swiper__) {
                            to[nextKey] = nextSource[nextKey];
                        } else {
                            extend(to[nextKey], nextSource[nextKey]);
                        }
                    } else {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
    }
    return to;
}
function bindModuleMethods(instance, obj) {
    Object.keys(obj).forEach(function(key) {
        if (isObject2(obj[key])) {
            Object.keys(obj[key]).forEach(function(subKey) {
                if (typeof obj[key][subKey] === "function") {
                    obj[key][subKey] = obj[key][subKey].bind(instance);
                }
            });
        }
        instance[key] = obj[key];
    });
}
function classesToSelector(classes2) {
    if (classes2 === void 0) {
        classes2 = "";
    }
    return "." + classes2.trim().replace(/([\.:\/])/g, "\\$1").replace(/ /g, ".");
}
function createElementIfNotDefined($container, params, createElements, checkProps) {
    var document2 = getDocument();
    if (createElements) {
        Object.keys(checkProps).forEach(function(key) {
            if (!params[key] && params.auto === true) {
                var element = document2.createElement("div");
                element.className = checkProps[key];
                $container.append(element);
                params[key] = element;
            }
        });
    }
    return params;
}
var support;
function calcSupport() {
    var window2 = getWindow();
    var document2 = getDocument();
    return {
        touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
        pointerEvents: !!window2.PointerEvent && "maxTouchPoints" in window2.navigator && window2.navigator.maxTouchPoints >= 0,
        observer: function checkObserver() {
            return "MutationObserver" in window2 || "WebkitMutationObserver" in window2;
        }(),
        passiveListener: function checkPassiveListener() {
            var supportsPassive = false;
            try {
                var opts = Object.defineProperty({}, "passive", {
                    get: function get2() {
                        supportsPassive = true;
                    }
                });
                window2.addEventListener("testPassiveListener", null, opts);
            } catch (e) {}
            return supportsPassive;
        }(),
        gestures: function checkGestures() {
            return "ongesturestart" in window2;
        }()
    };
}
function getSupport() {
    if (!support) {
        support = calcSupport();
    }
    return support;
}
var device;
function calcDevice(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, userAgent = _ref.userAgent;
    var support3 = getSupport();
    var window2 = getWindow();
    var platform = window2.navigator.platform;
    var ua = userAgent || window2.navigator.userAgent;
    var device2 = {
        ios: false,
        android: false
    };
    var screenWidth = window2.screen.width;
    var screenHeight = window2.screen.height;
    var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    var windows = platform === "Win32";
    var macos = platform === "MacIntel";
    var iPadScreens = [
        "1024x1366",
        "1366x1024",
        "834x1194",
        "1194x834",
        "834x1112",
        "1112x834",
        "768x1024",
        "1024x768",
        "820x1180",
        "1180x820",
        "810x1080",
        "1080x810"
    ];
    if (!ipad && macos && support3.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [
            0,
            1,
            "13_0_0"
        ];
        macos = false;
    }
    if (android && !windows) {
        device2.os = "android";
        device2.android = true;
    }
    if (ipad || iphone || ipod) {
        device2.os = "ios";
        device2.ios = true;
    }
    return device2;
}
function getDevice(overrides) {
    if (overrides === void 0) {
        overrides = {};
    }
    if (!device) {
        device = calcDevice(overrides);
    }
    return device;
}
var browser;
function calcBrowser() {
    var window2 = getWindow();
    function isSafari() {
        var ua = window2.navigator.userAgent.toLowerCase();
        return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    return {
        isEdge: !!window2.navigator.userAgent.match(/Edge/g),
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
    };
}
function getBrowser() {
    if (!browser) {
        browser = calcBrowser();
    }
    return browser;
}
var supportsResizeObserver = function supportsResizeObserver2() {
    var window2 = getWindow();
    return typeof window2.ResizeObserver !== "undefined";
};
var Resize = {
    name: "resize",
    create: function create() {
        var swiper = this;
        extend(swiper, {
            resize: {
                observer: null,
                createObserver: function createObserver() {
                    if (!swiper || swiper.destroyed || !swiper.initialized) return;
                    swiper.resize.observer = new ResizeObserver(function(entries) {
                        var width = swiper.width, height = swiper.height;
                        var newWidth = width;
                        var newHeight = height;
                        entries.forEach(function(_ref) {
                            var contentBoxSize = _ref.contentBoxSize, contentRect = _ref.contentRect, target = _ref.target;
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        });
                        if (newWidth !== width || newHeight !== height) {
                            swiper.resize.resizeHandler();
                        }
                    });
                    swiper.resize.observer.observe(swiper.el);
                },
                removeObserver: function removeObserver() {
                    if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
                        swiper.resize.observer.unobserve(swiper.el);
                        swiper.resize.observer = null;
                    }
                },
                resizeHandler: function resizeHandler() {
                    if (!swiper || swiper.destroyed || !swiper.initialized) return;
                    swiper.emit("beforeResize");
                    swiper.emit("resize");
                },
                orientationChangeHandler: function orientationChangeHandler() {
                    if (!swiper || swiper.destroyed || !swiper.initialized) return;
                    swiper.emit("orientationchange");
                }
            }
        });
    },
    on: {
        init: function init(swiper) {
            var window2 = getWindow();
            if (swiper.params.resizeObserver && supportsResizeObserver()) {
                swiper.resize.createObserver();
                return;
            }
            window2.addEventListener("resize", swiper.resize.resizeHandler);
            window2.addEventListener("orientationchange", swiper.resize.orientationChangeHandler);
        },
        destroy: function destroy(swiper) {
            var window2 = getWindow();
            swiper.resize.removeObserver();
            window2.removeEventListener("resize", swiper.resize.resizeHandler);
            window2.removeEventListener("orientationchange", swiper.resize.orientationChangeHandler);
        }
    }
};
function _extends$i() {
    _extends$i = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$i.apply(this, arguments);
}
var Observer = {
    attach: function attach(target, options3) {
        if (options3 === void 0) {
            options3 = {};
        }
        var window2 = getWindow();
        var swiper = this;
        var ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
        var observer = new ObserverFunc(function(mutations) {
            if (mutations.length === 1) {
                swiper.emit("observerUpdate", mutations[0]);
                return;
            }
            var observerUpdate4 = function observerUpdate5() {
                swiper.emit("observerUpdate", mutations[0]);
            };
            if (window2.requestAnimationFrame) {
                window2.requestAnimationFrame(observerUpdate4);
            } else {
                window2.setTimeout(observerUpdate4, 0);
            }
        });
        observer.observe(target, {
            attributes: typeof options3.attributes === "undefined" ? true : options3.attributes,
            childList: typeof options3.childList === "undefined" ? true : options3.childList,
            characterData: typeof options3.characterData === "undefined" ? true : options3.characterData
        });
        swiper.observer.observers.push(observer);
    },
    init: function init2() {
        var swiper = this;
        if (!swiper.support.observer || !swiper.params.observer) return;
        if (swiper.params.observeParents) {
            var containerParents = swiper.$el.parents();
            for(var i2 = 0; i2 < containerParents.length; i2 += 1){
                swiper.observer.attach(containerParents[i2]);
            }
        }
        swiper.observer.attach(swiper.$el[0], {
            childList: swiper.params.observeSlideChildren
        });
        swiper.observer.attach(swiper.$wrapperEl[0], {
            attributes: false
        });
    },
    destroy: function destroy2() {
        var swiper = this;
        swiper.observer.observers.forEach(function(observer) {
            observer.disconnect();
        });
        swiper.observer.observers = [];
    }
};
var Observer$1 = {
    name: "observer",
    params: {
        observer: false,
        observeParents: false,
        observeSlideChildren: false
    },
    create: function create2() {
        var swiper = this;
        bindModuleMethods(swiper, {
            observer: _extends$i({}, Observer, {
                observers: []
            })
        });
    },
    on: {
        init: function init3(swiper) {
            swiper.observer.init();
        },
        destroy: function destroy3(swiper) {
            swiper.observer.destroy();
        }
    }
};
var modular = {
    useParams: function useParams(instanceParams) {
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function(moduleName) {
            var module = instance.modules[moduleName];
            if (module.params) {
                extend(instanceParams, module.params);
            }
        });
    },
    useModules: function useModules(modulesParams) {
        if (modulesParams === void 0) {
            modulesParams = {};
        }
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function(moduleName) {
            var module = instance.modules[moduleName];
            var moduleParams = modulesParams[moduleName] || {};
            if (module.on && instance.on) {
                Object.keys(module.on).forEach(function(moduleEventName) {
                    instance.on(moduleEventName, module.on[moduleEventName]);
                });
            }
            if (module.create) {
                module.create.bind(instance)(moduleParams);
            }
        });
    }
};
var eventsEmitter = {
    on: function on2(events2, handler, priority) {
        var self2 = this;
        if (typeof handler !== "function") return self2;
        var method = priority ? "unshift" : "push";
        events2.split(" ").forEach(function(event2) {
            if (!self2.eventsListeners[event2]) self2.eventsListeners[event2] = [];
            self2.eventsListeners[event2][method](handler);
        });
        return self2;
    },
    once: function once(events2, handler, priority) {
        var self2 = this;
        if (typeof handler !== "function") return self2;
        function onceHandler() {
            self2.off(events2, onceHandler);
            if (onceHandler.__emitterProxy) {
                delete onceHandler.__emitterProxy;
            }
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            handler.apply(self2, args);
        }
        onceHandler.__emitterProxy = handler;
        return self2.on(events2, onceHandler, priority);
    },
    onAny: function onAny(handler, priority) {
        var self2 = this;
        if (typeof handler !== "function") return self2;
        var method = priority ? "unshift" : "push";
        if (self2.eventsAnyListeners.indexOf(handler) < 0) {
            self2.eventsAnyListeners[method](handler);
        }
        return self2;
    },
    offAny: function offAny(handler) {
        var self2 = this;
        if (!self2.eventsAnyListeners) return self2;
        var index2 = self2.eventsAnyListeners.indexOf(handler);
        if (index2 >= 0) {
            self2.eventsAnyListeners.splice(index2, 1);
        }
        return self2;
    },
    off: function off2(events2, handler) {
        var self2 = this;
        if (!self2.eventsListeners) return self2;
        events2.split(" ").forEach(function(event2) {
            if (typeof handler === "undefined") {
                self2.eventsListeners[event2] = [];
            } else if (self2.eventsListeners[event2]) {
                self2.eventsListeners[event2].forEach(function(eventHandler, index2) {
                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                        self2.eventsListeners[event2].splice(index2, 1);
                    }
                });
            }
        });
        return self2;
    },
    emit: function emit() {
        var self2 = this;
        if (!self2.eventsListeners) return self2;
        var events2;
        var data;
        var context;
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            args[_key2] = arguments[_key2];
        }
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
            events2 = args[0];
            data = args.slice(1, args.length);
            context = self2;
        } else {
            events2 = args[0].events;
            data = args[0].data;
            context = args[0].context || self2;
        }
        data.unshift(context);
        var eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
        eventsArray.forEach(function(event2) {
            if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
                self2.eventsAnyListeners.forEach(function(eventHandler) {
                    eventHandler.apply(context, [
                        event2
                    ].concat(data));
                });
            }
            if (self2.eventsListeners && self2.eventsListeners[event2]) {
                self2.eventsListeners[event2].forEach(function(eventHandler) {
                    eventHandler.apply(context, data);
                });
            }
        });
        return self2;
    }
};
function updateSize() {
    var swiper = this;
    var width;
    var height;
    var $el = swiper.$el;
    if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
        width = swiper.params.width;
    } else {
        width = $el[0].clientWidth;
    }
    if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
        height = swiper.params.height;
    } else {
        height = $el[0].clientHeight;
    }
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
    }
    width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
    height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    extend(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height
    });
}
function updateSlides() {
    var swiper = this;
    function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
            return property;
        }
        return ({
            "width": "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            "marginRight": "marginBottom"
        })[property];
    }
    function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
    }
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl, swiperSize = swiper.size, rtl = swiper.rtlTranslate, wrongRTL = swiper.wrongRTL;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    var slides = $wrapperEl.children("." + swiper.params.slideClass);
    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    var snapGrid = [];
    var slidesGrid = [];
    var slidesSizesGrid = [];
    var offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    var offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    var previousSnapGridLength = swiper.snapGrid.length;
    var previousSlidesGridLength = swiper.slidesGrid.length;
    var spaceBetween = params.spaceBetween;
    var slidePosition = -offsetBefore;
    var prevSlideSize = 0;
    var index2 = 0;
    if (typeof swiperSize === "undefined") {
        return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    }
    swiper.virtualSize = -spaceBetween;
    if (rtl) slides.css({
        marginLeft: "",
        marginTop: ""
    });
    else slides.css({
        marginRight: "",
        marginBottom: ""
    });
    var slidesNumberEvenToRows;
    if (params.slidesPerColumn > 1) {
        if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
            slidesNumberEvenToRows = slidesLength;
        } else {
            slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
        }
        if (params.slidesPerView !== "auto" && params.slidesPerColumnFill === "row") {
            slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
        }
    }
    var slideSize;
    var slidesPerColumn = params.slidesPerColumn;
    var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
    var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
    for(var i2 = 0; i2 < slidesLength; i2 += 1){
        slideSize = 0;
        var slide2 = slides.eq(i2);
        if (params.slidesPerColumn > 1) {
            var newSlideOrderIndex = void 0;
            var column = void 0;
            var row = void 0;
            if (params.slidesPerColumnFill === "row" && params.slidesPerGroup > 1) {
                var groupIndex = Math.floor(i2 / (params.slidesPerGroup * params.slidesPerColumn));
                var slideIndexInGroup = i2 - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
                var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
                row = Math.floor(slideIndexInGroup / columnsInGroup);
                column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
                newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                slide2.css({
                    "-webkit-box-ordinal-group": newSlideOrderIndex,
                    "-moz-box-ordinal-group": newSlideOrderIndex,
                    "-ms-flex-order": newSlideOrderIndex,
                    "-webkit-order": newSlideOrderIndex,
                    order: newSlideOrderIndex
                });
            } else if (params.slidesPerColumnFill === "column") {
                column = Math.floor(i2 / slidesPerColumn);
                row = i2 - column * slidesPerColumn;
                if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
                    row += 1;
                    if (row >= slidesPerColumn) {
                        row = 0;
                        column += 1;
                    }
                }
            } else {
                row = Math.floor(i2 / slidesPerRow);
                column = i2 - row * slidesPerRow;
            }
            slide2.css(getDirectionLabel("margin-top"), row !== 0 ? params.spaceBetween && params.spaceBetween + "px" : "");
        }
        if (slide2.css("display") === "none") continue;
        if (params.slidesPerView === "auto") {
            var slideStyles = getComputedStyle(slide2[0]);
            var currentTransform = slide2[0].style.transform;
            var currentWebKitTransform = slide2[0].style.webkitTransform;
            if (currentTransform) {
                slide2[0].style.transform = "none";
            }
            if (currentWebKitTransform) {
                slide2[0].style.webkitTransform = "none";
            }
            if (params.roundLengths) {
                slideSize = swiper.isHorizontal() ? slide2.outerWidth(true) : slide2.outerHeight(true);
            } else {
                var width = getDirectionPropertyValue(slideStyles, "width");
                var paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                var paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                var marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                var marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                var boxSizing = slideStyles.getPropertyValue("box-sizing");
                if (boxSizing && boxSizing === "border-box") {
                    slideSize = width + marginLeft + marginRight;
                } else {
                    var _slide$ = slide2[0], clientWidth = _slide$.clientWidth, offsetWidth = _slide$.offsetWidth;
                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                }
            }
            if (currentTransform) {
                slide2[0].style.transform = currentTransform;
            }
            if (currentWebKitTransform) {
                slide2[0].style.webkitTransform = currentWebKitTransform;
            }
            if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
            if (params.roundLengths) slideSize = Math.floor(slideSize);
            if (slides[i2]) {
                slides[i2].style[getDirectionLabel("width")] = slideSize + "px";
            }
        }
        if (slides[i2]) {
            slides[i2].swiperSlideSize = slideSize;
        }
        slidesSizesGrid.push(slideSize);
        if (params.centeredSlides) {
            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
            if (prevSlideSize === 0 && i2 !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (i2 === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if (index2 % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
        } else {
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
            slidePosition = slidePosition + slideSize + spaceBetween;
        }
        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index2 += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    var newSlidesGrid;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
        $wrapperEl.css({
            width: swiper.virtualSize + params.spaceBetween + "px"
        });
    }
    if (params.setWrapperSize) {
        var _$wrapperEl$css;
        $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel("width")] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css));
    }
    if (params.slidesPerColumn > 1) {
        var _$wrapperEl$css2;
        swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
        $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel("width")] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css2));
        if (params.centeredSlides) {
            newSlidesGrid = [];
            for(var _i = 0; _i < snapGrid.length; _i += 1){
                var slidesGridItem = snapGrid[_i];
                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
            }
            snapGrid = newSlidesGrid;
        }
    }
    if (!params.centeredSlides) {
        newSlidesGrid = [];
        for(var _i2 = 0; _i2 < snapGrid.length; _i2 += 1){
            var _slidesGridItem = snapGrid[_i2];
            if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);
            if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
                newSlidesGrid.push(_slidesGridItem);
            }
        }
        snapGrid = newSlidesGrid;
        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
            snapGrid.push(swiper.virtualSize - swiperSize);
        }
    }
    if (snapGrid.length === 0) snapGrid = [
        0
    ];
    if (params.spaceBetween !== 0) {
        var _slides$filter$css;
        var key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
        slides.filter(function(_, slideIndex) {
            if (!params.cssMode) return true;
            if (slideIndex === slides.length - 1) {
                return false;
            }
            return true;
        }).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + "px", _slides$filter$css));
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
        var allSlidesSize = 0;
        slidesSizesGrid.forEach(function(slideSizeValue) {
            allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        var maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(function(snap) {
            if (snap < 0) return -offsetBefore;
            if (snap > maxSnap) return maxSnap + offsetAfter;
            return snap;
        });
    }
    if (params.centerInsufficientSlides) {
        var _allSlidesSize = 0;
        slidesSizesGrid.forEach(function(slideSizeValue) {
            _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        _allSlidesSize -= params.spaceBetween;
        if (_allSlidesSize < swiperSize) {
            var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
            snapGrid.forEach(function(snap, snapIndex) {
                snapGrid[snapIndex] = snap - allSlidesOffset;
            });
            slidesGrid.forEach(function(snap, snapIndex) {
                slidesGrid[snapIndex] = snap + allSlidesOffset;
            });
        }
    }
    extend(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
    });
    if (slidesLength !== previousSlidesLength) {
        swiper.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateSlidesOffset();
    }
}
function updateAutoHeight(speed) {
    var swiper = this;
    var activeSlides = [];
    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    var newHeight = 0;
    var i2;
    if (typeof speed === "number") {
        swiper.setTransition(speed);
    } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
    }
    var getSlideByIndex = function getSlideByIndex2(index3) {
        if (isVirtual) {
            return swiper.slides.filter(function(el) {
                return parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index3;
            })[0];
        }
        return swiper.slides.eq(index3)[0];
    };
    if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
            swiper.visibleSlides.each(function(slide2) {
                activeSlides.push(slide2);
            });
        } else {
            for(i2 = 0; i2 < Math.ceil(swiper.params.slidesPerView); i2 += 1){
                var index2 = swiper.activeIndex + i2;
                if (index2 > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index2));
            }
        }
    } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }
    for(i2 = 0; i2 < activeSlides.length; i2 += 1){
        if (typeof activeSlides[i2] !== "undefined") {
            var height = activeSlides[i2].offsetHeight;
            newHeight = height > newHeight ? height : newHeight;
        }
    }
    if (newHeight) swiper.$wrapperEl.css("height", newHeight + "px");
}
function updateSlidesOffset() {
    var swiper = this;
    var slides = swiper.slides;
    for(var i2 = 0; i2 < slides.length; i2 += 1){
        slides[i2].swiperSlideOffset = swiper.isHorizontal() ? slides[i2].offsetLeft : slides[i2].offsetTop;
    }
}
function updateSlidesProgress(translate2) {
    if (translate2 === void 0) {
        translate2 = this && this.translate || 0;
    }
    var swiper = this;
    var params = swiper.params;
    var slides = swiper.slides, rtl = swiper.rtlTranslate;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
    var offsetCenter = -translate2;
    if (rtl) offsetCenter = translate2;
    slides.removeClass(params.slideVisibleClass);
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    for(var i2 = 0; i2 < slides.length; i2 += 1){
        var slide2 = slides[i2];
        var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide2.swiperSlideOffset) / (slide2.swiperSlideSize + params.spaceBetween);
        if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
            var slideBefore = -(offsetCenter - slide2.swiperSlideOffset);
            var slideAfter = slideBefore + swiper.slidesSizesGrid[i2];
            var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
            if (isVisible) {
                swiper.visibleSlides.push(slide2);
                swiper.visibleSlidesIndexes.push(i2);
                slides.eq(i2).addClass(params.slideVisibleClass);
            }
        }
        slide2.progress = rtl ? -slideProgress : slideProgress;
    }
    swiper.visibleSlides = $(swiper.visibleSlides);
}
function updateProgress(translate2) {
    var swiper = this;
    if (typeof translate2 === "undefined") {
        var multiplier = swiper.rtlTranslate ? -1 : 1;
        translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    var params = swiper.params;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    var progress = swiper.progress, isBeginning = swiper.isBeginning, isEnd = swiper.isEnd;
    var wasBeginning = isBeginning;
    var wasEnd = isEnd;
    if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
    } else {
        progress = (translate2 - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
    }
    extend(swiper, {
        progress,
        isBeginning,
        isEnd
    });
    if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate2);
    if (isBeginning && !wasBeginning) {
        swiper.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
        swiper.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit("fromEdge");
    }
    swiper.emit("progress", progress);
}
function updateSlidesClasses() {
    var swiper = this;
    var slides = swiper.slides, params = swiper.params, $wrapperEl = swiper.$wrapperEl, activeIndex = swiper.activeIndex, realIndex = swiper.realIndex;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
    var activeSlide;
    if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find("." + params.slideClass + '[data-swiper-slide-index="' + activeIndex + '"]');
    } else {
        activeSlide = slides.eq(activeIndex);
    }
    activeSlide.addClass(params.slideActiveClass);
    if (params.loop) {
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass);
        } else {
            $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass);
        }
    }
    var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);
    if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
    }
    var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);
    if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
    }
    if (params.loop) {
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass);
        } else {
            $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass);
        }
        if (prevSlide.hasClass(params.slideDuplicateClass)) {
            $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass);
        } else {
            $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass);
        }
    }
    swiper.emitSlidesClasses();
}
function updateActiveIndex(newActiveIndex) {
    var swiper = this;
    var translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    var slidesGrid = swiper.slidesGrid, snapGrid = swiper.snapGrid, params = swiper.params, previousIndex = swiper.activeIndex, previousRealIndex = swiper.realIndex, previousSnapIndex = swiper.snapIndex;
    var activeIndex = newActiveIndex;
    var snapIndex;
    if (typeof activeIndex === "undefined") {
        for(var i2 = 0; i2 < slidesGrid.length; i2 += 1){
            if (typeof slidesGrid[i2 + 1] !== "undefined") {
                if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1] - (slidesGrid[i2 + 1] - slidesGrid[i2]) / 2) {
                    activeIndex = i2;
                } else if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1]) {
                    activeIndex = i2 + 1;
                }
            } else if (translate2 >= slidesGrid[i2]) {
                activeIndex = i2;
            }
        }
        if (params.normalizeSlideIndex) {
            if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
        }
    }
    if (snapGrid.indexOf(translate2) >= 0) {
        snapIndex = snapGrid.indexOf(translate2);
    } else {
        var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
            swiper.snapIndex = snapIndex;
            swiper.emit("snapIndexChange");
        }
        return;
    }
    var realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
    extend(swiper, {
        snapIndex,
        realIndex,
        previousIndex,
        activeIndex
    });
    swiper.emit("activeIndexChange");
    swiper.emit("snapIndexChange");
    if (previousRealIndex !== realIndex) {
        swiper.emit("realIndexChange");
    }
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit("slideChange");
    }
}
function updateClickedSlide(e) {
    var swiper = this;
    var params = swiper.params;
    var slide2 = $(e.target).closest("." + params.slideClass)[0];
    var slideFound = false;
    var slideIndex;
    if (slide2) {
        for(var i2 = 0; i2 < swiper.slides.length; i2 += 1){
            if (swiper.slides[i2] === slide2) {
                slideFound = true;
                slideIndex = i2;
                break;
            }
        }
    }
    if (slide2 && slideFound) {
        swiper.clickedSlide = slide2;
        if (swiper.virtual && swiper.params.virtual.enabled) {
            swiper.clickedIndex = parseInt($(slide2).attr("data-swiper-slide-index"), 10);
        } else {
            swiper.clickedIndex = slideIndex;
        }
    } else {
        swiper.clickedSlide = void 0;
        swiper.clickedIndex = void 0;
        return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
    }
}
var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
};
function getSwiperTranslate(axis) {
    if (axis === void 0) {
        axis = this.isHorizontal() ? "x" : "y";
    }
    var swiper = this;
    var params = swiper.params, rtl = swiper.rtlTranslate, translate2 = swiper.translate, $wrapperEl = swiper.$wrapperEl;
    if (params.virtualTranslate) {
        return rtl ? -translate2 : translate2;
    }
    if (params.cssMode) {
        return translate2;
    }
    var currentTranslate = getTranslate($wrapperEl[0], axis);
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
    var swiper = this;
    var rtl = swiper.rtlTranslate, params = swiper.params, $wrapperEl = swiper.$wrapperEl, wrapperEl = swiper.wrapperEl, progress = swiper.progress;
    var x = 0;
    var y = 0;
    var z = 0;
    if (swiper.isHorizontal()) {
        x = rtl ? -translate2 : translate2;
    } else {
        y = translate2;
    }
    if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
    }
    if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
        $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y;
    var newProgress;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
        newProgress = 0;
    } else {
        newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
        swiper.updateProgress(translate2);
    }
    swiper.emit("setTranslate", swiper.translate, byController);
}
function minTranslate() {
    return -this.snapGrid[0];
}
function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
    if (translate2 === void 0) {
        translate2 = 0;
    }
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (translateBounds === void 0) {
        translateBounds = true;
    }
    var swiper = this;
    var params = swiper.params, wrapperEl = swiper.wrapperEl;
    if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
    }
    var minTranslate2 = swiper.minTranslate();
    var maxTranslate2 = swiper.maxTranslate();
    var newTranslate;
    if (translateBounds && translate2 > minTranslate2) newTranslate = minTranslate2;
    else if (translateBounds && translate2 < maxTranslate2) newTranslate = maxTranslate2;
    else newTranslate = translate2;
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
        var isH = swiper.isHorizontal();
        if (speed === 0) {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
        } else {
            if (wrapperEl.scrollTo) {
                var _wrapperEl$scrollTo;
                wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? "left" : "top"] = -newTranslate, _wrapperEl$scrollTo.behavior = "smooth", _wrapperEl$scrollTo));
            } else {
                wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
            }
        }
        return true;
    }
    if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionEnd");
        }
    } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionStart");
        }
        if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onTranslateToWrapperTransitionEnd) {
                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd4(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
                    swiper.onTranslateToWrapperTransitionEnd = null;
                    delete swiper.onTranslateToWrapperTransitionEnd;
                    if (runCallbacks) {
                        swiper.emit("transitionEnd");
                    }
                };
            }
            swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
            swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
        }
    }
    return true;
}
var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
};
function setTransition(duration, byController) {
    var swiper = this;
    if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
    }
    swiper.emit("setTransition", duration, byController);
}
function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var activeIndex = swiper.activeIndex, params = swiper.params, previousIndex = swiper.previousIndex;
    if (params.cssMode) return;
    if (params.autoHeight) {
        swiper.updateAutoHeight();
    }
    var dir = direction;
    if (!dir) {
        if (activeIndex > previousIndex) dir = "next";
        else if (activeIndex < previousIndex) dir = "prev";
        else dir = "reset";
    }
    swiper.emit("transitionStart");
    if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === "reset") {
            swiper.emit("slideResetTransitionStart");
            return;
        }
        swiper.emit("slideChangeTransitionStart");
        if (dir === "next") {
            swiper.emit("slideNextTransitionStart");
        } else {
            swiper.emit("slidePrevTransitionStart");
        }
    }
}
function transitionEnd(runCallbacks, direction) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var activeIndex = swiper.activeIndex, previousIndex = swiper.previousIndex, params = swiper.params;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    var dir = direction;
    if (!dir) {
        if (activeIndex > previousIndex) dir = "next";
        else if (activeIndex < previousIndex) dir = "prev";
        else dir = "reset";
    }
    swiper.emit("transitionEnd");
    if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === "reset") {
            swiper.emit("slideResetTransitionEnd");
            return;
        }
        swiper.emit("slideChangeTransitionEnd");
        if (dir === "next") {
            swiper.emit("slideNextTransitionEnd");
        } else {
            swiper.emit("slidePrevTransitionEnd");
        }
    }
}
var transition = {
    setTransition,
    transitionStart,
    transitionEnd
};
function slideTo(index2, speed, runCallbacks, internal, initial) {
    if (index2 === void 0) {
        index2 = 0;
    }
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (typeof index2 !== "number" && typeof index2 !== "string") {
        throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index2 + "] given.");
    }
    if (typeof index2 === "string") {
        var indexAsNumber = parseInt(index2, 10);
        var isValidNumber = isFinite(indexAsNumber);
        if (!isValidNumber) {
            throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index2 + "] given.");
        }
        index2 = indexAsNumber;
    }
    var swiper = this;
    var slideIndex = index2;
    if (slideIndex < 0) slideIndex = 0;
    var params = swiper.params, snapGrid = swiper.snapGrid, slidesGrid = swiper.slidesGrid, previousIndex = swiper.previousIndex, activeIndex = swiper.activeIndex, rtl = swiper.rtlTranslate, wrapperEl = swiper.wrapperEl, enabled = swiper.enabled;
    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
    }
    var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit("beforeSlideChangeStart");
    }
    var translate2 = -snapGrid[snapIndex];
    swiper.updateProgress(translate2);
    if (params.normalizeSlideIndex) {
        for(var i2 = 0; i2 < slidesGrid.length; i2 += 1){
            var normalizedTranslate = -Math.floor(translate2 * 100);
            var normalizedGird = Math.floor(slidesGrid[i2] * 100);
            var normalizedGridNext = Math.floor(slidesGrid[i2 + 1] * 100);
            if (typeof slidesGrid[i2 + 1] !== "undefined") {
                if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
                    slideIndex = i2;
                } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
                    slideIndex = i2 + 1;
                }
            } else if (normalizedTranslate >= normalizedGird) {
                slideIndex = i2;
            }
        }
    }
    if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate2 < swiper.translate && translate2 < swiper.minTranslate()) {
            return false;
        }
        if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
            if ((activeIndex || 0) !== slideIndex) return false;
        }
    }
    var direction;
    if (slideIndex > activeIndex) direction = "next";
    else if (slideIndex < activeIndex) direction = "prev";
    else direction = "reset";
    if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {
        swiper.updateActiveIndex(slideIndex);
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }
        swiper.updateSlidesClasses();
        if (params.effect !== "slide") {
            swiper.setTranslate(translate2);
        }
        if (direction !== "reset") {
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
        }
        return false;
    }
    if (params.cssMode) {
        var isH = swiper.isHorizontal();
        var t = -translate2;
        if (rtl) {
            t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
        }
        if (speed === 0) {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
        } else {
            if (wrapperEl.scrollTo) {
                var _wrapperEl$scrollTo;
                wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? "left" : "top"] = t, _wrapperEl$scrollTo.behavior = "smooth", _wrapperEl$scrollTo));
            } else {
                wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
            }
        }
        return true;
    }
    if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(translate2);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
    } else {
        swiper.setTransition(speed);
        swiper.setTranslate(translate2);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onSlideToWrapperTransitionEnd) {
                swiper.onSlideToWrapperTransitionEnd = function transitionEnd4(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
            }
            swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
        }
    }
    return true;
}
function slideToLoop(index2, speed, runCallbacks, internal) {
    if (index2 === void 0) {
        index2 = 0;
    }
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var newIndex = index2;
    if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
    }
    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}
function slideNext(speed, runCallbacks, internal) {
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var params = swiper.params, animating = swiper.animating, enabled = swiper.enabled;
    if (!enabled) return swiper;
    var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
    if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix();
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed, runCallbacks, internal) {
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    var params = swiper.params, animating = swiper.animating, snapGrid = swiper.snapGrid, slidesGrid = swiper.slidesGrid, rtlTranslate = swiper.rtlTranslate, enabled = swiper.enabled;
    if (!enabled) return swiper;
    if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix();
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }
    var translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize2(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
    }
    var normalizedTranslate = normalize2(translate2);
    var normalizedSnapGrid = snapGrid.map(function(val) {
        return normalize2(val);
    });
    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
        snapGrid.forEach(function(snap) {
            if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
        });
    }
    var prevIndex;
    if (typeof prevSnap !== "undefined") {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed, runCallbacks, internal) {
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    var swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (threshold === void 0) {
        threshold = 0.5;
    }
    var swiper = this;
    var index2 = swiper.activeIndex;
    var skip = Math.min(swiper.params.slidesPerGroupSkip, index2);
    var snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);
    var translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate2 >= swiper.snapGrid[snapIndex]) {
        var currentSnap = swiper.snapGrid[snapIndex];
        var nextSnap = swiper.snapGrid[snapIndex + 1];
        if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
            index2 += swiper.params.slidesPerGroup;
        }
    } else {
        var prevSnap = swiper.snapGrid[snapIndex - 1];
        var _currentSnap = swiper.snapGrid[snapIndex];
        if (translate2 - prevSnap <= (_currentSnap - prevSnap) * threshold) {
            index2 -= swiper.params.slidesPerGroup;
        }
    }
    index2 = Math.max(index2, 0);
    index2 = Math.min(index2, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index2, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
    var swiper = this;
    var params = swiper.params, $wrapperEl = swiper.$wrapperEl;
    var slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    var slideToIndex = swiper.clickedIndex;
    var realIndex;
    if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
        if (params.centeredSlides) {
            if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                swiper.loopFix();
                slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index();
                nextTick3(function() {
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index();
            nextTick3(function() {
                swiper.slideTo(slideToIndex);
            });
        } else {
            swiper.slideTo(slideToIndex);
        }
    } else {
        swiper.slideTo(slideToIndex);
    }
}
var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
};
function loopCreate() {
    var swiper = this;
    var document2 = getDocument();
    var params = swiper.params, $wrapperEl = swiper.$wrapperEl;
    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
    var slides = $wrapperEl.children("." + params.slideClass);
    if (params.loopFillGroupWithBlank) {
        var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
        if (blankSlidesNum !== params.slidesPerGroup) {
            for(var i2 = 0; i2 < blankSlidesNum; i2 += 1){
                var blankNode = $(document2.createElement("div")).addClass(params.slideClass + " " + params.slideBlankClass);
                $wrapperEl.append(blankNode);
            }
            slides = $wrapperEl.children("." + params.slideClass);
        }
    }
    if (params.slidesPerView === "auto" && !params.loopedSlides) params.loopedSlides = slides.length;
    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper.loopedSlides += params.loopAdditionalSlides;
    if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
    }
    var prependSlides = [];
    var appendSlides = [];
    slides.each(function(el, index2) {
        var slide2 = $(el);
        if (index2 < swiper.loopedSlides) {
            appendSlides.push(el);
        }
        if (index2 < slides.length && index2 >= slides.length - swiper.loopedSlides) {
            prependSlides.push(el);
        }
        slide2.attr("data-swiper-slide-index", index2);
    });
    for(var _i = 0; _i < appendSlides.length; _i += 1){
        $wrapperEl.append($(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
    for(var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1){
        $wrapperEl.prepend($(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
}
function loopFix() {
    var swiper = this;
    swiper.emit("beforeLoopFix");
    var activeIndex = swiper.activeIndex, slides = swiper.slides, loopedSlides = swiper.loopedSlides, allowSlidePrev = swiper.allowSlidePrev, allowSlideNext = swiper.allowSlideNext, snapGrid = swiper.snapGrid, rtl = swiper.rtlTranslate;
    var newIndex;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    var snapTranslate = -snapGrid[activeIndex];
    var diff = snapTranslate - swiper.getTranslate();
    if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        var slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (slideChanged && diff !== 0) {
            swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
    } else if (activeIndex >= slides.length - loopedSlides) {
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        var _slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (_slideChanged && diff !== 0) {
            swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit("loopFix");
}
function loopDestroy() {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl, params = swiper.params, slides = swiper.slides;
    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
    slides.removeAttr("data-swiper-slide-index");
}
var loop = {
    loopCreate,
    loopFix,
    loopDestroy
};
function setGrabCursor(moving) {
    var swiper = this;
    if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    var el = swiper.el;
    el.style.cursor = "move";
    el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
    el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
    el.style.cursor = moving ? "grabbing" : "grab";
}
function unsetGrabCursor() {
    var swiper = this;
    if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
    }
    swiper.el.style.cursor = "";
}
var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
};
function appendSlide(slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl, params = swiper.params;
    if (params.loop) {
        swiper.loopDestroy();
    }
    if (typeof slides === "object" && "length" in slides) {
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            if (slides[i2]) $wrapperEl.append(slides[i2]);
        }
    } else {
        $wrapperEl.append(slides);
    }
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!(params.observer && swiper.support.observer)) {
        swiper.update();
    }
}
function prependSlide(slides) {
    var swiper = this;
    var params = swiper.params, $wrapperEl = swiper.$wrapperEl, activeIndex = swiper.activeIndex;
    if (params.loop) {
        swiper.loopDestroy();
    }
    var newActiveIndex = activeIndex + 1;
    if (typeof slides === "object" && "length" in slides) {
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            if (slides[i2]) $wrapperEl.prepend(slides[i2]);
        }
        newActiveIndex = activeIndex + slides.length;
    } else {
        $wrapperEl.prepend(slides);
    }
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!(params.observer && swiper.support.observer)) {
        swiper.update();
    }
    swiper.slideTo(newActiveIndex, 0, false);
}
function addSlide(index2, slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl, params = swiper.params, activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;
    if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
    }
    var baseLength = swiper.slides.length;
    if (index2 <= 0) {
        swiper.prependSlide(slides);
        return;
    }
    if (index2 >= baseLength) {
        swiper.appendSlide(slides);
        return;
    }
    var newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + 1 : activeIndexBuffer;
    var slidesBuffer = [];
    for(var i2 = baseLength - 1; i2 >= index2; i2 -= 1){
        var currentSlide = swiper.slides.eq(i2);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
    }
    if (typeof slides === "object" && "length" in slides) {
        for(var _i = 0; _i < slides.length; _i += 1){
            if (slides[_i]) $wrapperEl.append(slides[_i]);
        }
        newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
        $wrapperEl.append(slides);
    }
    for(var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1){
        $wrapperEl.append(slidesBuffer[_i2]);
    }
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!(params.observer && swiper.support.observer)) {
        swiper.update();
    }
    if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
        swiper.slideTo(newActiveIndex, 0, false);
    }
}
function removeSlide(slidesIndexes) {
    var swiper = this;
    var params = swiper.params, $wrapperEl = swiper.$wrapperEl, activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;
    if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
    }
    var newActiveIndex = activeIndexBuffer;
    var indexToRemove;
    if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
        for(var i2 = 0; i2 < slidesIndexes.length; i2 += 1){
            indexToRemove = slidesIndexes[i2];
            if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }
        newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
    }
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!(params.observer && swiper.support.observer)) {
        swiper.update();
    }
    if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
        swiper.slideTo(newActiveIndex, 0, false);
    }
}
function removeAllSlides() {
    var swiper = this;
    var slidesIndexes = [];
    for(var i2 = 0; i2 < swiper.slides.length; i2 += 1){
        slidesIndexes.push(i2);
    }
    swiper.removeSlide(slidesIndexes);
}
var manipulation = {
    appendSlide,
    prependSlide,
    addSlide,
    removeSlide,
    removeAllSlides
};
function onTouchStart(event2) {
    var swiper = this;
    var document2 = getDocument();
    var window2 = getWindow();
    var data = swiper.touchEventsData;
    var params = swiper.params, touches = swiper.touches, enabled = swiper.enabled;
    if (!enabled) return;
    if (swiper.animating && params.preventInteractionOnTransition) {
        return;
    }
    var e = event2;
    if (e.originalEvent) e = e.originalEvent;
    var $targetEl = $(e.target);
    if (params.touchEventsTarget === "wrapper") {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
    }
    data.isTouchEvent = e.type === "touchstart";
    if (!data.isTouchEvent && "which" in e && e.which === 3) return;
    if (!data.isTouchEvent && "button" in e && e.button > 0) return;
    if (data.isTouched && data.isMoved) return;
    var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    if (swipingClassHasValue && e.target && e.target.shadowRoot && event2.path && event2.path[0]) {
        $targetEl = $(event2.path[0]);
    }
    if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
        swiper.allowClick = true;
        return;
    }
    if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
    }
    touches.currentX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touches.currentY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    var startX = touches.currentX;
    var startY = touches.currentY;
    var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === "prevent") {
            event2.preventDefault();
        } else {
            return;
        }
    }
    extend(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: void 0,
        startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = void 0;
    if (params.threshold > 0) data.allowThresholdMove = false;
    if (e.type !== "touchstart") {
        var preventDefault = true;
        if ($targetEl.is(data.focusableElements)) preventDefault = false;
        if (document2.activeElement && $(document2.activeElement).is(data.focusableElements) && document2.activeElement !== $targetEl[0]) {
            document2.activeElement.blur();
        }
        var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
            e.preventDefault();
        }
    }
    swiper.emit("touchStart", e);
}
function onTouchMove(event2) {
    var document2 = getDocument();
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params, touches = swiper.touches, rtl = swiper.rtlTranslate, enabled = swiper.enabled;
    if (!enabled) return;
    var e = event2;
    if (e.originalEvent) e = e.originalEvent;
    if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
            swiper.emit("touchMoveOpposite", e);
        }
        return;
    }
    if (data.isTouchEvent && e.type !== "touchmove") return;
    var targetTouch = e.type === "touchmove" && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
    var pageX = e.type === "touchmove" ? targetTouch.pageX : e.pageX;
    var pageY = e.type === "touchmove" ? targetTouch.pageY : e.pageY;
    if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
    }
    if (!swiper.allowTouchMove) {
        swiper.allowClick = false;
        if (data.isTouched) {
            extend(touches, {
                startX: pageX,
                startY: pageY,
                currentX: pageX,
                currentY: pageY
            });
            data.touchStartTime = now();
        }
        return;
    }
    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                data.isTouched = false;
                data.isMoved = false;
                return;
            }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
            return;
        }
    }
    if (data.isTouchEvent && document2.activeElement) {
        if (e.target === document2.activeElement && $(e.target).is(data.focusableElements)) {
            data.isMoved = true;
            swiper.allowClick = false;
            return;
        }
    }
    if (data.allowTouchCallbacks) {
        swiper.emit("touchMove", e);
    }
    if (e.targetTouches && e.targetTouches.length > 1) return;
    touches.currentX = pageX;
    touches.currentY = pageY;
    var diffX = touches.currentX - touches.startX;
    var diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;
    if (typeof data.isScrolling === "undefined") {
        var touchAngle;
        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
            data.isScrolling = false;
        } else {
            if (diffX * diffX + diffY * diffY >= 25) {
                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
            }
        }
    }
    if (data.isScrolling) {
        swiper.emit("touchMoveOpposite", e);
    }
    if (typeof data.startMoving === "undefined") {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
            data.startMoving = true;
        }
    }
    if (data.isScrolling) {
        data.isTouched = false;
        return;
    }
    if (!data.startMoving) {
        return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e.cancelable) {
        e.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
    }
    if (!data.isMoved) {
        if (params.loop) {
            swiper.loopFix();
        }
        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);
        if (swiper.animating) {
            swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
        }
        data.allowMomentumBounce = false;
        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(true);
        }
        swiper.emit("sliderFirstMove", e);
    }
    swiper.emit("sliderMove", e);
    data.isMoved = true;
    var diff = swiper.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) diff = -diff;
    swiper.swipeDirection = diff > 0 ? "prev" : "next";
    data.currentTranslate = diff + data.startTranslate;
    var disableParentSwiper = true;
    var resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
    }
    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
    }
    if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
    }
    if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
    }
    if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
            if (!data.allowThresholdMove) {
                data.allowThresholdMove = true;
                touches.startX = touches.currentX;
                touches.startY = touches.currentY;
                data.currentTranslate = data.startTranslate;
                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                return;
            }
        } else {
            data.currentTranslate = data.startTranslate;
            return;
        }
    }
    if (!params.followFinger || params.cssMode) return;
    if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    if (params.freeMode) {
        if (data.velocities.length === 0) {
            data.velocities.push({
                position: touches[swiper.isHorizontal() ? "startX" : "startY"],
                time: data.touchStartTime
            });
        }
        data.velocities.push({
            position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
            time: now()
        });
    }
    swiper.updateProgress(data.currentTranslate);
    swiper.setTranslate(data.currentTranslate);
}
function onTouchEnd(event2) {
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params, touches = swiper.touches, rtl = swiper.rtlTranslate, $wrapperEl = swiper.$wrapperEl, slidesGrid = swiper.slidesGrid, snapGrid = swiper.snapGrid, enabled = swiper.enabled;
    if (!enabled) return;
    var e = event2;
    if (e.originalEvent) e = e.originalEvent;
    if (data.allowTouchCallbacks) {
        swiper.emit("touchEnd", e);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
            swiper.setGrabCursor(false);
        }
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
    }
    var touchEndTime = now();
    var timeDiff = touchEndTime - data.touchStartTime;
    if (swiper.allowClick) {
        swiper.updateClickedSlide(e);
        swiper.emit("tap click", e);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
            swiper.emit("doubleTap doubleClick", e);
        }
    }
    data.lastClickTime = now();
    nextTick3(function() {
        if (!swiper.destroyed) swiper.allowClick = true;
    });
    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    var currentPos;
    if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
        currentPos = -data.currentTranslate;
    }
    if (params.cssMode) {
        return;
    }
    if (params.freeMode) {
        if (currentPos < -swiper.minTranslate()) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        if (currentPos > -swiper.maxTranslate()) {
            if (swiper.slides.length < snapGrid.length) {
                swiper.slideTo(snapGrid.length - 1);
            } else {
                swiper.slideTo(swiper.slides.length - 1);
            }
            return;
        }
        if (params.freeModeMomentum) {
            if (data.velocities.length > 1) {
                var lastMoveEvent = data.velocities.pop();
                var velocityEvent = data.velocities.pop();
                var distance = lastMoveEvent.position - velocityEvent.position;
                var time = lastMoveEvent.time - velocityEvent.time;
                swiper.velocity = distance / time;
                swiper.velocity /= 2;
                if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
                    swiper.velocity = 0;
                }
                if (time > 150 || now() - lastMoveEvent.time > 300) {
                    swiper.velocity = 0;
                }
            } else {
                swiper.velocity = 0;
            }
            swiper.velocity *= params.freeModeMomentumVelocityRatio;
            data.velocities.length = 0;
            var momentumDuration = 1e3 * params.freeModeMomentumRatio;
            var momentumDistance = swiper.velocity * momentumDuration;
            var newPosition = swiper.translate + momentumDistance;
            if (rtl) newPosition = -newPosition;
            var doBounce = false;
            var afterBouncePosition;
            var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
            var needsLoopFix;
            if (newPosition < swiper.maxTranslate()) {
                if (params.freeModeMomentumBounce) {
                    if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                        newPosition = swiper.maxTranslate() - bounceAmount;
                    }
                    afterBouncePosition = swiper.maxTranslate();
                    doBounce = true;
                    data.allowMomentumBounce = true;
                } else {
                    newPosition = swiper.maxTranslate();
                }
                if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (newPosition > swiper.minTranslate()) {
                if (params.freeModeMomentumBounce) {
                    if (newPosition - swiper.minTranslate() > bounceAmount) {
                        newPosition = swiper.minTranslate() + bounceAmount;
                    }
                    afterBouncePosition = swiper.minTranslate();
                    doBounce = true;
                    data.allowMomentumBounce = true;
                } else {
                    newPosition = swiper.minTranslate();
                }
                if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (params.freeModeSticky) {
                var nextSlide;
                for(var j = 0; j < snapGrid.length; j += 1){
                    if (snapGrid[j] > -newPosition) {
                        nextSlide = j;
                        break;
                    }
                }
                if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") {
                    newPosition = snapGrid[nextSlide];
                } else {
                    newPosition = snapGrid[nextSlide - 1];
                }
                newPosition = -newPosition;
            }
            if (needsLoopFix) {
                swiper.once("transitionEnd", function() {
                    swiper.loopFix();
                });
            }
            if (swiper.velocity !== 0) {
                if (rtl) {
                    momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                } else {
                    momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                }
                if (params.freeModeSticky) {
                    var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                    var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                    if (moveDistance < currentSlideSize) {
                        momentumDuration = params.speed;
                    } else if (moveDistance < 2 * currentSlideSize) {
                        momentumDuration = params.speed * 1.5;
                    } else {
                        momentumDuration = params.speed * 2.5;
                    }
                }
            } else if (params.freeModeSticky) {
                swiper.slideToClosest();
                return;
            }
            if (params.freeModeMomentumBounce && doBounce) {
                swiper.updateProgress(afterBouncePosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                swiper.animating = true;
                $wrapperEl.transitionEnd(function() {
                    if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                    swiper.emit("momentumBounce");
                    swiper.setTransition(params.speed);
                    setTimeout(function() {
                        swiper.setTranslate(afterBouncePosition);
                        $wrapperEl.transitionEnd(function() {
                            if (!swiper || swiper.destroyed) return;
                            swiper.transitionEnd();
                        });
                    }, 0);
                });
            } else if (swiper.velocity) {
                swiper.updateProgress(newPosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                if (!swiper.animating) {
                    swiper.animating = true;
                    $wrapperEl.transitionEnd(function() {
                        if (!swiper || swiper.destroyed) return;
                        swiper.transitionEnd();
                    });
                }
            } else {
                swiper.emit("_freeModeNoMomentumRelease");
                swiper.updateProgress(newPosition);
            }
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        } else if (params.freeModeSticky) {
            swiper.slideToClosest();
            return;
        } else if (params.freeMode) {
            swiper.emit("_freeModeNoMomentumRelease");
        }
        if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        return;
    }
    var stopIndex = 0;
    var groupSize = swiper.slidesSizesGrid[0];
    for(var i2 = 0; i2 < slidesGrid.length; i2 += i2 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){
        var _increment = i2 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i2 + _increment] !== "undefined") {
            if (currentPos >= slidesGrid[i2] && currentPos < slidesGrid[i2 + _increment]) {
                stopIndex = i2;
                groupSize = slidesGrid[i2 + _increment] - slidesGrid[i2];
            }
        } else if (currentPos >= slidesGrid[i2]) {
            stopIndex = i2;
            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
    }
    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
        if (!params.longSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        if (swiper.swipeDirection === "next") {
            if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
            else swiper.slideTo(stopIndex);
        }
        if (swiper.swipeDirection === "prev") {
            if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
            else swiper.slideTo(stopIndex);
        }
    } else {
        if (!params.shortSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
        if (!isNavButtonTarget) {
            if (swiper.swipeDirection === "next") {
                swiper.slideTo(stopIndex + increment);
            }
            if (swiper.swipeDirection === "prev") {
                swiper.slideTo(stopIndex);
            }
        } else if (e.target === swiper.navigation.nextEl) {
            swiper.slideTo(stopIndex + increment);
        } else {
            swiper.slideTo(stopIndex);
        }
    }
}
function onResize() {
    var swiper = this;
    var params = swiper.params, el = swiper.el;
    if (el && el.offsetWidth === 0) return;
    if (params.breakpoints) {
        swiper.setBreakpoint();
    }
    var allowSlideNext = swiper.allowSlideNext, allowSlidePrev = swiper.allowSlidePrev, snapGrid = swiper.snapGrid;
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
    }
}
function onClick(e) {
    var swiper = this;
    if (!swiper.enabled) return;
    if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();
        if (swiper.params.preventClicksPropagation && swiper.animating) {
            e.stopPropagation();
            e.stopImmediatePropagation();
        }
    }
}
function onScroll() {
    var swiper = this;
    var wrapperEl = swiper.wrapperEl, rtlTranslate = swiper.rtlTranslate, enabled = swiper.enabled;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
        if (rtlTranslate) {
            swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
        } else {
            swiper.translate = -wrapperEl.scrollLeft;
        }
    } else {
        swiper.translate = -wrapperEl.scrollTop;
    }
    if (swiper.translate === -0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    var newProgress;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
        newProgress = 0;
    } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit("setTranslate", swiper.translate, false);
}
var dummyEventAttached = false;
function dummyEventListener() {}
function attachEvents() {
    var swiper = this;
    var document2 = getDocument();
    var params = swiper.params, touchEvents = swiper.touchEvents, el = swiper.el, wrapperEl = swiper.wrapperEl, device2 = swiper.device, support3 = swiper.support;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    var capture = !!params.nested;
    if (!support3.touch && support3.pointerEvents) {
        el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
        document2.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document2.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
        if (support3.touch) {
            var passiveListener = touchEvents.start === "touchstart" && support3.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
            el.addEventListener(touchEvents.move, swiper.onTouchMove, support3.passiveListener ? {
                passive: false,
                capture
            } : capture);
            el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
            if (touchEvents.cancel) {
                el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
            if (!dummyEventAttached) {
                document2.addEventListener("touchstart", dummyEventListener);
                dummyEventAttached = true;
            }
        }
        if (params.simulateTouch && !device2.ios && !device2.android || params.simulateTouch && !support3.touch && device2.ios) {
            el.addEventListener("mousedown", swiper.onTouchStart, false);
            document2.addEventListener("mousemove", swiper.onTouchMove, capture);
            document2.addEventListener("mouseup", swiper.onTouchEnd, false);
        }
    }
    if (params.preventClicks || params.preventClicksPropagation) {
        el.addEventListener("click", swiper.onClick, true);
    }
    if (params.cssMode) {
        wrapperEl.addEventListener("scroll", swiper.onScroll);
    }
    if (params.updateOnWindowResize) {
        swiper.on(device2.ios || device2.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
        swiper.on("observerUpdate", onResize, true);
    }
}
function detachEvents() {
    var swiper = this;
    var document2 = getDocument();
    var params = swiper.params, touchEvents = swiper.touchEvents, el = swiper.el, wrapperEl = swiper.wrapperEl, device2 = swiper.device, support3 = swiper.support;
    var capture = !!params.nested;
    if (!support3.touch && support3.pointerEvents) {
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
        document2.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document2.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
        if (support3.touch) {
            var passiveListener = touchEvents.start === "onTouchStart" && support3.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
            el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
            el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
            if (touchEvents.cancel) {
                el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
        }
        if (params.simulateTouch && !device2.ios && !device2.android || params.simulateTouch && !support3.touch && device2.ios) {
            el.removeEventListener("mousedown", swiper.onTouchStart, false);
            document2.removeEventListener("mousemove", swiper.onTouchMove, capture);
            document2.removeEventListener("mouseup", swiper.onTouchEnd, false);
        }
    }
    if (params.preventClicks || params.preventClicksPropagation) {
        el.removeEventListener("click", swiper.onClick, true);
    }
    if (params.cssMode) {
        wrapperEl.removeEventListener("scroll", swiper.onScroll);
    }
    swiper.off(device2.ios || device2.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize);
}
var events = {
    attachEvents,
    detachEvents
};
function setBreakpoint() {
    var swiper = this;
    var activeIndex = swiper.activeIndex, initialized = swiper.initialized, _swiper$loopedSlides = swiper.loopedSlides, loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides, params = swiper.params, $el = swiper.$el;
    var breakpoints2 = params.breakpoints;
    if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0) return;
    var breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    var breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
    if (breakpointOnlyParams) {
        [
            "slidesPerView",
            "spaceBetween",
            "slidesPerGroup",
            "slidesPerGroupSkip",
            "slidesPerColumn"
        ].forEach(function(param) {
            var paramValue = breakpointOnlyParams[param];
            if (typeof paramValue === "undefined") return;
            if (param === "slidesPerView" && (paramValue === "AUTO" || paramValue === "auto")) {
                breakpointOnlyParams[param] = "auto";
            } else if (param === "slidesPerView") {
                breakpointOnlyParams[param] = parseFloat(paramValue);
            } else {
                breakpointOnlyParams[param] = parseInt(paramValue, 10);
            }
        });
    }
    var breakpointParams = breakpointOnlyParams || swiper.originalParams;
    var wasMultiRow = params.slidesPerColumn > 1;
    var isMultiRow = breakpointParams.slidesPerColumn > 1;
    var wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
        $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
        swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(params.containerModifierClass + "multirow");
        if (breakpointParams.slidesPerColumnFill === "column") {
            $el.addClass(params.containerModifierClass + "multirow-column");
        }
        swiper.emitContainerClasses();
    }
    var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    if (directionChanged && initialized) {
        swiper.changeDirection();
    }
    extend(swiper.params, breakpointParams);
    var isEnabled = swiper.params.enabled;
    extend(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
        swiper.disable();
    } else if (!wasEnabled && isEnabled) {
        swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
    }
    swiper.emit("breakpoint", breakpointParams);
}
function getBreakpoint(breakpoints2, base, containerEl) {
    if (base === void 0) {
        base = "window";
    }
    if (!breakpoints2 || base === "container" && !containerEl) return void 0;
    var breakpoint = false;
    var window2 = getWindow();
    var currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    var points = Object.keys(breakpoints2).map(function(point2) {
        if (typeof point2 === "string" && point2.indexOf("@") === 0) {
            var minRatio = parseFloat(point2.substr(1));
            var value2 = currentHeight * minRatio;
            return {
                value: value2,
                point: point2
            };
        }
        return {
            value: point2,
            point: point2
        };
    });
    points.sort(function(a, b) {
        return parseInt(a.value, 10) - parseInt(b.value, 10);
    });
    for(var i2 = 0; i2 < points.length; i2 += 1){
        var _points$i = points[i2], point = _points$i.point, value = _points$i.value;
        if (base === "window") {
            if (window2.matchMedia("(min-width: " + value + "px)").matches) {
                breakpoint = point;
            }
        } else if (value <= containerEl.clientWidth) {
            breakpoint = point;
        }
    }
    return breakpoint || "max";
}
var breakpoints = {
    setBreakpoint,
    getBreakpoint
};
function prepareClasses(entries, prefix) {
    var resultClasses = [];
    entries.forEach(function(item) {
        if (typeof item === "object") {
            Object.keys(item).forEach(function(classNames) {
                if (item[classNames]) {
                    resultClasses.push(prefix + classNames);
                }
            });
        } else if (typeof item === "string") {
            resultClasses.push(prefix + item);
        }
    });
    return resultClasses;
}
function addClasses() {
    var swiper = this;
    var classNames = swiper.classNames, params = swiper.params, rtl = swiper.rtl, $el = swiper.$el, device2 = swiper.device, support3 = swiper.support;
    var suffixes = prepareClasses([
        "initialized",
        params.direction,
        {
            "pointer-events": support3.pointerEvents && !support3.touch
        },
        {
            "free-mode": params.freeMode
        },
        {
            "autoheight": params.autoHeight
        },
        {
            "rtl": rtl
        },
        {
            "multirow": params.slidesPerColumn > 1
        },
        {
            "multirow-column": params.slidesPerColumn > 1 && params.slidesPerColumnFill === "column"
        },
        {
            "android": device2.android
        },
        {
            "ios": device2.ios
        },
        {
            "css-mode": params.cssMode
        }
    ], params.containerModifierClass);
    classNames.push.apply(classNames, suffixes);
    $el.addClass([].concat(classNames).join(" "));
    swiper.emitContainerClasses();
}
function removeClasses() {
    var swiper = this;
    var $el = swiper.$el, classNames = swiper.classNames;
    $el.removeClass(classNames.join(" "));
    swiper.emitContainerClasses();
}
var classes = {
    addClasses,
    removeClasses
};
function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
    var window2 = getWindow();
    var image;
    function onReady() {
        if (callback) callback();
    }
    var isPicture = $(imageEl).parent("picture")[0];
    if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
            image = new window2.Image();
            image.onload = onReady;
            image.onerror = onReady;
            if (sizes) {
                image.sizes = sizes;
            }
            if (srcset) {
                image.srcset = srcset;
            }
            if (src) {
                image.src = src;
            }
        } else {
            onReady();
        }
    } else {
        onReady();
    }
}
function preloadImages() {
    var swiper = this;
    swiper.imagesToLoad = swiper.$el.find("img");
    function onReady() {
        if (typeof swiper === "undefined" || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== void 0) swiper.imagesLoaded += 1;
        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
            if (swiper.params.updateOnImagesReady) swiper.update();
            swiper.emit("imagesReady");
        }
    }
    for(var i2 = 0; i2 < swiper.imagesToLoad.length; i2 += 1){
        var imageEl = swiper.imagesToLoad[i2];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
    }
}
var images = {
    loadImage,
    preloadImages
};
function checkOverflow() {
    var swiper = this;
    var params = swiper.params;
    var wasLocked = swiper.isLocked;
    var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;
    if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
        swiper.isLocked = lastSlidePosition <= swiper.size;
    } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
    }
    swiper.allowSlideNext = !swiper.isLocked;
    swiper.allowSlidePrev = !swiper.isLocked;
    if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
    if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
        if (swiper.navigation) swiper.navigation.update();
    }
}
var checkOverflow$1 = {
    checkOverflow
};
var defaults = {
    init: true,
    direction: "horizontal",
    touchEventsTarget: "container",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: false,
    nested: false,
    createElements: false,
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: false,
    userAgent: null,
    url: null,
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    freeMode: false,
    freeModeMomentum: true,
    freeModeMomentumRatio: 1,
    freeModeMomentumBounce: true,
    freeModeMomentumBounceRatio: 1,
    freeModeMomentumVelocityRatio: 1,
    freeModeSticky: false,
    freeModeMinimumVelocity: 0.02,
    autoHeight: false,
    setWrapperSize: false,
    virtualTranslate: false,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerColumn: 1,
    slidesPerColumnFill: "column",
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    watchOverflow: false,
    roundLengths: false,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    uniqueNavElements: true,
    resistance: true,
    resistanceRatio: 0.85,
    watchSlidesProgress: false,
    watchSlidesVisibility: false,
    grabCursor: false,
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    preloadImages: true,
    updateOnImagesReady: true,
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: false,
    loopPreventsSlide: true,
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: true,
    containerModifierClass: "swiper-container-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-invisible-blank",
    slideActiveClass: "swiper-slide-active",
    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
    slideVisibleClass: "swiper-slide-visible",
    slideDuplicateClass: "swiper-slide-duplicate",
    slideNextClass: "swiper-slide-next",
    slideDuplicateNextClass: "swiper-slide-duplicate-next",
    slidePrevClass: "swiper-slide-prev",
    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
    wrapperClass: "swiper-wrapper",
    runCallbacksOnInit: true,
    _emitClasses: false
};
function _defineProperties2(target, props) {
    for(var i2 = 0; i2 < props.length; i2++){
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties2(Constructor, staticProps);
    return Constructor;
}
var prototypes = {
    modular,
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    manipulation,
    events,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes,
    images
};
var extendedDefaults = {};
var Swiper$1 = function() {
    function Swiper2() {
        var el;
        var params;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
            params = args[0];
        } else {
            el = args[0];
            params = args[1];
        }
        if (!params) params = {};
        params = extend({}, params);
        if (el && !params.el) params.el = el;
        if (params.el && $(params.el).length > 1) {
            var swipers = [];
            $(params.el).each(function(containerEl) {
                var newParams = extend({}, params, {
                    el: containerEl
                });
                swipers.push(new Swiper2(newParams));
            });
            return swipers;
        }
        var swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
            userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        if (typeof swiper.modules === "undefined") {
            swiper.modules = {};
        }
        Object.keys(swiper.modules).forEach(function(moduleName) {
            var module = swiper.modules[moduleName];
            if (module.params) {
                var moduleParamName = Object.keys(module.params)[0];
                var moduleParams = module.params[moduleParamName];
                if (typeof moduleParams !== "object" || moduleParams === null) return;
                if ([
                    "navigation",
                    "pagination",
                    "scrollbar"
                ].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
                    params[moduleParamName] = {
                        auto: true
                    };
                }
                if (!(moduleParamName in params && "enabled" in moduleParams)) return;
                if (params[moduleParamName] === true) {
                    params[moduleParamName] = {
                        enabled: true
                    };
                }
                if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
                    params[moduleParamName].enabled = true;
                }
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
            }
        });
        var swiperParams = extend({}, defaults);
        swiper.useParams(swiperParams);
        swiper.params = extend({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend({}, swiper.params);
        swiper.passedParams = extend({}, params);
        if (swiper.params && swiper.params.on) {
            Object.keys(swiper.params.on).forEach(function(eventName) {
                swiper.on(eventName, swiper.params.on[eventName]);
            });
        }
        if (swiper.params && swiper.params.onAny) {
            swiper.onAny(swiper.params.onAny);
        }
        swiper.$ = $;
        extend(swiper, {
            enabled: swiper.params.enabled,
            el,
            classNames: [],
            slides: $(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal: function isHorizontal() {
                return swiper.params.direction === "horizontal";
            },
            isVertical: function isVertical() {
                return swiper.params.direction === "vertical";
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: true,
            isEnd: false,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: false,
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev,
            touchEvents: function touchEvents() {
                var touch = [
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "touchcancel"
                ];
                var desktop = [
                    "mousedown",
                    "mousemove",
                    "mouseup"
                ];
                if (swiper.support.pointerEvents) {
                    desktop = [
                        "pointerdown",
                        "pointermove",
                        "pointerup"
                    ];
                }
                swiper.touchEventsTouch = {
                    start: touch[0],
                    move: touch[1],
                    end: touch[2],
                    cancel: touch[3]
                };
                swiper.touchEventsDesktop = {
                    start: desktop[0],
                    move: desktop[1],
                    end: desktop[2]
                };
                return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
            }(),
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: swiper.params.focusableElements,
                lastClickTime: now(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0
            },
            allowClick: true,
            allowTouchMove: swiper.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        });
        swiper.useModules();
        swiper.emit("_swiper");
        if (swiper.params.init) {
            swiper.init();
        }
        return swiper;
    }
    var _proto = Swiper2.prototype;
    _proto.enable = function enable4() {
        var swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;
        if (swiper.params.grabCursor) {
            swiper.setGrabCursor();
        }
        swiper.emit("enable");
    };
    _proto.disable = function disable4() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;
        if (swiper.params.grabCursor) {
            swiper.unsetGrabCursor();
        }
        swiper.emit("disable");
    };
    _proto.setProgress = function setProgress(progress, speed) {
        var swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        var min = swiper.minTranslate();
        var max = swiper.maxTranslate();
        var current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    };
    _proto.emitContainerClasses = function emitContainerClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var classes2 = swiper.el.className.split(" ").filter(function(className) {
            return className.indexOf("swiper-container") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit("_containerClasses", classes2.join(" "));
    };
    _proto.getSlideClasses = function getSlideClasses(slideEl) {
        var swiper = this;
        return slideEl.className.split(" ").filter(function(className) {
            return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(" ");
    };
    _proto.emitSlidesClasses = function emitSlidesClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var updates = [];
        swiper.slides.each(function(slideEl) {
            var classNames = swiper.getSlideClasses(slideEl);
            updates.push({
                slideEl,
                classNames
            });
            swiper.emit("_slideClass", slideEl, classNames);
        });
        swiper.emit("_slideClasses", updates);
    };
    _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
        var swiper = this;
        var params = swiper.params, slides = swiper.slides, slidesGrid = swiper.slidesGrid, swiperSize = swiper.size, activeIndex = swiper.activeIndex;
        var spv = 1;
        if (params.centeredSlides) {
            var slideSize = slides[activeIndex].swiperSlideSize;
            var breakLoop;
            for(var i2 = activeIndex + 1; i2 < slides.length; i2 += 1){
                if (slides[i2] && !breakLoop) {
                    slideSize += slides[i2].swiperSlideSize;
                    spv += 1;
                    if (slideSize > swiperSize) breakLoop = true;
                }
            }
            for(var _i = activeIndex - 1; _i >= 0; _i -= 1){
                if (slides[_i] && !breakLoop) {
                    slideSize += slides[_i].swiperSlideSize;
                    spv += 1;
                    if (slideSize > swiperSize) breakLoop = true;
                }
            }
        } else {
            for(var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1){
                if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
                    spv += 1;
                }
            }
        }
        return spv;
    };
    _proto.update = function update9() {
        var swiper = this;
        if (!swiper || swiper.destroyed) return;
        var snapGrid = swiper.snapGrid, params = swiper.params;
        if (params.breakpoints) {
            swiper.setBreakpoint();
        }
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();
        function setTranslate17() {
            var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
            var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        var translated;
        if (swiper.params.freeMode) {
            setTranslate17();
            if (swiper.params.autoHeight) {
                swiper.updateAutoHeight();
            }
        } else {
            if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
            } else {
                translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
            }
            if (!translated) {
                setTranslate17();
            }
        }
        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
        swiper.emit("update");
    };
    _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
            needUpdate = true;
        }
        var swiper = this;
        var currentDirection = swiper.params.direction;
        if (!newDirection) {
            newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
        }
        if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
            return swiper;
        }
        swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(function(slideEl) {
            if (newDirection === "vertical") {
                slideEl.style.width = "";
            } else {
                slideEl.style.height = "";
            }
        });
        swiper.emit("changeDirection");
        if (needUpdate) swiper.update();
        return swiper;
    };
    _proto.mount = function mount(el) {
        var swiper = this;
        if (swiper.mounted) return true;
        var $el = $(el || swiper.params.el);
        el = $el[0];
        if (!el) {
            return false;
        }
        el.swiper = swiper;
        var getWrapperSelector = function getWrapperSelector2() {
            return "." + (swiper.params.wrapperClass || "").trim().split(" ").join(".");
        };
        var getWrapper = function getWrapper2() {
            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                var res = $(el.shadowRoot.querySelector(getWrapperSelector()));
                res.children = function(options3) {
                    return $el.children(options3);
                };
                return res;
            }
            return $el.children(getWrapperSelector());
        };
        var $wrapperEl = getWrapper();
        if ($wrapperEl.length === 0 && swiper.params.createElements) {
            var document2 = getDocument();
            var wrapper = document2.createElement("div");
            $wrapperEl = $(wrapper);
            wrapper.className = swiper.params.wrapperClass;
            $el.append(wrapper);
            $el.children("." + swiper.params.slideClass).each(function(slideEl) {
                $wrapperEl.append(slideEl);
            });
        }
        extend(swiper, {
            $el,
            el,
            $wrapperEl,
            wrapperEl: $wrapperEl[0],
            mounted: true,
            rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
            rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
            wrongRTL: $wrapperEl.css("display") === "-webkit-box"
        });
        return true;
    };
    _proto.init = function init23(el) {
        var swiper = this;
        if (swiper.initialized) return swiper;
        var mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit("beforeInit");
        if (swiper.params.breakpoints) {
            swiper.setBreakpoint();
        }
        swiper.addClasses();
        if (swiper.params.loop) {
            swiper.loopCreate();
        }
        swiper.updateSize();
        swiper.updateSlides();
        if (swiper.params.watchOverflow) {
            swiper.checkOverflow();
        }
        if (swiper.params.grabCursor && swiper.enabled) {
            swiper.setGrabCursor();
        }
        if (swiper.params.preloadImages) {
            swiper.preloadImages();
        }
        if (swiper.params.loop) {
            swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
            swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        }
        swiper.attachEvents();
        swiper.initialized = true;
        swiper.emit("init");
        swiper.emit("afterInit");
        return swiper;
    };
    _proto.destroy = function destroy20(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
            deleteInstance = true;
        }
        if (cleanStyles === void 0) {
            cleanStyles = true;
        }
        var swiper = this;
        var params = swiper.params, $el = swiper.$el, $wrapperEl = swiper.$wrapperEl, slides = swiper.slides;
        if (typeof swiper.params === "undefined" || swiper.destroyed) {
            return null;
        }
        swiper.emit("beforeDestroy");
        swiper.initialized = false;
        swiper.detachEvents();
        if (params.loop) {
            swiper.loopDestroy();
        }
        if (cleanStyles) {
            swiper.removeClasses();
            $el.removeAttr("style");
            $wrapperEl.removeAttr("style");
            if (slides && slides.length) {
                slides.removeClass([
                    params.slideVisibleClass,
                    params.slideActiveClass,
                    params.slideNextClass,
                    params.slidePrevClass
                ].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
            }
        }
        swiper.emit("destroy");
        Object.keys(swiper.eventsListeners).forEach(function(eventName) {
            swiper.off(eventName);
        });
        if (deleteInstance !== false) {
            swiper.$el[0].swiper = null;
            deleteProps(swiper);
        }
        swiper.destroyed = true;
        return null;
    };
    Swiper2.extendDefaults = function extendDefaults(newDefaults) {
        extend(extendedDefaults, newDefaults);
    };
    Swiper2.installModule = function installModule(module) {
        if (!Swiper2.prototype.modules) Swiper2.prototype.modules = {};
        var name = module.name || Object.keys(Swiper2.prototype.modules).length + "_" + now();
        Swiper2.prototype.modules[name] = module;
    };
    Swiper2.use = function use(module) {
        if (Array.isArray(module)) {
            module.forEach(function(m) {
                return Swiper2.installModule(m);
            });
            return Swiper2;
        }
        Swiper2.installModule(module);
        return Swiper2;
    };
    _createClass2(Swiper2, null, [
        {
            key: "extendedDefaults",
            get: function get2() {
                return extendedDefaults;
            }
        },
        {
            key: "defaults",
            get: function get2() {
                return defaults;
            }
        }
    ]);
    return Swiper2;
}();
Object.keys(prototypes).forEach(function(prototypeGroup) {
    Object.keys(prototypes[prototypeGroup]).forEach(function(protoMethod) {
        Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
});
Swiper$1.use([
    Resize,
    Observer$1
]);
function _extends$h() {
    _extends$h = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$h.apply(this, arguments);
}
var Virtual = {
    update: function update2(force) {
        var swiper = this;
        var _swiper$params = swiper.params, slidesPerView = _swiper$params.slidesPerView, slidesPerGroup = _swiper$params.slidesPerGroup, centeredSlides = _swiper$params.centeredSlides;
        var _swiper$params$virtua = swiper.params.virtual, addSlidesBefore = _swiper$params$virtua.addSlidesBefore, addSlidesAfter = _swiper$params$virtua.addSlidesAfter;
        var _swiper$virtual = swiper.virtual, previousFrom = _swiper$virtual.from, previousTo = _swiper$virtual.to, slides = _swiper$virtual.slides, previousSlidesGrid = _swiper$virtual.slidesGrid, renderSlide2 = _swiper$virtual.renderSlide, previousOffset = _swiper$virtual.offset;
        swiper.updateActiveIndex();
        var activeIndex = swiper.activeIndex || 0;
        var offsetProp;
        if (swiper.rtlTranslate) offsetProp = "right";
        else offsetProp = swiper.isHorizontal() ? "left" : "top";
        var slidesAfter;
        var slidesBefore;
        if (centeredSlides) {
            slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
            slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
        } else {
            slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
            slidesBefore = slidesPerGroup + addSlidesBefore;
        }
        var from = Math.max((activeIndex || 0) - slidesBefore, 0);
        var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
        var offset2 = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
        extend(swiper.virtual, {
            from,
            to,
            offset: offset2,
            slidesGrid: swiper.slidesGrid
        });
        function onRendered() {
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
            if (swiper.lazy && swiper.params.lazy.enabled) {
                swiper.lazy.load();
            }
        }
        if (previousFrom === from && previousTo === to && !force) {
            if (swiper.slidesGrid !== previousSlidesGrid && offset2 !== previousOffset) {
                swiper.slides.css(offsetProp, offset2 + "px");
            }
            swiper.updateProgress();
            return;
        }
        if (swiper.params.virtual.renderExternal) {
            swiper.params.virtual.renderExternal.call(swiper, {
                offset: offset2,
                from,
                to,
                slides: function getSlides() {
                    var slidesToRender = [];
                    for(var i3 = from; i3 <= to; i3 += 1){
                        slidesToRender.push(slides[i3]);
                    }
                    return slidesToRender;
                }()
            });
            if (swiper.params.virtual.renderExternalUpdate) {
                onRendered();
            }
            return;
        }
        var prependIndexes = [];
        var appendIndexes = [];
        if (force) {
            swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
        } else {
            for(var i2 = previousFrom; i2 <= previousTo; i2 += 1){
                if (i2 < from || i2 > to) {
                    swiper.$wrapperEl.find("." + swiper.params.slideClass + '[data-swiper-slide-index="' + i2 + '"]').remove();
                }
            }
        }
        for(var _i = 0; _i < slides.length; _i += 1){
            if (_i >= from && _i <= to) {
                if (typeof previousTo === "undefined" || force) {
                    appendIndexes.push(_i);
                } else {
                    if (_i > previousTo) appendIndexes.push(_i);
                    if (_i < previousFrom) prependIndexes.push(_i);
                }
            }
        }
        appendIndexes.forEach(function(index2) {
            swiper.$wrapperEl.append(renderSlide2(slides[index2], index2));
        });
        prependIndexes.sort(function(a, b) {
            return b - a;
        }).forEach(function(index2) {
            swiper.$wrapperEl.prepend(renderSlide2(slides[index2], index2));
        });
        swiper.$wrapperEl.children(".swiper-slide").css(offsetProp, offset2 + "px");
        onRendered();
    },
    renderSlide: function renderSlide(slide2, index2) {
        var swiper = this;
        var params = swiper.params.virtual;
        if (params.cache && swiper.virtual.cache[index2]) {
            return swiper.virtual.cache[index2];
        }
        var $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide2, index2)) : $('<div class="' + swiper.params.slideClass + '" data-swiper-slide-index="' + index2 + '">' + slide2 + "</div>");
        if (!$slideEl.attr("data-swiper-slide-index")) $slideEl.attr("data-swiper-slide-index", index2);
        if (params.cache) swiper.virtual.cache[index2] = $slideEl;
        return $slideEl;
    },
    appendSlide: function appendSlide2(slides) {
        var swiper = this;
        if (typeof slides === "object" && "length" in slides) {
            for(var i2 = 0; i2 < slides.length; i2 += 1){
                if (slides[i2]) swiper.virtual.slides.push(slides[i2]);
            }
        } else {
            swiper.virtual.slides.push(slides);
        }
        swiper.virtual.update(true);
    },
    prependSlide: function prependSlide2(slides) {
        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var newActiveIndex = activeIndex + 1;
        var numberOfNewSlides = 1;
        if (Array.isArray(slides)) {
            for(var i2 = 0; i2 < slides.length; i2 += 1){
                if (slides[i2]) swiper.virtual.slides.unshift(slides[i2]);
            }
            newActiveIndex = activeIndex + slides.length;
            numberOfNewSlides = slides.length;
        } else {
            swiper.virtual.slides.unshift(slides);
        }
        if (swiper.params.virtual.cache) {
            var cache2 = swiper.virtual.cache;
            var newCache = {};
            Object.keys(cache2).forEach(function(cachedIndex) {
                var $cachedEl = cache2[cachedIndex];
                var cachedElIndex = $cachedEl.attr("data-swiper-slide-index");
                if (cachedElIndex) {
                    $cachedEl.attr("data-swiper-slide-index", parseInt(cachedElIndex, 10) + 1);
                }
                newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
            });
            swiper.virtual.cache = newCache;
        }
        swiper.virtual.update(true);
        swiper.slideTo(newActiveIndex, 0);
    },
    removeSlide: function removeSlide2(slidesIndexes) {
        var swiper = this;
        if (typeof slidesIndexes === "undefined" || slidesIndexes === null) return;
        var activeIndex = swiper.activeIndex;
        if (Array.isArray(slidesIndexes)) {
            for(var i2 = slidesIndexes.length - 1; i2 >= 0; i2 -= 1){
                swiper.virtual.slides.splice(slidesIndexes[i2], 1);
                if (swiper.params.virtual.cache) {
                    delete swiper.virtual.cache[slidesIndexes[i2]];
                }
                if (slidesIndexes[i2] < activeIndex) activeIndex -= 1;
                activeIndex = Math.max(activeIndex, 0);
            }
        } else {
            swiper.virtual.slides.splice(slidesIndexes, 1);
            if (swiper.params.virtual.cache) {
                delete swiper.virtual.cache[slidesIndexes];
            }
            if (slidesIndexes < activeIndex) activeIndex -= 1;
            activeIndex = Math.max(activeIndex, 0);
        }
        swiper.virtual.update(true);
        swiper.slideTo(activeIndex, 0);
    },
    removeAllSlides: function removeAllSlides2() {
        var swiper = this;
        swiper.virtual.slides = [];
        if (swiper.params.virtual.cache) {
            swiper.virtual.cache = {};
        }
        swiper.virtual.update(true);
        swiper.slideTo(0, 0);
    }
};
var Virtual$1 = {
    name: "virtual",
    params: {
        virtual: {
            enabled: false,
            slides: [],
            cache: true,
            renderSlide: null,
            renderExternal: null,
            renderExternalUpdate: true,
            addSlidesBefore: 0,
            addSlidesAfter: 0
        }
    },
    create: function create3() {
        var swiper = this;
        bindModuleMethods(swiper, {
            virtual: _extends$h({}, Virtual, {
                slides: swiper.params.virtual.slides,
                cache: {}
            })
        });
    },
    on: {
        beforeInit: function beforeInit(swiper) {
            if (!swiper.params.virtual.enabled) return;
            swiper.classNames.push(swiper.params.containerModifierClass + "virtual");
            var overwriteParams = {
                watchSlidesProgress: true
            };
            extend(swiper.params, overwriteParams);
            extend(swiper.originalParams, overwriteParams);
            if (!swiper.params.initialSlide) {
                swiper.virtual.update();
            }
        },
        setTranslate: function setTranslate2(swiper) {
            if (!swiper.params.virtual.enabled) return;
            swiper.virtual.update();
        }
    }
};
function _extends$g() {
    _extends$g = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$g.apply(this, arguments);
}
var Keyboard = {
    handle: function handle(event2) {
        var swiper = this;
        if (!swiper.enabled) return;
        var window2 = getWindow();
        var document2 = getDocument();
        var rtl = swiper.rtlTranslate;
        var e = event2;
        if (e.originalEvent) e = e.originalEvent;
        var kc = e.keyCode || e.charCode;
        var pageUpDown = swiper.params.keyboard.pageUpDown;
        var isPageUp = pageUpDown && kc === 33;
        var isPageDown = pageUpDown && kc === 34;
        var isArrowLeft = kc === 37;
        var isArrowRight = kc === 39;
        var isArrowUp = kc === 38;
        var isArrowDown = kc === 40;
        if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
            return false;
        }
        if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
            return false;
        }
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
            return void 0;
        }
        if (document2.activeElement && document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === "input" || document2.activeElement.nodeName.toLowerCase() === "textarea")) {
            return void 0;
        }
        if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
            var inView = false;
            if (swiper.$el.parents("." + swiper.params.slideClass).length > 0 && swiper.$el.parents("." + swiper.params.slideActiveClass).length === 0) {
                return void 0;
            }
            var $el = swiper.$el;
            var swiperWidth = $el[0].clientWidth;
            var swiperHeight = $el[0].clientHeight;
            var windowWidth = window2.innerWidth;
            var windowHeight = window2.innerHeight;
            var swiperOffset = swiper.$el.offset();
            if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
            var swiperCoord = [
                [
                    swiperOffset.left,
                    swiperOffset.top
                ],
                [
                    swiperOffset.left + swiperWidth,
                    swiperOffset.top
                ],
                [
                    swiperOffset.left,
                    swiperOffset.top + swiperHeight
                ],
                [
                    swiperOffset.left + swiperWidth,
                    swiperOffset.top + swiperHeight
                ]
            ];
            for(var i2 = 0; i2 < swiperCoord.length; i2 += 1){
                var point = swiperCoord[i2];
                if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                    if (point[0] === 0 && point[1] === 0) continue;
                    inView = true;
                }
            }
            if (!inView) return void 0;
        }
        if (swiper.isHorizontal()) {
            if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            }
            if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
            if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
        } else {
            if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            }
            if (isPageDown || isArrowDown) swiper.slideNext();
            if (isPageUp || isArrowUp) swiper.slidePrev();
        }
        swiper.emit("keyPress", kc);
        return void 0;
    },
    enable: function enable() {
        var swiper = this;
        var document2 = getDocument();
        if (swiper.keyboard.enabled) return;
        $(document2).on("keydown", swiper.keyboard.handle);
        swiper.keyboard.enabled = true;
    },
    disable: function disable() {
        var swiper = this;
        var document2 = getDocument();
        if (!swiper.keyboard.enabled) return;
        $(document2).off("keydown", swiper.keyboard.handle);
        swiper.keyboard.enabled = false;
    }
};
var Keyboard$1 = {
    name: "keyboard",
    params: {
        keyboard: {
            enabled: false,
            onlyInViewport: true,
            pageUpDown: true
        }
    },
    create: function create4() {
        var swiper = this;
        bindModuleMethods(swiper, {
            keyboard: _extends$g({
                enabled: false
            }, Keyboard)
        });
    },
    on: {
        init: function init4(swiper) {
            if (swiper.params.keyboard.enabled) {
                swiper.keyboard.enable();
            }
        },
        destroy: function destroy4(swiper) {
            if (swiper.keyboard.enabled) {
                swiper.keyboard.disable();
            }
        }
    }
};
function isEventSupported() {
    var document2 = getDocument();
    var eventName = "onwheel";
    var isSupported = eventName in document2;
    if (!isSupported) {
        var element = document2.createElement("div");
        element.setAttribute(eventName, "return;");
        isSupported = typeof element[eventName] === "function";
    }
    if (!isSupported && document2.implementation && document2.implementation.hasFeature && document2.implementation.hasFeature("", "") !== true) {
        isSupported = document2.implementation.hasFeature("Events.wheel", "3.0");
    }
    return isSupported;
}
var Mousewheel = {
    lastScrollTime: now(),
    lastEventBeforeSnap: void 0,
    recentWheelEvents: [],
    event: function event() {
        var window2 = getWindow();
        if (window2.navigator.userAgent.indexOf("firefox") > -1) return "DOMMouseScroll";
        return isEventSupported() ? "wheel" : "mousewheel";
    },
    normalize: function normalize(e) {
        var PIXEL_STEP = 10;
        var LINE_HEIGHT = 40;
        var PAGE_HEIGHT = 800;
        var sX = 0;
        var sY = 0;
        var pX = 0;
        var pY = 0;
        if ("detail" in e) {
            sY = e.detail;
        }
        if ("wheelDelta" in e) {
            sY = -e.wheelDelta / 120;
        }
        if ("wheelDeltaY" in e) {
            sY = -e.wheelDeltaY / 120;
        }
        if ("wheelDeltaX" in e) {
            sX = -e.wheelDeltaX / 120;
        }
        if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
            sX = sY;
            sY = 0;
        }
        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;
        if ("deltaY" in e) {
            pY = e.deltaY;
        }
        if ("deltaX" in e) {
            pX = e.deltaX;
        }
        if (e.shiftKey && !pX) {
            pX = pY;
            pY = 0;
        }
        if ((pX || pY) && e.deltaMode) {
            if (e.deltaMode === 1) {
                pX *= LINE_HEIGHT;
                pY *= LINE_HEIGHT;
            } else {
                pX *= PAGE_HEIGHT;
                pY *= PAGE_HEIGHT;
            }
        }
        if (pX && !sX) {
            sX = pX < 1 ? -1 : 1;
        }
        if (pY && !sY) {
            sY = pY < 1 ? -1 : 1;
        }
        return {
            spinX: sX,
            spinY: sY,
            pixelX: pX,
            pixelY: pY
        };
    },
    handleMouseEnter: function handleMouseEnter() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.mouseEntered = true;
    },
    handleMouseLeave: function handleMouseLeave() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.mouseEntered = false;
    },
    handle: function handle2(event2) {
        var e = event2;
        var disableParentSwiper = true;
        var swiper = this;
        if (!swiper.enabled) return;
        var params = swiper.params.mousewheel;
        if (swiper.params.cssMode) {
            e.preventDefault();
        }
        var target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== "container") {
            target = $(swiper.params.mousewheel.eventsTarget);
        }
        if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;
        if (e.originalEvent) e = e.originalEvent;
        var delta = 0;
        var rtlFactor = swiper.rtlTranslate ? -1 : 1;
        var data = Mousewheel.normalize(e);
        if (params.forceToAxis) {
            if (swiper.isHorizontal()) {
                if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
                else return true;
            } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
            else return true;
        } else {
            delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
        }
        if (delta === 0) return true;
        if (params.invert) delta = -delta;
        var positions = swiper.getTranslate() + delta * params.sensitivity;
        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();
        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
        if (!swiper.params.freeMode) {
            var newEvent = {
                time: now(),
                delta: Math.abs(delta),
                direction: Math.sign(delta),
                raw: event2
            };
            var recentWheelEvents = swiper.mousewheel.recentWheelEvents;
            if (recentWheelEvents.length >= 2) {
                recentWheelEvents.shift();
            }
            var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
            recentWheelEvents.push(newEvent);
            if (prevEvent) {
                if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                    swiper.mousewheel.animateSlider(newEvent);
                }
            } else {
                swiper.mousewheel.animateSlider(newEvent);
            }
            if (swiper.mousewheel.releaseScroll(newEvent)) {
                return true;
            }
        } else {
            var _newEvent = {
                time: now(),
                delta: Math.abs(delta),
                direction: Math.sign(delta)
            };
            var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;
            var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;
            if (!ignoreWheelEvents) {
                swiper.mousewheel.lastEventBeforeSnap = void 0;
                if (swiper.params.loop) {
                    swiper.loopFix();
                }
                var position = swiper.getTranslate() + delta * params.sensitivity;
                var wasBeginning = swiper.isBeginning;
                var wasEnd = swiper.isEnd;
                if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                swiper.setTransition(0);
                swiper.setTranslate(position);
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
                if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                    swiper.updateSlidesClasses();
                }
                if (swiper.params.freeModeSticky) {
                    clearTimeout(swiper.mousewheel.timeout);
                    swiper.mousewheel.timeout = void 0;
                    var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;
                    if (_recentWheelEvents.length >= 15) {
                        _recentWheelEvents.shift();
                    }
                    var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : void 0;
                    var firstEvent = _recentWheelEvents[0];
                    _recentWheelEvents.push(_newEvent);
                    if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {
                        _recentWheelEvents.splice(0);
                    } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {
                        var snapToThreshold = delta > 0 ? 0.8 : 0.2;
                        swiper.mousewheel.lastEventBeforeSnap = _newEvent;
                        _recentWheelEvents.splice(0);
                        swiper.mousewheel.timeout = nextTick3(function() {
                            swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
                        }, 0);
                    }
                    if (!swiper.mousewheel.timeout) {
                        swiper.mousewheel.timeout = nextTick3(function() {
                            var snapToThreshold2 = 0.5;
                            swiper.mousewheel.lastEventBeforeSnap = _newEvent;
                            _recentWheelEvents.splice(0);
                            swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold2);
                        }, 500);
                    }
                }
                if (!ignoreWheelEvents) swiper.emit("scroll", e);
                if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
                if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
            }
        }
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        return false;
    },
    animateSlider: function animateSlider(newEvent) {
        var swiper = this;
        var window2 = getWindow();
        if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {
            return false;
        }
        if (this.params.mousewheel.thresholdTime && now() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {
            return false;
        }
        if (newEvent.delta >= 6 && now() - swiper.mousewheel.lastScrollTime < 60) {
            return true;
        }
        if (newEvent.direction < 0) {
            if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                swiper.slideNext();
                swiper.emit("scroll", newEvent.raw);
            }
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
            swiper.slidePrev();
            swiper.emit("scroll", newEvent.raw);
        }
        swiper.mousewheel.lastScrollTime = new window2.Date().getTime();
        return false;
    },
    releaseScroll: function releaseScroll(newEvent) {
        var swiper = this;
        var params = swiper.params.mousewheel;
        if (newEvent.direction < 0) {
            if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                return true;
            }
        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
            return true;
        }
        return false;
    },
    enable: function enable2() {
        var swiper = this;
        var event2 = Mousewheel.event();
        if (swiper.params.cssMode) {
            swiper.wrapperEl.removeEventListener(event2, swiper.mousewheel.handle);
            return true;
        }
        if (!event2) return false;
        if (swiper.mousewheel.enabled) return false;
        var target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== "container") {
            target = $(swiper.params.mousewheel.eventsTarget);
        }
        target.on("mouseenter", swiper.mousewheel.handleMouseEnter);
        target.on("mouseleave", swiper.mousewheel.handleMouseLeave);
        target.on(event2, swiper.mousewheel.handle);
        swiper.mousewheel.enabled = true;
        return true;
    },
    disable: function disable2() {
        var swiper = this;
        var event2 = Mousewheel.event();
        if (swiper.params.cssMode) {
            swiper.wrapperEl.addEventListener(event2, swiper.mousewheel.handle);
            return true;
        }
        if (!event2) return false;
        if (!swiper.mousewheel.enabled) return false;
        var target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== "container") {
            target = $(swiper.params.mousewheel.eventsTarget);
        }
        target.off(event2, swiper.mousewheel.handle);
        swiper.mousewheel.enabled = false;
        return true;
    }
};
var Mousewheel$1 = {
    name: "mousewheel",
    params: {
        mousewheel: {
            enabled: false,
            releaseOnEdges: false,
            invert: false,
            forceToAxis: false,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null
        }
    },
    create: function create5() {
        var swiper = this;
        bindModuleMethods(swiper, {
            mousewheel: {
                enabled: false,
                lastScrollTime: now(),
                lastEventBeforeSnap: void 0,
                recentWheelEvents: [],
                enable: Mousewheel.enable,
                disable: Mousewheel.disable,
                handle: Mousewheel.handle,
                handleMouseEnter: Mousewheel.handleMouseEnter,
                handleMouseLeave: Mousewheel.handleMouseLeave,
                animateSlider: Mousewheel.animateSlider,
                releaseScroll: Mousewheel.releaseScroll
            }
        });
    },
    on: {
        init: function init5(swiper) {
            if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
                swiper.mousewheel.disable();
            }
            if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
        },
        destroy: function destroy5(swiper) {
            if (swiper.params.cssMode) {
                swiper.mousewheel.enable();
            }
            if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
        }
    }
};
function _extends$f() {
    _extends$f = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$f.apply(this, arguments);
}
var Navigation = {
    toggleEl: function toggleEl($el, disabled) {
        $el[disabled ? "addClass" : "removeClass"](this.params.navigation.disabledClass);
        if ($el[0] && $el[0].tagName === "BUTTON") $el[0].disabled = disabled;
    },
    update: function update3() {
        var swiper = this;
        var params = swiper.params.navigation;
        var toggleEl2 = swiper.navigation.toggleEl;
        if (swiper.params.loop) return;
        var _swiper$navigation = swiper.navigation, $nextEl = _swiper$navigation.$nextEl, $prevEl = _swiper$navigation.$prevEl;
        if ($prevEl && $prevEl.length > 0) {
            if (swiper.isBeginning) {
                toggleEl2($prevEl, true);
            } else {
                toggleEl2($prevEl, false);
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                $prevEl[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
            }
        }
        if ($nextEl && $nextEl.length > 0) {
            if (swiper.isEnd) {
                toggleEl2($nextEl, true);
            } else {
                toggleEl2($nextEl, false);
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                $nextEl[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
            }
        }
    },
    onPrevClick: function onPrevClick(e) {
        var swiper = this;
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop) return;
        swiper.slidePrev();
    },
    onNextClick: function onNextClick(e) {
        var swiper = this;
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop) return;
        swiper.slideNext();
    },
    init: function init6() {
        var swiper = this;
        var params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper.$el, swiper.params.navigation, swiper.params.createElements, {
            nextEl: "swiper-button-next",
            prevEl: "swiper-button-prev"
        });
        if (!(params.nextEl || params.prevEl)) return;
        var $nextEl;
        var $prevEl;
        if (params.nextEl) {
            $nextEl = $(params.nextEl);
            if (swiper.params.uniqueNavElements && typeof params.nextEl === "string" && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
                $nextEl = swiper.$el.find(params.nextEl);
            }
        }
        if (params.prevEl) {
            $prevEl = $(params.prevEl);
            if (swiper.params.uniqueNavElements && typeof params.prevEl === "string" && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
                $prevEl = swiper.$el.find(params.prevEl);
            }
        }
        if ($nextEl && $nextEl.length > 0) {
            $nextEl.on("click", swiper.navigation.onNextClick);
        }
        if ($prevEl && $prevEl.length > 0) {
            $prevEl.on("click", swiper.navigation.onPrevClick);
        }
        extend(swiper.navigation, {
            $nextEl,
            nextEl: $nextEl && $nextEl[0],
            $prevEl,
            prevEl: $prevEl && $prevEl[0]
        });
        if (!swiper.enabled) {
            if ($nextEl) $nextEl.addClass(params.lockClass);
            if ($prevEl) $prevEl.addClass(params.lockClass);
        }
    },
    destroy: function destroy6() {
        var swiper = this;
        var _swiper$navigation2 = swiper.navigation, $nextEl = _swiper$navigation2.$nextEl, $prevEl = _swiper$navigation2.$prevEl;
        if ($nextEl && $nextEl.length) {
            $nextEl.off("click", swiper.navigation.onNextClick);
            $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }
        if ($prevEl && $prevEl.length) {
            $prevEl.off("click", swiper.navigation.onPrevClick);
            $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
    }
};
var Navigation$1 = {
    name: "navigation",
    params: {
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: false,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock"
        }
    },
    create: function create6() {
        var swiper = this;
        bindModuleMethods(swiper, {
            navigation: _extends$f({}, Navigation)
        });
    },
    on: {
        init: function init7(swiper) {
            swiper.navigation.init();
            swiper.navigation.update();
        },
        toEdge: function toEdge(swiper) {
            swiper.navigation.update();
        },
        fromEdge: function fromEdge(swiper) {
            swiper.navigation.update();
        },
        destroy: function destroy7(swiper) {
            swiper.navigation.destroy();
        },
        "enable disable": function enableDisable(swiper) {
            var _swiper$navigation3 = swiper.navigation, $nextEl = _swiper$navigation3.$nextEl, $prevEl = _swiper$navigation3.$prevEl;
            if ($nextEl) {
                $nextEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
            }
            if ($prevEl) {
                $prevEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
            }
        },
        click: function click(swiper, e) {
            var _swiper$navigation4 = swiper.navigation, $nextEl = _swiper$navigation4.$nextEl, $prevEl = _swiper$navigation4.$prevEl;
            var targetEl = e.target;
            if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
                if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                var isHidden;
                if ($nextEl) {
                    isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
                } else if ($prevEl) {
                    isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
                }
                if (isHidden === true) {
                    swiper.emit("navigationShow");
                } else {
                    swiper.emit("navigationHide");
                }
                if ($nextEl) {
                    $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
                if ($prevEl) {
                    $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
            }
        }
    }
};
function _extends$e() {
    _extends$e = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$e.apply(this, arguments);
}
var Pagination = {
    update: function update4() {
        var swiper = this;
        var rtl = swiper.rtl;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el;
        var current;
        var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.loop) {
            current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
            if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
                current -= slidesLength - swiper.loopedSlides * 2;
            }
            if (current > total - 1) current -= total;
            if (current < 0 && swiper.params.paginationType !== "bullets") current = total + current;
        } else if (typeof swiper.snapIndex !== "undefined") {
            current = swiper.snapIndex;
        } else {
            current = swiper.activeIndex || 0;
        }
        if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
            var bullets = swiper.pagination.bullets;
            var firstIndex;
            var lastIndex;
            var midIndex;
            if (params.dynamicBullets) {
                swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
                $el.css(swiper.isHorizontal() ? "width" : "height", swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");
                if (params.dynamicMainBullets > 1 && swiper.previousIndex !== void 0) {
                    swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;
                    if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
                        swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
                    } else if (swiper.pagination.dynamicBulletIndex < 0) {
                        swiper.pagination.dynamicBulletIndex = 0;
                    }
                }
                firstIndex = current - swiper.pagination.dynamicBulletIndex;
                lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                midIndex = (lastIndex + firstIndex) / 2;
            }
            bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");
            if ($el.length > 1) {
                bullets.each(function(bullet) {
                    var $bullet2 = $(bullet);
                    var bulletIndex2 = $bullet2.index();
                    if (bulletIndex2 === current) {
                        $bullet2.addClass(params.bulletActiveClass);
                    }
                    if (params.dynamicBullets) {
                        if (bulletIndex2 >= firstIndex && bulletIndex2 <= lastIndex) {
                            $bullet2.addClass(params.bulletActiveClass + "-main");
                        }
                        if (bulletIndex2 === firstIndex) {
                            $bullet2.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                        }
                        if (bulletIndex2 === lastIndex) {
                            $bullet2.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                        }
                    }
                });
            } else {
                var $bullet = bullets.eq(current);
                var bulletIndex = $bullet.index();
                $bullet.addClass(params.bulletActiveClass);
                if (params.dynamicBullets) {
                    var $firstDisplayedBullet = bullets.eq(firstIndex);
                    var $lastDisplayedBullet = bullets.eq(lastIndex);
                    for(var i2 = firstIndex; i2 <= lastIndex; i2 += 1){
                        bullets.eq(i2).addClass(params.bulletActiveClass + "-main");
                    }
                    if (swiper.params.loop) {
                        if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                            for(var _i = params.dynamicMainBullets; _i >= 0; _i -= 1){
                                bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + "-main");
                            }
                            bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
                        } else {
                            $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                            $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                        }
                    } else {
                        $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                        $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                    }
                }
            }
            if (params.dynamicBullets) {
                var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
                var offsetProp = rtl ? "right" : "left";
                bullets.css(swiper.isHorizontal() ? offsetProp : "top", bulletsOffset + "px");
            }
        }
        if (params.type === "fraction") {
            $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
            $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }
        if (params.type === "progressbar") {
            var progressbarDirection;
            if (params.progressbarOpposite) {
                progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
            } else {
                progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
            }
            var scale = (current + 1) / total;
            var scaleX = 1;
            var scaleY = 1;
            if (progressbarDirection === "horizontal") {
                scaleX = scale;
            } else {
                scaleY = scale;
            }
            $el.find(classesToSelector(params.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
        }
        if (params.type === "custom" && params.renderCustom) {
            $el.html(params.renderCustom(swiper, current + 1, total));
            swiper.emit("paginationRender", $el[0]);
        } else {
            swiper.emit("paginationUpdate", $el[0]);
        }
        if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
        }
    },
    render: function render() {
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el;
        var paginationHTML = "";
        if (params.type === "bullets") {
            var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {
                numberOfBullets = slidesLength;
            }
            for(var i2 = 0; i2 < numberOfBullets; i2 += 1){
                if (params.renderBullet) {
                    paginationHTML += params.renderBullet.call(swiper, i2, params.bulletClass);
                } else {
                    paginationHTML += "<" + params.bulletElement + ' class="' + params.bulletClass + '"></' + params.bulletElement + ">";
                }
            }
            $el.html(paginationHTML);
            swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }
        if (params.type === "fraction") {
            if (params.renderFraction) {
                paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
            } else {
                paginationHTML = '<span class="' + params.currentClass + '"></span> / ' + ('<span class="' + params.totalClass + '"></span>');
            }
            $el.html(paginationHTML);
        }
        if (params.type === "progressbar") {
            if (params.renderProgressbar) {
                paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
            } else {
                paginationHTML = '<span class="' + params.progressbarFillClass + '"></span>';
            }
            $el.html(paginationHTML);
        }
        if (params.type !== "custom") {
            swiper.emit("paginationRender", swiper.pagination.$el[0]);
        }
    },
    init: function init8() {
        var swiper = this;
        swiper.params.pagination = createElementIfNotDefined(swiper.$el, swiper.params.pagination, swiper.params.createElements, {
            el: "swiper-pagination"
        });
        var params = swiper.params.pagination;
        if (!params.el) return;
        var $el = $(params.el);
        if ($el.length === 0) return;
        if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1) {
            $el = swiper.$el.find(params.el);
        }
        if (params.type === "bullets" && params.clickable) {
            $el.addClass(params.clickableClass);
        }
        $el.addClass(params.modifierClass + params.type);
        if (params.type === "bullets" && params.dynamicBullets) {
            $el.addClass("" + params.modifierClass + params.type + "-dynamic");
            swiper.pagination.dynamicBulletIndex = 0;
            if (params.dynamicMainBullets < 1) {
                params.dynamicMainBullets = 1;
            }
        }
        if (params.type === "progressbar" && params.progressbarOpposite) {
            $el.addClass(params.progressbarOppositeClass);
        }
        if (params.clickable) {
            $el.on("click", classesToSelector(params.bulletClass), function onClick2(e) {
                e.preventDefault();
                var index2 = $(this).index() * swiper.params.slidesPerGroup;
                if (swiper.params.loop) index2 += swiper.loopedSlides;
                swiper.slideTo(index2);
            });
        }
        extend(swiper.pagination, {
            $el,
            el: $el[0]
        });
        if (!swiper.enabled) {
            $el.addClass(params.lockClass);
        }
    },
    destroy: function destroy8() {
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
        if (params.clickable) {
            $el.off("click", classesToSelector(params.bulletClass));
        }
    }
};
var Pagination$1 = {
    name: "pagination",
    params: {
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: false,
            hideOnClick: false,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: false,
            type: "bullets",
            dynamicBullets: false,
            dynamicMainBullets: 1,
            formatFractionCurrent: function formatFractionCurrent(number) {
                return number;
            },
            formatFractionTotal: function formatFractionTotal(number) {
                return number;
            },
            bulletClass: "swiper-pagination-bullet",
            bulletActiveClass: "swiper-pagination-bullet-active",
            modifierClass: "swiper-pagination-",
            currentClass: "swiper-pagination-current",
            totalClass: "swiper-pagination-total",
            hiddenClass: "swiper-pagination-hidden",
            progressbarFillClass: "swiper-pagination-progressbar-fill",
            progressbarOppositeClass: "swiper-pagination-progressbar-opposite",
            clickableClass: "swiper-pagination-clickable",
            lockClass: "swiper-pagination-lock"
        }
    },
    create: function create7() {
        var swiper = this;
        bindModuleMethods(swiper, {
            pagination: _extends$e({
                dynamicBulletIndex: 0
            }, Pagination)
        });
    },
    on: {
        init: function init9(swiper) {
            swiper.pagination.init();
            swiper.pagination.render();
            swiper.pagination.update();
        },
        activeIndexChange: function activeIndexChange(swiper) {
            if (swiper.params.loop) {
                swiper.pagination.update();
            } else if (typeof swiper.snapIndex === "undefined") {
                swiper.pagination.update();
            }
        },
        snapIndexChange: function snapIndexChange(swiper) {
            if (!swiper.params.loop) {
                swiper.pagination.update();
            }
        },
        slidesLengthChange: function slidesLengthChange(swiper) {
            if (swiper.params.loop) {
                swiper.pagination.render();
                swiper.pagination.update();
            }
        },
        snapGridLengthChange: function snapGridLengthChange(swiper) {
            if (!swiper.params.loop) {
                swiper.pagination.render();
                swiper.pagination.update();
            }
        },
        destroy: function destroy9(swiper) {
            swiper.pagination.destroy();
        },
        "enable disable": function enableDisable2(swiper) {
            var $el = swiper.pagination.$el;
            if ($el) {
                $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.pagination.lockClass);
            }
        },
        click: function click2(swiper, e) {
            var targetEl = e.target;
            if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
                if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
                if (isHidden === true) {
                    swiper.emit("paginationShow");
                } else {
                    swiper.emit("paginationHide");
                }
                swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
            }
        }
    }
};
function _extends$d() {
    _extends$d = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$d.apply(this, arguments);
}
var Scrollbar = {
    setTranslate: function setTranslate3() {
        var swiper = this;
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        var scrollbar = swiper.scrollbar, rtl = swiper.rtlTranslate, progress = swiper.progress;
        var dragSize = scrollbar.dragSize, trackSize = scrollbar.trackSize, $dragEl = scrollbar.$dragEl, $el = scrollbar.$el;
        var params = swiper.params.scrollbar;
        var newSize = dragSize;
        var newPos = (trackSize - dragSize) * progress;
        if (rtl) {
            newPos = -newPos;
            if (newPos > 0) {
                newSize = dragSize - newPos;
                newPos = 0;
            } else if (-newPos + dragSize > trackSize) {
                newSize = trackSize + newPos;
            }
        } else if (newPos < 0) {
            newSize = dragSize + newPos;
            newPos = 0;
        } else if (newPos + dragSize > trackSize) {
            newSize = trackSize - newPos;
        }
        if (swiper.isHorizontal()) {
            $dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
            $dragEl[0].style.width = newSize + "px";
        } else {
            $dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
            $dragEl[0].style.height = newSize + "px";
        }
        if (params.hide) {
            clearTimeout(swiper.scrollbar.timeout);
            $el[0].style.opacity = 1;
            swiper.scrollbar.timeout = setTimeout(function() {
                $el[0].style.opacity = 0;
                $el.transition(400);
            }, 1e3);
        }
    },
    setTransition: function setTransition2(duration) {
        var swiper = this;
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.$dragEl.transition(duration);
    },
    updateSize: function updateSize2() {
        var swiper = this;
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        var scrollbar = swiper.scrollbar;
        var $dragEl = scrollbar.$dragEl, $el = scrollbar.$el;
        $dragEl[0].style.width = "";
        $dragEl[0].style.height = "";
        var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
        var divider = swiper.size / swiper.virtualSize;
        var moveDivider = divider * (trackSize / swiper.size);
        var dragSize;
        if (swiper.params.scrollbar.dragSize === "auto") {
            dragSize = trackSize * divider;
        } else {
            dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }
        if (swiper.isHorizontal()) {
            $dragEl[0].style.width = dragSize + "px";
        } else {
            $dragEl[0].style.height = dragSize + "px";
        }
        if (divider >= 1) {
            $el[0].style.display = "none";
        } else {
            $el[0].style.display = "";
        }
        if (swiper.params.scrollbar.hide) {
            $el[0].style.opacity = 0;
        }
        extend(scrollbar, {
            trackSize,
            divider,
            moveDivider,
            dragSize
        });
        if (swiper.params.watchOverflow && swiper.enabled) {
            scrollbar.$el[swiper.isLocked ? "addClass" : "removeClass"](swiper.params.scrollbar.lockClass);
        }
    },
    getPointerPosition: function getPointerPosition(e) {
        var swiper = this;
        if (swiper.isHorizontal()) {
            return e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].clientX : e.clientX;
        }
        return e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].clientY : e.clientY;
    },
    setDragPosition: function setDragPosition(e) {
        var swiper = this;
        var scrollbar = swiper.scrollbar, rtl = swiper.rtlTranslate;
        var $el = scrollbar.$el, dragSize = scrollbar.dragSize, trackSize = scrollbar.trackSize, dragStartPos = scrollbar.dragStartPos;
        var positionRatio;
        positionRatio = (scrollbar.getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);
        if (rtl) {
            positionRatio = 1 - positionRatio;
        }
        var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    },
    onDragStart: function onDragStart(e) {
        var swiper = this;
        var params = swiper.params.scrollbar;
        var scrollbar = swiper.scrollbar, $wrapperEl = swiper.$wrapperEl;
        var $el = scrollbar.$el, $dragEl = scrollbar.$dragEl;
        swiper.scrollbar.isTouched = true;
        swiper.scrollbar.dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? "left" : "top"] : null;
        e.preventDefault();
        e.stopPropagation();
        $wrapperEl.transition(100);
        $dragEl.transition(100);
        scrollbar.setDragPosition(e);
        clearTimeout(swiper.scrollbar.dragTimeout);
        $el.transition(0);
        if (params.hide) {
            $el.css("opacity", 1);
        }
        if (swiper.params.cssMode) {
            swiper.$wrapperEl.css("scroll-snap-type", "none");
        }
        swiper.emit("scrollbarDragStart", e);
    },
    onDragMove: function onDragMove(e) {
        var swiper = this;
        var scrollbar = swiper.scrollbar, $wrapperEl = swiper.$wrapperEl;
        var $el = scrollbar.$el, $dragEl = scrollbar.$dragEl;
        if (!swiper.scrollbar.isTouched) return;
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        scrollbar.setDragPosition(e);
        $wrapperEl.transition(0);
        $el.transition(0);
        $dragEl.transition(0);
        swiper.emit("scrollbarDragMove", e);
    },
    onDragEnd: function onDragEnd(e) {
        var swiper = this;
        var params = swiper.params.scrollbar;
        var scrollbar = swiper.scrollbar, $wrapperEl = swiper.$wrapperEl;
        var $el = scrollbar.$el;
        if (!swiper.scrollbar.isTouched) return;
        swiper.scrollbar.isTouched = false;
        if (swiper.params.cssMode) {
            swiper.$wrapperEl.css("scroll-snap-type", "");
            $wrapperEl.transition("");
        }
        if (params.hide) {
            clearTimeout(swiper.scrollbar.dragTimeout);
            swiper.scrollbar.dragTimeout = nextTick3(function() {
                $el.css("opacity", 0);
                $el.transition(400);
            }, 1e3);
        }
        swiper.emit("scrollbarDragEnd", e);
        if (params.snapOnRelease) {
            swiper.slideToClosest();
        }
    },
    enableDraggable: function enableDraggable() {
        var swiper = this;
        if (!swiper.params.scrollbar.el) return;
        var document2 = getDocument();
        var scrollbar = swiper.scrollbar, touchEventsTouch = swiper.touchEventsTouch, touchEventsDesktop = swiper.touchEventsDesktop, params = swiper.params, support3 = swiper.support;
        var $el = scrollbar.$el;
        var target = $el[0];
        var activeListener = support3.passiveListener && params.passiveListeners ? {
            passive: false,
            capture: false
        } : false;
        var passiveListener = support3.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        if (!target) return;
        if (!support3.touch) {
            target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
            document2.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
            document2.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
        } else {
            target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
            target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
            target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
        }
    },
    disableDraggable: function disableDraggable() {
        var swiper = this;
        if (!swiper.params.scrollbar.el) return;
        var document2 = getDocument();
        var scrollbar = swiper.scrollbar, touchEventsTouch = swiper.touchEventsTouch, touchEventsDesktop = swiper.touchEventsDesktop, params = swiper.params, support3 = swiper.support;
        var $el = scrollbar.$el;
        var target = $el[0];
        var activeListener = support3.passiveListener && params.passiveListeners ? {
            passive: false,
            capture: false
        } : false;
        var passiveListener = support3.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        if (!target) return;
        if (!support3.touch) {
            target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
            document2.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
            document2.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
        } else {
            target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
            target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
            target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
        }
    },
    init: function init10() {
        var swiper = this;
        var scrollbar = swiper.scrollbar, $swiperEl = swiper.$el;
        swiper.params.scrollbar = createElementIfNotDefined($swiperEl, swiper.params.scrollbar, swiper.params.createElements, {
            el: "swiper-scrollbar"
        });
        var params = swiper.params.scrollbar;
        if (!params.el) return;
        var $el = $(params.el);
        if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
            $el = $swiperEl.find(params.el);
        }
        var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);
        if ($dragEl.length === 0) {
            $dragEl = $('<div class="' + swiper.params.scrollbar.dragClass + '"></div>');
            $el.append($dragEl);
        }
        extend(scrollbar, {
            $el,
            el: $el[0],
            $dragEl,
            dragEl: $dragEl[0]
        });
        if (params.draggable) {
            scrollbar.enableDraggable();
        }
        if ($el) {
            $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.scrollbar.lockClass);
        }
    },
    destroy: function destroy10() {
        var swiper = this;
        swiper.scrollbar.disableDraggable();
    }
};
var Scrollbar$1 = {
    name: "scrollbar",
    params: {
        scrollbar: {
            el: null,
            dragSize: "auto",
            hide: false,
            draggable: false,
            snapOnRelease: true,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag"
        }
    },
    create: function create8() {
        var swiper = this;
        bindModuleMethods(swiper, {
            scrollbar: _extends$d({
                isTouched: false,
                timeout: null,
                dragTimeout: null
            }, Scrollbar)
        });
    },
    on: {
        init: function init11(swiper) {
            swiper.scrollbar.init();
            swiper.scrollbar.updateSize();
            swiper.scrollbar.setTranslate();
        },
        update: function update5(swiper) {
            swiper.scrollbar.updateSize();
        },
        resize: function resize(swiper) {
            swiper.scrollbar.updateSize();
        },
        observerUpdate: function observerUpdate(swiper) {
            swiper.scrollbar.updateSize();
        },
        setTranslate: function setTranslate4(swiper) {
            swiper.scrollbar.setTranslate();
        },
        setTransition: function setTransition3(swiper, duration) {
            swiper.scrollbar.setTransition(duration);
        },
        "enable disable": function enableDisable3(swiper) {
            var $el = swiper.scrollbar.$el;
            if ($el) {
                $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.scrollbar.lockClass);
            }
        },
        destroy: function destroy11(swiper) {
            swiper.scrollbar.destroy();
        }
    }
};
function _extends$c() {
    _extends$c = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$c.apply(this, arguments);
}
var Parallax = {
    setTransform: function setTransform2(el, progress) {
        var swiper = this;
        var rtl = swiper.rtl;
        var $el = $(el);
        var rtlFactor = rtl ? -1 : 1;
        var p = $el.attr("data-swiper-parallax") || "0";
        var x = $el.attr("data-swiper-parallax-x");
        var y = $el.attr("data-swiper-parallax-y");
        var scale = $el.attr("data-swiper-parallax-scale");
        var opacity = $el.attr("data-swiper-parallax-opacity");
        if (x || y) {
            x = x || "0";
            y = y || "0";
        } else if (swiper.isHorizontal()) {
            x = p;
            y = "0";
        } else {
            y = p;
            x = "0";
        }
        if (x.indexOf("%") >= 0) {
            x = parseInt(x, 10) * progress * rtlFactor + "%";
        } else {
            x = x * progress * rtlFactor + "px";
        }
        if (y.indexOf("%") >= 0) {
            y = parseInt(y, 10) * progress + "%";
        } else {
            y = y * progress + "px";
        }
        if (typeof opacity !== "undefined" && opacity !== null) {
            var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
            $el[0].style.opacity = currentOpacity;
        }
        if (typeof scale === "undefined" || scale === null) {
            $el.transform("translate3d(" + x + ", " + y + ", 0px)");
        } else {
            var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
            $el.transform("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")");
        }
    },
    setTranslate: function setTranslate5() {
        var swiper = this;
        var $el = swiper.$el, slides = swiper.slides, progress = swiper.progress, snapGrid = swiper.snapGrid;
        $el.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(function(el) {
            swiper.parallax.setTransform(el, progress);
        });
        slides.each(function(slideEl, slideIndex) {
            var slideProgress = slideEl.progress;
            if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== "auto") {
                slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
            }
            slideProgress = Math.min(Math.max(slideProgress, -1), 1);
            $(slideEl).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(function(el) {
                swiper.parallax.setTransform(el, slideProgress);
            });
        });
    },
    setTransition: function setTransition4(duration) {
        if (duration === void 0) {
            duration = this.params.speed;
        }
        var swiper = this;
        var $el = swiper.$el;
        $el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(function(parallaxEl) {
            var $parallaxEl = $(parallaxEl);
            var parallaxDuration = parseInt($parallaxEl.attr("data-swiper-parallax-duration"), 10) || duration;
            if (duration === 0) parallaxDuration = 0;
            $parallaxEl.transition(parallaxDuration);
        });
    }
};
var Parallax$1 = {
    name: "parallax",
    params: {
        parallax: {
            enabled: false
        }
    },
    create: function create9() {
        var swiper = this;
        bindModuleMethods(swiper, {
            parallax: _extends$c({}, Parallax)
        });
    },
    on: {
        beforeInit: function beforeInit2(swiper) {
            if (!swiper.params.parallax.enabled) return;
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
        },
        init: function init12(swiper) {
            if (!swiper.params.parallax.enabled) return;
            swiper.parallax.setTranslate();
        },
        setTranslate: function setTranslate6(swiper) {
            if (!swiper.params.parallax.enabled) return;
            swiper.parallax.setTranslate();
        },
        setTransition: function setTransition5(swiper, duration) {
            if (!swiper.params.parallax.enabled) return;
            swiper.parallax.setTransition(duration);
        }
    }
};
function _extends$b() {
    _extends$b = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$b.apply(this, arguments);
}
var Zoom = {
    getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
        if (e.targetTouches.length < 2) return 1;
        var x1 = e.targetTouches[0].pageX;
        var y1 = e.targetTouches[0].pageY;
        var x2 = e.targetTouches[1].pageX;
        var y2 = e.targetTouches[1].pageY;
        var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        return distance;
    },
    onGestureStart: function onGestureStart(e) {
        var swiper = this;
        var support3 = swiper.support;
        var params = swiper.params.zoom;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture;
        zoom.fakeGestureTouched = false;
        zoom.fakeGestureMoved = false;
        if (!support3.gestures) {
            if (e.type !== "touchstart" || e.type === "touchstart" && e.targetTouches.length < 2) {
                return;
            }
            zoom.fakeGestureTouched = true;
            gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
        }
        if (!gesture.$slideEl || !gesture.$slideEl.length) {
            gesture.$slideEl = $(e.target).closest("." + swiper.params.slideClass);
            if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target");
            gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
            gesture.maxRatio = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
            if (gesture.$imageWrapEl.length === 0) {
                gesture.$imageEl = void 0;
                return;
            }
        }
        if (gesture.$imageEl) {
            gesture.$imageEl.transition(0);
        }
        swiper.zoom.isScaling = true;
    },
    onGestureChange: function onGestureChange(e) {
        var swiper = this;
        var support3 = swiper.support;
        var params = swiper.params.zoom;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture;
        if (!support3.gestures) {
            if (e.type !== "touchmove" || e.type === "touchmove" && e.targetTouches.length < 2) {
                return;
            }
            zoom.fakeGestureMoved = true;
            gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
            if (e.type === "gesturechange") zoom.onGestureStart(e);
            return;
        }
        if (support3.gestures) {
            zoom.scale = e.scale * zoom.currentScale;
        } else {
            zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
        }
        if (zoom.scale > gesture.maxRatio) {
            zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
        }
        if (zoom.scale < params.minRatio) {
            zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
        }
        gesture.$imageEl.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    onGestureEnd: function onGestureEnd(e) {
        var swiper = this;
        var device2 = swiper.device;
        var support3 = swiper.support;
        var params = swiper.params.zoom;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture;
        if (!support3.gestures) {
            if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
                return;
            }
            if (e.type !== "touchend" || e.type === "touchend" && e.changedTouches.length < 2 && !device2.android) {
                return;
            }
            zoom.fakeGestureTouched = false;
            zoom.fakeGestureMoved = false;
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
        gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
        zoom.currentScale = zoom.scale;
        zoom.isScaling = false;
        if (zoom.scale === 1) gesture.$slideEl = void 0;
    },
    onTouchStart: function onTouchStart2(e) {
        var swiper = this;
        var device2 = swiper.device;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture, image = zoom.image;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (image.isTouched) return;
        if (device2.android && e.cancelable) e.preventDefault();
        image.isTouched = true;
        image.touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
        image.touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    },
    onTouchMove: function onTouchMove2(e) {
        var swiper = this;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture, image = zoom.image, velocity = zoom.velocity;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        swiper.allowClick = false;
        if (!image.isTouched || !gesture.$slideEl) return;
        if (!image.isMoved) {
            image.width = gesture.$imageEl[0].offsetWidth;
            image.height = gesture.$imageEl[0].offsetHeight;
            image.startX = getTranslate(gesture.$imageWrapEl[0], "x") || 0;
            image.startY = getTranslate(gesture.$imageWrapEl[0], "y") || 0;
            gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
            gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
            gesture.$imageWrapEl.transition(0);
        }
        var scaledWidth = image.width * zoom.scale;
        var scaledHeight = image.height * zoom.scale;
        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.touchesCurrent.x = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
        image.touchesCurrent.y = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
        if (!image.isMoved && !zoom.isScaling) {
            if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                image.isTouched = false;
                return;
            }
            if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                image.isTouched = false;
                return;
            }
        }
        if (e.cancelable) {
            e.preventDefault();
        }
        e.stopPropagation();
        image.isMoved = true;
        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
        if (image.currentX < image.minX) {
            image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
        }
        if (image.currentX > image.maxX) {
            image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
        }
        if (image.currentY < image.minY) {
            image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
        }
        if (image.currentY > image.maxY) {
            image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
        }
        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
        if (!velocity.prevTime) velocity.prevTime = Date.now();
        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
        velocity.prevPositionX = image.touchesCurrent.x;
        velocity.prevPositionY = image.touchesCurrent.y;
        velocity.prevTime = Date.now();
        gesture.$imageWrapEl.transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTouchEnd: function onTouchEnd2() {
        var swiper = this;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture, image = zoom.image, velocity = zoom.velocity;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (!image.isTouched || !image.isMoved) {
            image.isTouched = false;
            image.isMoved = false;
            return;
        }
        image.isTouched = false;
        image.isMoved = false;
        var momentumDurationX = 300;
        var momentumDurationY = 300;
        var momentumDistanceX = velocity.x * momentumDurationX;
        var newPositionX = image.currentX + momentumDistanceX;
        var momentumDistanceY = velocity.y * momentumDurationY;
        var newPositionY = image.currentY + momentumDistanceY;
        if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
        if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
        var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
        image.currentX = newPositionX;
        image.currentY = newPositionY;
        var scaledWidth = image.width * zoom.scale;
        var scaledHeight = image.height * zoom.scale;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
        gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTransitionEnd: function onTransitionEnd() {
        var swiper = this;
        var zoom = swiper.zoom;
        var gesture = zoom.gesture;
        if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
            if (gesture.$imageEl) {
                gesture.$imageEl.transform("translate3d(0,0,0) scale(1)");
            }
            if (gesture.$imageWrapEl) {
                gesture.$imageWrapEl.transform("translate3d(0,0,0)");
            }
            zoom.scale = 1;
            zoom.currentScale = 1;
            gesture.$slideEl = void 0;
            gesture.$imageEl = void 0;
            gesture.$imageWrapEl = void 0;
        }
    },
    toggle: function toggle(e) {
        var swiper = this;
        var zoom = swiper.zoom;
        if (zoom.scale && zoom.scale !== 1) {
            zoom.out();
        } else {
            zoom.in(e);
        }
    },
    in: function _in(e) {
        var swiper = this;
        var window2 = getWindow();
        var zoom = swiper.zoom;
        var params = swiper.params.zoom;
        var gesture = zoom.gesture, image = zoom.image;
        if (!gesture.$slideEl) {
            if (e && e.target) {
                gesture.$slideEl = $(e.target).closest("." + swiper.params.slideClass);
            }
            if (!gesture.$slideEl) {
                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                    gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
                } else {
                    gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                }
            }
            gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target");
            gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
        gesture.$slideEl.addClass("" + params.zoomedSlideClass);
        var touchX;
        var touchY;
        var offsetX;
        var offsetY;
        var diffX;
        var diffY;
        var translateX;
        var translateY;
        var imageWidth;
        var imageHeight;
        var scaledWidth;
        var scaledHeight;
        var translateMinX;
        var translateMinY;
        var translateMaxX;
        var translateMaxY;
        var slideWidth;
        var slideHeight;
        if (typeof image.touchesStart.x === "undefined" && e) {
            touchX = e.type === "touchend" ? e.changedTouches[0].pageX : e.pageX;
            touchY = e.type === "touchend" ? e.changedTouches[0].pageY : e.pageY;
        } else {
            touchX = image.touchesStart.x;
            touchY = image.touchesStart.y;
        }
        zoom.scale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
        zoom.currentScale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
        if (e) {
            slideWidth = gesture.$slideEl[0].offsetWidth;
            slideHeight = gesture.$slideEl[0].offsetHeight;
            offsetX = gesture.$slideEl.offset().left + window2.scrollX;
            offsetY = gesture.$slideEl.offset().top + window2.scrollY;
            diffX = offsetX + slideWidth / 2 - touchX;
            diffY = offsetY + slideHeight / 2 - touchY;
            imageWidth = gesture.$imageEl[0].offsetWidth;
            imageHeight = gesture.$imageEl[0].offsetHeight;
            scaledWidth = imageWidth * zoom.scale;
            scaledHeight = imageHeight * zoom.scale;
            translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
            translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
            translateMaxX = -translateMinX;
            translateMaxY = -translateMinY;
            translateX = diffX * zoom.scale;
            translateY = diffY * zoom.scale;
            if (translateX < translateMinX) {
                translateX = translateMinX;
            }
            if (translateX > translateMaxX) {
                translateX = translateMaxX;
            }
            if (translateY < translateMinY) {
                translateY = translateMinY;
            }
            if (translateY > translateMaxY) {
                translateY = translateMaxY;
            }
        } else {
            translateX = 0;
            translateY = 0;
        }
        gesture.$imageWrapEl.transition(300).transform("translate3d(" + translateX + "px, " + translateY + "px,0)");
        gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    out: function out() {
        var swiper = this;
        var zoom = swiper.zoom;
        var params = swiper.params.zoom;
        var gesture = zoom.gesture;
        if (!gesture.$slideEl) {
            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
            } else {
                gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            }
            gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target");
            gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) return;
        zoom.scale = 1;
        zoom.currentScale = 1;
        gesture.$imageWrapEl.transition(300).transform("translate3d(0,0,0)");
        gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)");
        gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
        gesture.$slideEl = void 0;
    },
    toggleGestures: function toggleGestures(method) {
        var swiper = this;
        var zoom = swiper.zoom;
        var selector = zoom.slideSelector, passive = zoom.passiveListener;
        swiper.$wrapperEl[method]("gesturestart", selector, zoom.onGestureStart, passive);
        swiper.$wrapperEl[method]("gesturechange", selector, zoom.onGestureChange, passive);
        swiper.$wrapperEl[method]("gestureend", selector, zoom.onGestureEnd, passive);
    },
    enableGestures: function enableGestures() {
        if (this.zoom.gesturesEnabled) return;
        this.zoom.gesturesEnabled = true;
        this.zoom.toggleGestures("on");
    },
    disableGestures: function disableGestures() {
        if (!this.zoom.gesturesEnabled) return;
        this.zoom.gesturesEnabled = false;
        this.zoom.toggleGestures("off");
    },
    enable: function enable3() {
        var swiper = this;
        var support3 = swiper.support;
        var zoom = swiper.zoom;
        if (zoom.enabled) return;
        zoom.enabled = true;
        var passiveListener = swiper.touchEvents.start === "touchstart" && support3.passiveListener && swiper.params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        var activeListenerWithCapture = support3.passiveListener ? {
            passive: false,
            capture: true
        } : true;
        var slideSelector = "." + swiper.params.slideClass;
        swiper.zoom.passiveListener = passiveListener;
        swiper.zoom.slideSelector = slideSelector;
        if (support3.gestures) {
            swiper.$wrapperEl.on(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
            swiper.$wrapperEl.on(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === "touchstart") {
            swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
            swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
            swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
            if (swiper.touchEvents.cancel) {
                swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
            }
        }
        swiper.$wrapperEl.on(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
    },
    disable: function disable3() {
        var swiper = this;
        var zoom = swiper.zoom;
        if (!zoom.enabled) return;
        var support3 = swiper.support;
        swiper.zoom.enabled = false;
        var passiveListener = swiper.touchEvents.start === "touchstart" && support3.passiveListener && swiper.params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        var activeListenerWithCapture = support3.passiveListener ? {
            passive: false,
            capture: true
        } : true;
        var slideSelector = "." + swiper.params.slideClass;
        if (support3.gestures) {
            swiper.$wrapperEl.off(swiper.touchEvents.start, swiper.zoom.enableGestures, passiveListener);
            swiper.$wrapperEl.off(swiper.touchEvents.end, swiper.zoom.disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === "touchstart") {
            swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
            swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
            swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
            if (swiper.touchEvents.cancel) {
                swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
            }
        }
        swiper.$wrapperEl.off(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
    }
};
var Zoom$1 = {
    name: "zoom",
    params: {
        zoom: {
            enabled: false,
            maxRatio: 3,
            minRatio: 1,
            toggle: true,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed"
        }
    },
    create: function create10() {
        var swiper = this;
        bindModuleMethods(swiper, {
            zoom: _extends$b({
                enabled: false,
                scale: 1,
                currentScale: 1,
                isScaling: false,
                gesture: {
                    $slideEl: void 0,
                    slideWidth: void 0,
                    slideHeight: void 0,
                    $imageEl: void 0,
                    $imageWrapEl: void 0,
                    maxRatio: 3
                },
                image: {
                    isTouched: void 0,
                    isMoved: void 0,
                    currentX: void 0,
                    currentY: void 0,
                    minX: void 0,
                    minY: void 0,
                    maxX: void 0,
                    maxY: void 0,
                    width: void 0,
                    height: void 0,
                    startX: void 0,
                    startY: void 0,
                    touchesStart: {},
                    touchesCurrent: {}
                },
                velocity: {
                    x: void 0,
                    y: void 0,
                    prevPositionX: void 0,
                    prevPositionY: void 0,
                    prevTime: void 0
                }
            }, Zoom)
        });
        var scale = 1;
        Object.defineProperty(swiper.zoom, "scale", {
            get: function get2() {
                return scale;
            },
            set: function set2(value) {
                if (scale !== value) {
                    var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : void 0;
                    var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : void 0;
                    swiper.emit("zoomChange", value, imageEl, slideEl);
                }
                scale = value;
            }
        });
    },
    on: {
        init: function init13(swiper) {
            if (swiper.params.zoom.enabled) {
                swiper.zoom.enable();
            }
        },
        destroy: function destroy12(swiper) {
            swiper.zoom.disable();
        },
        touchStart: function touchStart(swiper, e) {
            if (!swiper.zoom.enabled) return;
            swiper.zoom.onTouchStart(e);
        },
        touchEnd: function touchEnd(swiper, e) {
            if (!swiper.zoom.enabled) return;
            swiper.zoom.onTouchEnd(e);
        },
        doubleTap: function doubleTap(swiper, e) {
            if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                swiper.zoom.toggle(e);
            }
        },
        transitionEnd: function transitionEnd2(swiper) {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                swiper.zoom.onTransitionEnd();
            }
        },
        slideChange: function slideChange(swiper) {
            if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
                swiper.zoom.onTransitionEnd();
            }
        }
    }
};
function _extends$a() {
    _extends$a = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$a.apply(this, arguments);
}
var Lazy = {
    loadInSlide: function loadInSlide(index2, loadInDuplicate) {
        if (loadInDuplicate === void 0) {
            loadInDuplicate = true;
        }
        var swiper = this;
        var params = swiper.params.lazy;
        if (typeof index2 === "undefined") return;
        if (swiper.slides.length === 0) return;
        var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        var $slideEl = isVirtual ? swiper.$wrapperEl.children("." + swiper.params.slideClass + '[data-swiper-slide-index="' + index2 + '"]') : swiper.slides.eq(index2);
        var $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");
        if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
            $images.push($slideEl[0]);
        }
        if ($images.length === 0) return;
        $images.each(function(imageEl) {
            var $imageEl = $(imageEl);
            $imageEl.addClass(params.loadingClass);
            var background = $imageEl.attr("data-background");
            var src = $imageEl.attr("data-src");
            var srcset = $imageEl.attr("data-srcset");
            var sizes = $imageEl.attr("data-sizes");
            var $pictureEl = $imageEl.parent("picture");
            swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function() {
                if (typeof swiper === "undefined" || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) return;
                if (background) {
                    $imageEl.css("background-image", 'url("' + background + '")');
                    $imageEl.removeAttr("data-background");
                } else {
                    if (srcset) {
                        $imageEl.attr("srcset", srcset);
                        $imageEl.removeAttr("data-srcset");
                    }
                    if (sizes) {
                        $imageEl.attr("sizes", sizes);
                        $imageEl.removeAttr("data-sizes");
                    }
                    if ($pictureEl.length) {
                        $pictureEl.children("source").each(function(sourceEl) {
                            var $source = $(sourceEl);
                            if ($source.attr("data-srcset")) {
                                $source.attr("srcset", $source.attr("data-srcset"));
                                $source.removeAttr("data-srcset");
                            }
                        });
                    }
                    if (src) {
                        $imageEl.attr("src", src);
                        $imageEl.removeAttr("data-src");
                    }
                }
                $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
                $slideEl.find("." + params.preloaderClass).remove();
                if (swiper.params.loop && loadInDuplicate) {
                    var slideOriginalIndex = $slideEl.attr("data-swiper-slide-index");
                    if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                        var originalSlide = swiper.$wrapperEl.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + swiper.params.slideDuplicateClass + ")");
                        swiper.lazy.loadInSlide(originalSlide.index(), false);
                    } else {
                        var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                        swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
                    }
                }
                swiper.emit("lazyImageReady", $slideEl[0], $imageEl[0]);
                if (swiper.params.autoHeight) {
                    swiper.updateAutoHeight();
                }
            });
            swiper.emit("lazyImageLoad", $slideEl[0], $imageEl[0]);
        });
    },
    load: function load() {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl, swiperParams = swiper.params, slides = swiper.slides, activeIndex = swiper.activeIndex;
        var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
        var params = swiperParams.lazy;
        var slidesPerView = swiperParams.slidesPerView;
        if (slidesPerView === "auto") {
            slidesPerView = 0;
        }
        function slideExist(index2) {
            if (isVirtual) {
                if ($wrapperEl.children("." + swiperParams.slideClass + '[data-swiper-slide-index="' + index2 + '"]').length) {
                    return true;
                }
            } else if (slides[index2]) return true;
            return false;
        }
        function slideIndex(slideEl) {
            if (isVirtual) {
                return $(slideEl).attr("data-swiper-slide-index");
            }
            return $(slideEl).index();
        }
        if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
        if (swiper.params.watchSlidesVisibility) {
            $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function(slideEl) {
                var index2 = isVirtual ? $(slideEl).attr("data-swiper-slide-index") : $(slideEl).index();
                swiper.lazy.loadInSlide(index2);
            });
        } else if (slidesPerView > 1) {
            for(var i2 = activeIndex; i2 < activeIndex + slidesPerView; i2 += 1){
                if (slideExist(i2)) swiper.lazy.loadInSlide(i2);
            }
        } else {
            swiper.lazy.loadInSlide(activeIndex);
        }
        if (params.loadPrevNext) {
            if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
                var amount = params.loadPrevNextAmount;
                var spv = slidesPerView;
                var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
                var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
                for(var _i = activeIndex + slidesPerView; _i < maxIndex; _i += 1){
                    if (slideExist(_i)) swiper.lazy.loadInSlide(_i);
                }
                for(var _i2 = minIndex; _i2 < activeIndex; _i2 += 1){
                    if (slideExist(_i2)) swiper.lazy.loadInSlide(_i2);
                }
            } else {
                var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);
                if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));
                var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);
                if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
            }
        }
    },
    checkInViewOnLoad: function checkInViewOnLoad() {
        var window2 = getWindow();
        var swiper = this;
        if (!swiper || swiper.destroyed) return;
        var $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window2);
        var isWindow = $scrollElement[0] === window2;
        var scrollElementWidth = isWindow ? window2.innerWidth : $scrollElement[0].offsetWidth;
        var scrollElementHeight = isWindow ? window2.innerHeight : $scrollElement[0].offsetHeight;
        var swiperOffset = swiper.$el.offset();
        var rtl = swiper.rtlTranslate;
        var inView = false;
        if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
        var swiperCoord = [
            [
                swiperOffset.left,
                swiperOffset.top
            ],
            [
                swiperOffset.left + swiper.width,
                swiperOffset.top
            ],
            [
                swiperOffset.left,
                swiperOffset.top + swiper.height
            ],
            [
                swiperOffset.left + swiper.width,
                swiperOffset.top + swiper.height
            ]
        ];
        for(var i2 = 0; i2 < swiperCoord.length; i2 += 1){
            var point = swiperCoord[i2];
            if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
                if (point[0] === 0 && point[1] === 0) continue;
                inView = true;
            }
        }
        var passiveListener = swiper.touchEvents.start === "touchstart" && swiper.support.passiveListener && swiper.params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        if (inView) {
            swiper.lazy.load();
            $scrollElement.off("scroll", swiper.lazy.checkInViewOnLoad, passiveListener);
        } else if (!swiper.lazy.scrollHandlerAttached) {
            swiper.lazy.scrollHandlerAttached = true;
            $scrollElement.on("scroll", swiper.lazy.checkInViewOnLoad, passiveListener);
        }
    }
};
var Lazy$1 = {
    name: "lazy",
    params: {
        lazy: {
            checkInView: false,
            enabled: false,
            loadPrevNext: false,
            loadPrevNextAmount: 1,
            loadOnTransitionStart: false,
            scrollingElement: "",
            elementClass: "swiper-lazy",
            loadingClass: "swiper-lazy-loading",
            loadedClass: "swiper-lazy-loaded",
            preloaderClass: "swiper-lazy-preloader"
        }
    },
    create: function create11() {
        var swiper = this;
        bindModuleMethods(swiper, {
            lazy: _extends$a({
                initialImageLoaded: false
            }, Lazy)
        });
    },
    on: {
        beforeInit: function beforeInit3(swiper) {
            if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
                swiper.params.preloadImages = false;
            }
        },
        init: function init14(swiper) {
            if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
                if (swiper.params.lazy.checkInView) {
                    swiper.lazy.checkInViewOnLoad();
                } else {
                    swiper.lazy.load();
                }
            }
        },
        scroll: function scroll(swiper) {
            if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
                swiper.lazy.load();
            }
        },
        "scrollbarDragMove resize _freeModeNoMomentumRelease": function lazyLoad(swiper) {
            if (swiper.params.lazy.enabled) {
                swiper.lazy.load();
            }
        },
        transitionStart: function transitionStart2(swiper) {
            if (swiper.params.lazy.enabled) {
                if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
                    swiper.lazy.load();
                }
            }
        },
        transitionEnd: function transitionEnd3(swiper) {
            if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
                swiper.lazy.load();
            }
        },
        slideChange: function slideChange2(swiper) {
            var _swiper$params = swiper.params, lazy = _swiper$params.lazy, cssMode = _swiper$params.cssMode, watchSlidesVisibility = _swiper$params.watchSlidesVisibility, watchSlidesProgress = _swiper$params.watchSlidesProgress, touchReleaseOnEdges = _swiper$params.touchReleaseOnEdges, resistanceRatio = _swiper$params.resistanceRatio;
            if (lazy.enabled && (cssMode || (watchSlidesVisibility || watchSlidesProgress) && (touchReleaseOnEdges || resistanceRatio === 0))) {
                swiper.lazy.load();
            }
        }
    }
};
function _extends$9() {
    _extends$9 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$9.apply(this, arguments);
}
var Controller = {
    LinearSpline: function LinearSpline(x, y) {
        var binarySearch = function search() {
            var maxIndex;
            var minIndex;
            var guess;
            return function(array, val) {
                minIndex = -1;
                maxIndex = array.length;
                while(maxIndex - minIndex > 1){
                    guess = maxIndex + minIndex >> 1;
                    if (array[guess] <= val) {
                        minIndex = guess;
                    } else {
                        maxIndex = guess;
                    }
                }
                return maxIndex;
            };
        }();
        this.x = x;
        this.y = y;
        this.lastIndex = x.length - 1;
        var i1;
        var i3;
        this.interpolate = function interpolate(x2) {
            if (!x2) return 0;
            i3 = binarySearch(this.x, x2);
            i1 = i3 - 1;
            return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
        };
        return this;
    },
    getInterpolateFunction: function getInterpolateFunction(c) {
        var swiper = this;
        if (!swiper.controller.spline) {
            swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
        }
    },
    setTranslate: function setTranslate7(_setTranslate, byController) {
        var swiper = this;
        var controlled = swiper.controller.control;
        var multiplier;
        var controlledTranslate;
        var Swiper2 = swiper.constructor;
        function setControlledTranslate(c) {
            var translate2 = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
            if (swiper.params.controller.by === "slide") {
                swiper.controller.getInterpolateFunction(c);
                controlledTranslate = -swiper.controller.spline.interpolate(-translate2);
            }
            if (!controlledTranslate || swiper.params.controller.by === "container") {
                multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                controlledTranslate = (translate2 - swiper.minTranslate()) * multiplier + c.minTranslate();
            }
            if (swiper.params.controller.inverse) {
                controlledTranslate = c.maxTranslate() - controlledTranslate;
            }
            c.updateProgress(controlledTranslate);
            c.setTranslate(controlledTranslate, swiper);
            c.updateActiveIndex();
            c.updateSlidesClasses();
        }
        if (Array.isArray(controlled)) {
            for(var i2 = 0; i2 < controlled.length; i2 += 1){
                if (controlled[i2] !== byController && controlled[i2] instanceof Swiper2) {
                    setControlledTranslate(controlled[i2]);
                }
            }
        } else if (controlled instanceof Swiper2 && byController !== controlled) {
            setControlledTranslate(controlled);
        }
    },
    setTransition: function setTransition6(duration, byController) {
        var swiper = this;
        var Swiper2 = swiper.constructor;
        var controlled = swiper.controller.control;
        var i2;
        function setControlledTransition(c) {
            c.setTransition(duration, swiper);
            if (duration !== 0) {
                c.transitionStart();
                if (c.params.autoHeight) {
                    nextTick3(function() {
                        c.updateAutoHeight();
                    });
                }
                c.$wrapperEl.transitionEnd(function() {
                    if (!controlled) return;
                    if (c.params.loop && swiper.params.controller.by === "slide") {
                        c.loopFix();
                    }
                    c.transitionEnd();
                });
            }
        }
        if (Array.isArray(controlled)) {
            for(i2 = 0; i2 < controlled.length; i2 += 1){
                if (controlled[i2] !== byController && controlled[i2] instanceof Swiper2) {
                    setControlledTransition(controlled[i2]);
                }
            }
        } else if (controlled instanceof Swiper2 && byController !== controlled) {
            setControlledTransition(controlled);
        }
    }
};
var Controller$1 = {
    name: "controller",
    params: {
        controller: {
            control: void 0,
            inverse: false,
            by: "slide"
        }
    },
    create: function create12() {
        var swiper = this;
        bindModuleMethods(swiper, {
            controller: _extends$9({
                control: swiper.params.controller.control
            }, Controller)
        });
    },
    on: {
        update: function update6(swiper) {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
                swiper.controller.spline = void 0;
                delete swiper.controller.spline;
            }
        },
        resize: function resize2(swiper) {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
                swiper.controller.spline = void 0;
                delete swiper.controller.spline;
            }
        },
        observerUpdate: function observerUpdate2(swiper) {
            if (!swiper.controller.control) return;
            if (swiper.controller.spline) {
                swiper.controller.spline = void 0;
                delete swiper.controller.spline;
            }
        },
        setTranslate: function setTranslate8(swiper, translate2, byController) {
            if (!swiper.controller.control) return;
            swiper.controller.setTranslate(translate2, byController);
        },
        setTransition: function setTransition7(swiper, duration, byController) {
            if (!swiper.controller.control) return;
            swiper.controller.setTransition(duration, byController);
        }
    }
};
function _extends$8() {
    _extends$8 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$8.apply(this, arguments);
}
var A11y = {
    getRandomNumber: function getRandomNumber(size) {
        if (size === void 0) {
            size = 16;
        }
        var randomChar = function randomChar2() {
            return Math.round(16 * Math.random()).toString(16);
        };
        return "x".repeat(size).replace(/x/g, randomChar);
    },
    makeElFocusable: function makeElFocusable($el) {
        $el.attr("tabIndex", "0");
        return $el;
    },
    makeElNotFocusable: function makeElNotFocusable($el) {
        $el.attr("tabIndex", "-1");
        return $el;
    },
    addElRole: function addElRole($el, role) {
        $el.attr("role", role);
        return $el;
    },
    addElRoleDescription: function addElRoleDescription($el, description) {
        $el.attr("aria-roledescription", description);
        return $el;
    },
    addElControls: function addElControls($el, controls) {
        $el.attr("aria-controls", controls);
        return $el;
    },
    addElLabel: function addElLabel($el, label) {
        $el.attr("aria-label", label);
        return $el;
    },
    addElId: function addElId($el, id) {
        $el.attr("id", id);
        return $el;
    },
    addElLive: function addElLive($el, live) {
        $el.attr("aria-live", live);
        return $el;
    },
    disableEl: function disableEl($el) {
        $el.attr("aria-disabled", true);
        return $el;
    },
    enableEl: function enableEl($el) {
        $el.attr("aria-disabled", false);
        return $el;
    },
    onEnterOrSpaceKey: function onEnterOrSpaceKey(e) {
        if (e.keyCode !== 13 && e.keyCode !== 32) return;
        var swiper = this;
        var params = swiper.params.a11y;
        var $targetEl = $(e.target);
        if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
            if (!(swiper.isEnd && !swiper.params.loop)) {
                swiper.slideNext();
            }
            if (swiper.isEnd) {
                swiper.a11y.notify(params.lastSlideMessage);
            } else {
                swiper.a11y.notify(params.nextSlideMessage);
            }
        }
        if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
            if (!(swiper.isBeginning && !swiper.params.loop)) {
                swiper.slidePrev();
            }
            if (swiper.isBeginning) {
                swiper.a11y.notify(params.firstSlideMessage);
            } else {
                swiper.a11y.notify(params.prevSlideMessage);
            }
        }
        if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
            $targetEl[0].click();
        }
    },
    notify: function notify(message) {
        var swiper = this;
        var notification = swiper.a11y.liveRegion;
        if (notification.length === 0) return;
        notification.html("");
        notification.html(message);
    },
    updateNavigation: function updateNavigation() {
        var swiper = this;
        if (swiper.params.loop || !swiper.navigation) return;
        var _swiper$navigation = swiper.navigation, $nextEl = _swiper$navigation.$nextEl, $prevEl = _swiper$navigation.$prevEl;
        if ($prevEl && $prevEl.length > 0) {
            if (swiper.isBeginning) {
                swiper.a11y.disableEl($prevEl);
                swiper.a11y.makeElNotFocusable($prevEl);
            } else {
                swiper.a11y.enableEl($prevEl);
                swiper.a11y.makeElFocusable($prevEl);
            }
        }
        if ($nextEl && $nextEl.length > 0) {
            if (swiper.isEnd) {
                swiper.a11y.disableEl($nextEl);
                swiper.a11y.makeElNotFocusable($nextEl);
            } else {
                swiper.a11y.enableEl($nextEl);
                swiper.a11y.makeElFocusable($nextEl);
            }
        }
    },
    updatePagination: function updatePagination() {
        var swiper = this;
        var params = swiper.params.a11y;
        if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
            swiper.pagination.bullets.each(function(bulletEl) {
                var $bulletEl = $(bulletEl);
                swiper.a11y.makeElFocusable($bulletEl);
                if (!swiper.params.pagination.renderBullet) {
                    swiper.a11y.addElRole($bulletEl, "button");
                    swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
                }
            });
        }
    },
    init: function init15() {
        var swiper = this;
        var params = swiper.params.a11y;
        swiper.$el.append(swiper.a11y.liveRegion);
        var $containerEl = swiper.$el;
        if (params.containerRoleDescriptionMessage) {
            swiper.a11y.addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
        }
        if (params.containerMessage) {
            swiper.a11y.addElLabel($containerEl, params.containerMessage);
        }
        var $wrapperEl = swiper.$wrapperEl;
        var wrapperId = $wrapperEl.attr("id") || "swiper-wrapper-" + swiper.a11y.getRandomNumber(16);
        var live = swiper.params.autoplay && swiper.params.autoplay.enabled ? "off" : "polite";
        swiper.a11y.addElId($wrapperEl, wrapperId);
        swiper.a11y.addElLive($wrapperEl, live);
        if (params.itemRoleDescriptionMessage) {
            swiper.a11y.addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
        }
        swiper.a11y.addElRole($(swiper.slides), params.slideRole);
        var slidesLength = swiper.params.loop ? swiper.slides.filter(function(el) {
            return !el.classList.contains(swiper.params.slideDuplicateClass);
        }).length : swiper.slides.length;
        swiper.slides.each(function(slideEl, index2) {
            var $slideEl = $(slideEl);
            var slideIndex = swiper.params.loop ? parseInt($slideEl.attr("data-swiper-slide-index"), 10) : index2;
            var ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
            swiper.a11y.addElLabel($slideEl, ariaLabelMessage);
        });
        var $nextEl;
        var $prevEl;
        if (swiper.navigation && swiper.navigation.$nextEl) {
            $nextEl = swiper.navigation.$nextEl;
        }
        if (swiper.navigation && swiper.navigation.$prevEl) {
            $prevEl = swiper.navigation.$prevEl;
        }
        if ($nextEl && $nextEl.length) {
            swiper.a11y.makeElFocusable($nextEl);
            if ($nextEl[0].tagName !== "BUTTON") {
                swiper.a11y.addElRole($nextEl, "button");
                $nextEl.on("keydown", swiper.a11y.onEnterOrSpaceKey);
            }
            swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
            swiper.a11y.addElControls($nextEl, wrapperId);
        }
        if ($prevEl && $prevEl.length) {
            swiper.a11y.makeElFocusable($prevEl);
            if ($prevEl[0].tagName !== "BUTTON") {
                swiper.a11y.addElRole($prevEl, "button");
                $prevEl.on("keydown", swiper.a11y.onEnterOrSpaceKey);
            }
            swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
            swiper.a11y.addElControls($prevEl, wrapperId);
        }
        if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
            swiper.pagination.$el.on("keydown", classesToSelector(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
        }
    },
    destroy: function destroy13() {
        var swiper = this;
        if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();
        var $nextEl;
        var $prevEl;
        if (swiper.navigation && swiper.navigation.$nextEl) {
            $nextEl = swiper.navigation.$nextEl;
        }
        if (swiper.navigation && swiper.navigation.$prevEl) {
            $prevEl = swiper.navigation.$prevEl;
        }
        if ($nextEl) {
            $nextEl.off("keydown", swiper.a11y.onEnterOrSpaceKey);
        }
        if ($prevEl) {
            $prevEl.off("keydown", swiper.a11y.onEnterOrSpaceKey);
        }
        if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
            swiper.pagination.$el.off("keydown", classesToSelector(swiper.params.pagination.bulletClass), swiper.a11y.onEnterOrSpaceKey);
        }
    }
};
var A11y$1 = {
    name: "a11y",
    params: {
        a11y: {
            enabled: true,
            notificationClass: "swiper-notification",
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            paginationBulletMessage: "Go to slide {{index}}",
            slideLabelMessage: "{{index}} / {{slidesLength}}",
            containerMessage: null,
            containerRoleDescriptionMessage: null,
            itemRoleDescriptionMessage: null,
            slideRole: "group"
        }
    },
    create: function create13() {
        var swiper = this;
        bindModuleMethods(swiper, {
            a11y: _extends$8({}, A11y, {
                liveRegion: $('<span class="' + swiper.params.a11y.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>')
            })
        });
    },
    on: {
        afterInit: function afterInit(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.init();
            swiper.a11y.updateNavigation();
        },
        toEdge: function toEdge2(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.updateNavigation();
        },
        fromEdge: function fromEdge2(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.updateNavigation();
        },
        paginationUpdate: function paginationUpdate(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.updatePagination();
        },
        destroy: function destroy14(swiper) {
            if (!swiper.params.a11y.enabled) return;
            swiper.a11y.destroy();
        }
    }
};
function _extends$7() {
    _extends$7 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$7.apply(this, arguments);
}
var History = {
    init: function init16() {
        var swiper = this;
        var window2 = getWindow();
        if (!swiper.params.history) return;
        if (!window2.history || !window2.history.pushState) {
            swiper.params.history.enabled = false;
            swiper.params.hashNavigation.enabled = true;
            return;
        }
        var history2 = swiper.history;
        history2.initialized = true;
        history2.paths = History.getPathValues(swiper.params.url);
        if (!history2.paths.key && !history2.paths.value) return;
        history2.scrollToSlide(0, history2.paths.value, swiper.params.runCallbacksOnInit);
        if (!swiper.params.history.replaceState) {
            window2.addEventListener("popstate", swiper.history.setHistoryPopState);
        }
    },
    destroy: function destroy15() {
        var swiper = this;
        var window2 = getWindow();
        if (!swiper.params.history.replaceState) {
            window2.removeEventListener("popstate", swiper.history.setHistoryPopState);
        }
    },
    setHistoryPopState: function setHistoryPopState() {
        var swiper = this;
        swiper.history.paths = History.getPathValues(swiper.params.url);
        swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
    },
    getPathValues: function getPathValues(urlOverride) {
        var window2 = getWindow();
        var location2;
        if (urlOverride) {
            location2 = new URL(urlOverride);
        } else {
            location2 = window2.location;
        }
        var pathArray = location2.pathname.slice(1).split("/").filter(function(part) {
            return part !== "";
        });
        var total = pathArray.length;
        var key = pathArray[total - 2];
        var value = pathArray[total - 1];
        return {
            key,
            value
        };
    },
    setHistory: function setHistory(key, index2) {
        var swiper = this;
        var window2 = getWindow();
        if (!swiper.history.initialized || !swiper.params.history.enabled) return;
        var location2;
        if (swiper.params.url) {
            location2 = new URL(swiper.params.url);
        } else {
            location2 = window2.location;
        }
        var slide2 = swiper.slides.eq(index2);
        var value = History.slugify(slide2.attr("data-history"));
        if (swiper.params.history.root.length > 0) {
            var root = swiper.params.history.root;
            if (root[root.length - 1] === "/") root = root.slice(0, root.length - 1);
            value = root + "/" + key + "/" + value;
        } else if (!location2.pathname.includes(key)) {
            value = key + "/" + value;
        }
        var currentState = window2.history.state;
        if (currentState && currentState.value === value) {
            return;
        }
        if (swiper.params.history.replaceState) {
            window2.history.replaceState({
                value
            }, null, value);
        } else {
            window2.history.pushState({
                value
            }, null, value);
        }
    },
    slugify: function slugify(text2) {
        return text2.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
    },
    scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
        var swiper = this;
        if (value) {
            for(var i2 = 0, length = swiper.slides.length; i2 < length; i2 += 1){
                var slide2 = swiper.slides.eq(i2);
                var slideHistory = History.slugify(slide2.attr("data-history"));
                if (slideHistory === value && !slide2.hasClass(swiper.params.slideDuplicateClass)) {
                    var index2 = slide2.index();
                    swiper.slideTo(index2, speed, runCallbacks);
                }
            }
        } else {
            swiper.slideTo(0, speed, runCallbacks);
        }
    }
};
var History$1 = {
    name: "history",
    params: {
        history: {
            enabled: false,
            root: "",
            replaceState: false,
            key: "slides"
        }
    },
    create: function create14() {
        var swiper = this;
        bindModuleMethods(swiper, {
            history: _extends$7({}, History)
        });
    },
    on: {
        init: function init17(swiper) {
            if (swiper.params.history.enabled) {
                swiper.history.init();
            }
        },
        destroy: function destroy16(swiper) {
            if (swiper.params.history.enabled) {
                swiper.history.destroy();
            }
        },
        "transitionEnd _freeModeNoMomentumRelease": function transitionEnd_freeModeNoMomentumRelease(swiper) {
            if (swiper.history.initialized) {
                swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        },
        slideChange: function slideChange3(swiper) {
            if (swiper.history.initialized && swiper.params.cssMode) {
                swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
            }
        }
    }
};
function _extends$6() {
    _extends$6 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$6.apply(this, arguments);
}
var HashNavigation = {
    onHashChange: function onHashChange() {
        var swiper = this;
        var document2 = getDocument();
        swiper.emit("hashChange");
        var newHash = document2.location.hash.replace("#", "");
        var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr("data-hash");
        if (newHash !== activeSlideHash) {
            var newIndex = swiper.$wrapperEl.children("." + swiper.params.slideClass + '[data-hash="' + newHash + '"]').index();
            if (typeof newIndex === "undefined") return;
            swiper.slideTo(newIndex);
        }
    },
    setHash: function setHash() {
        var swiper = this;
        var window2 = getWindow();
        var document2 = getDocument();
        if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
        if (swiper.params.hashNavigation.replaceState && window2.history && window2.history.replaceState) {
            window2.history.replaceState(null, null, "#" + swiper.slides.eq(swiper.activeIndex).attr("data-hash") || "");
            swiper.emit("hashSet");
        } else {
            var slide2 = swiper.slides.eq(swiper.activeIndex);
            var hash = slide2.attr("data-hash") || slide2.attr("data-history");
            document2.location.hash = hash || "";
            swiper.emit("hashSet");
        }
    },
    init: function init18() {
        var swiper = this;
        var document2 = getDocument();
        var window2 = getWindow();
        if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
        swiper.hashNavigation.initialized = true;
        var hash = document2.location.hash.replace("#", "");
        if (hash) {
            var speed = 0;
            for(var i2 = 0, length = swiper.slides.length; i2 < length; i2 += 1){
                var slide2 = swiper.slides.eq(i2);
                var slideHash = slide2.attr("data-hash") || slide2.attr("data-history");
                if (slideHash === hash && !slide2.hasClass(swiper.params.slideDuplicateClass)) {
                    var index2 = slide2.index();
                    swiper.slideTo(index2, speed, swiper.params.runCallbacksOnInit, true);
                }
            }
        }
        if (swiper.params.hashNavigation.watchState) {
            $(window2).on("hashchange", swiper.hashNavigation.onHashChange);
        }
    },
    destroy: function destroy17() {
        var swiper = this;
        var window2 = getWindow();
        if (swiper.params.hashNavigation.watchState) {
            $(window2).off("hashchange", swiper.hashNavigation.onHashChange);
        }
    }
};
var HashNavigation$1 = {
    name: "hash-navigation",
    params: {
        hashNavigation: {
            enabled: false,
            replaceState: false,
            watchState: false
        }
    },
    create: function create15() {
        var swiper = this;
        bindModuleMethods(swiper, {
            hashNavigation: _extends$6({
                initialized: false
            }, HashNavigation)
        });
    },
    on: {
        init: function init19(swiper) {
            if (swiper.params.hashNavigation.enabled) {
                swiper.hashNavigation.init();
            }
        },
        destroy: function destroy18(swiper) {
            if (swiper.params.hashNavigation.enabled) {
                swiper.hashNavigation.destroy();
            }
        },
        "transitionEnd _freeModeNoMomentumRelease": function transitionEnd_freeModeNoMomentumRelease2(swiper) {
            if (swiper.hashNavigation.initialized) {
                swiper.hashNavigation.setHash();
            }
        },
        slideChange: function slideChange4(swiper) {
            if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
                swiper.hashNavigation.setHash();
            }
        }
    }
};
function _extends$5() {
    _extends$5 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$5.apply(this, arguments);
}
var Autoplay = {
    run: function run() {
        var swiper = this;
        var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
        var delay = swiper.params.autoplay.delay;
        if ($activeSlideEl.attr("data-swiper-autoplay")) {
            delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper.params.autoplay.delay;
        }
        clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.timeout = nextTick3(function() {
            var autoplayResult;
            if (swiper.params.autoplay.reverseDirection) {
                if (swiper.params.loop) {
                    swiper.loopFix();
                    autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                    swiper.emit("autoplay");
                } else if (!swiper.isBeginning) {
                    autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
                    swiper.emit("autoplay");
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                    swiper.emit("autoplay");
                } else {
                    swiper.autoplay.stop();
                }
            } else if (swiper.params.loop) {
                swiper.loopFix();
                autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                swiper.emit("autoplay");
            } else if (!swiper.isEnd) {
                autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
                swiper.emit("autoplay");
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
                autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
                swiper.emit("autoplay");
            } else {
                swiper.autoplay.stop();
            }
            if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();
            else if (autoplayResult === false) {
                swiper.autoplay.run();
            }
        }, delay);
    },
    start: function start() {
        var swiper = this;
        if (typeof swiper.autoplay.timeout !== "undefined") return false;
        if (swiper.autoplay.running) return false;
        swiper.autoplay.running = true;
        swiper.emit("autoplayStart");
        swiper.autoplay.run();
        return true;
    },
    stop: function stop() {
        var swiper = this;
        if (!swiper.autoplay.running) return false;
        if (typeof swiper.autoplay.timeout === "undefined") return false;
        if (swiper.autoplay.timeout) {
            clearTimeout(swiper.autoplay.timeout);
            swiper.autoplay.timeout = void 0;
        }
        swiper.autoplay.running = false;
        swiper.emit("autoplayStop");
        return true;
    },
    pause: function pause(speed) {
        var swiper = this;
        if (!swiper.autoplay.running) return;
        if (swiper.autoplay.paused) return;
        if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.paused = true;
        if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
            swiper.autoplay.paused = false;
            swiper.autoplay.run();
        } else {
            [
                "transitionend",
                "webkitTransitionEnd"
            ].forEach(function(event2) {
                swiper.$wrapperEl[0].addEventListener(event2, swiper.autoplay.onTransitionEnd);
            });
        }
    },
    onVisibilityChange: function onVisibilityChange() {
        var swiper = this;
        var document2 = getDocument();
        if (document2.visibilityState === "hidden" && swiper.autoplay.running) {
            swiper.autoplay.pause();
        }
        if (document2.visibilityState === "visible" && swiper.autoplay.paused) {
            swiper.autoplay.run();
            swiper.autoplay.paused = false;
        }
    },
    onTransitionEnd: function onTransitionEnd2(e) {
        var swiper = this;
        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
        if (e.target !== swiper.$wrapperEl[0]) return;
        [
            "transitionend",
            "webkitTransitionEnd"
        ].forEach(function(event2) {
            swiper.$wrapperEl[0].removeEventListener(event2, swiper.autoplay.onTransitionEnd);
        });
        swiper.autoplay.paused = false;
        if (!swiper.autoplay.running) {
            swiper.autoplay.stop();
        } else {
            swiper.autoplay.run();
        }
    },
    onMouseEnter: function onMouseEnter() {
        var swiper = this;
        if (swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.stop();
        } else {
            swiper.autoplay.pause();
        }
        [
            "transitionend",
            "webkitTransitionEnd"
        ].forEach(function(event2) {
            swiper.$wrapperEl[0].removeEventListener(event2, swiper.autoplay.onTransitionEnd);
        });
    },
    onMouseLeave: function onMouseLeave() {
        var swiper = this;
        if (swiper.params.autoplay.disableOnInteraction) {
            return;
        }
        swiper.autoplay.paused = false;
        swiper.autoplay.run();
    },
    attachMouseEvents: function attachMouseEvents() {
        var swiper = this;
        if (swiper.params.autoplay.pauseOnMouseEnter) {
            swiper.$el.on("mouseenter", swiper.autoplay.onMouseEnter);
            swiper.$el.on("mouseleave", swiper.autoplay.onMouseLeave);
        }
    },
    detachMouseEvents: function detachMouseEvents() {
        var swiper = this;
        swiper.$el.off("mouseenter", swiper.autoplay.onMouseEnter);
        swiper.$el.off("mouseleave", swiper.autoplay.onMouseLeave);
    }
};
var Autoplay$1 = {
    name: "autoplay",
    params: {
        autoplay: {
            enabled: false,
            delay: 3e3,
            waitForTransition: true,
            disableOnInteraction: true,
            stopOnLastSlide: false,
            reverseDirection: false,
            pauseOnMouseEnter: false
        }
    },
    create: function create16() {
        var swiper = this;
        bindModuleMethods(swiper, {
            autoplay: _extends$5({}, Autoplay, {
                running: false,
                paused: false
            })
        });
    },
    on: {
        init: function init20(swiper) {
            if (swiper.params.autoplay.enabled) {
                swiper.autoplay.start();
                var document2 = getDocument();
                document2.addEventListener("visibilitychange", swiper.autoplay.onVisibilityChange);
                swiper.autoplay.attachMouseEvents();
            }
        },
        beforeTransitionStart: function beforeTransitionStart(swiper, speed, internal) {
            if (swiper.autoplay.running) {
                if (internal || !swiper.params.autoplay.disableOnInteraction) {
                    swiper.autoplay.pause(speed);
                } else {
                    swiper.autoplay.stop();
                }
            }
        },
        sliderFirstMove: function sliderFirstMove(swiper) {
            if (swiper.autoplay.running) {
                if (swiper.params.autoplay.disableOnInteraction) {
                    swiper.autoplay.stop();
                } else {
                    swiper.autoplay.pause();
                }
            }
        },
        touchEnd: function touchEnd2(swiper) {
            if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
                swiper.autoplay.run();
            }
        },
        destroy: function destroy19(swiper) {
            swiper.autoplay.detachMouseEvents();
            if (swiper.autoplay.running) {
                swiper.autoplay.stop();
            }
            var document2 = getDocument();
            document2.removeEventListener("visibilitychange", swiper.autoplay.onVisibilityChange);
        }
    }
};
function _extends$4() {
    _extends$4 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$4.apply(this, arguments);
}
var Fade = {
    setTranslate: function setTranslate9() {
        var swiper = this;
        var slides = swiper.slides;
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            var $slideEl = swiper.slides.eq(i2);
            var offset2 = $slideEl[0].swiperSlideOffset;
            var tx = -offset2;
            if (!swiper.params.virtualTranslate) tx -= swiper.translate;
            var ty = 0;
            if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
            }
            var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
            $slideEl.css({
                opacity: slideOpacity
            }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
        }
    },
    setTransition: function setTransition8(duration) {
        var swiper = this;
        var slides = swiper.slides, $wrapperEl = swiper.$wrapperEl;
        slides.transition(duration);
        if (swiper.params.virtualTranslate && duration !== 0) {
            var eventTriggered = false;
            slides.transitionEnd(function() {
                if (eventTriggered) return;
                if (!swiper || swiper.destroyed) return;
                eventTriggered = true;
                swiper.animating = false;
                var triggerEvents = [
                    "webkitTransitionEnd",
                    "transitionend"
                ];
                for(var i2 = 0; i2 < triggerEvents.length; i2 += 1){
                    $wrapperEl.trigger(triggerEvents[i2]);
                }
            });
        }
    }
};
var EffectFade = {
    name: "effect-fade",
    params: {
        fadeEffect: {
            crossFade: false
        }
    },
    create: function create17() {
        var swiper = this;
        bindModuleMethods(swiper, {
            fadeEffect: _extends$4({}, Fade)
        });
    },
    on: {
        beforeInit: function beforeInit4(swiper) {
            if (swiper.params.effect !== "fade") return;
            swiper.classNames.push(swiper.params.containerModifierClass + "fade");
            var overwriteParams = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: true
            };
            extend(swiper.params, overwriteParams);
            extend(swiper.originalParams, overwriteParams);
        },
        setTranslate: function setTranslate10(swiper) {
            if (swiper.params.effect !== "fade") return;
            swiper.fadeEffect.setTranslate();
        },
        setTransition: function setTransition9(swiper, duration) {
            if (swiper.params.effect !== "fade") return;
            swiper.fadeEffect.setTransition(duration);
        }
    }
};
function _extends$3() {
    _extends$3 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$3.apply(this, arguments);
}
var Cube = {
    setTranslate: function setTranslate11() {
        var swiper = this;
        var $el = swiper.$el, $wrapperEl = swiper.$wrapperEl, slides = swiper.slides, swiperWidth = swiper.width, swiperHeight = swiper.height, rtl = swiper.rtlTranslate, swiperSize = swiper.size, browser2 = swiper.browser;
        var params = swiper.params.cubeEffect;
        var isHorizontal = swiper.isHorizontal();
        var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        var wrapperRotate = 0;
        var $cubeShadowEl;
        if (params.shadow) {
            if (isHorizontal) {
                $cubeShadowEl = $wrapperEl.find(".swiper-cube-shadow");
                if ($cubeShadowEl.length === 0) {
                    $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                    $wrapperEl.append($cubeShadowEl);
                }
                $cubeShadowEl.css({
                    height: swiperWidth + "px"
                });
            } else {
                $cubeShadowEl = $el.find(".swiper-cube-shadow");
                if ($cubeShadowEl.length === 0) {
                    $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                    $el.append($cubeShadowEl);
                }
            }
        }
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            var $slideEl = slides.eq(i2);
            var slideIndex = i2;
            if (isVirtual) {
                slideIndex = parseInt($slideEl.attr("data-swiper-slide-index"), 10);
            }
            var slideAngle = slideIndex * 90;
            var round = Math.floor(slideAngle / 360);
            if (rtl) {
                slideAngle = -slideAngle;
                round = Math.floor(-slideAngle / 360);
            }
            var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
            var tx = 0;
            var ty = 0;
            var tz = 0;
            if (slideIndex % 4 === 0) {
                tx = -round * 4 * swiperSize;
                tz = 0;
            } else if ((slideIndex - 1) % 4 === 0) {
                tx = 0;
                tz = -round * 4 * swiperSize;
            } else if ((slideIndex - 2) % 4 === 0) {
                tx = swiperSize + round * 4 * swiperSize;
                tz = swiperSize;
            } else if ((slideIndex - 3) % 4 === 0) {
                tx = -swiperSize;
                tz = 3 * swiperSize + swiperSize * 4 * round;
            }
            if (rtl) {
                tx = -tx;
            }
            if (!isHorizontal) {
                ty = tx;
                tx = 0;
            }
            var transform2 = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
            if (progress <= 1 && progress > -1) {
                wrapperRotate = slideIndex * 90 + progress * 90;
                if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
            }
            $slideEl.transform(transform2);
            if (params.slideShadows) {
                var shadowBefore = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
                var shadowAfter = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                if (shadowBefore.length === 0) {
                    shadowBefore = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "left" : "top") + '"></div>');
                    $slideEl.append(shadowBefore);
                }
                if (shadowAfter.length === 0) {
                    shadowAfter = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "right" : "bottom") + '"></div>');
                    $slideEl.append(shadowAfter);
                }
                if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
            }
        }
        $wrapperEl.css({
            "-webkit-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
            "-moz-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
            "-ms-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
            "transform-origin": "50% 50% -" + swiperSize / 2 + "px"
        });
        if (params.shadow) {
            if (isHorizontal) {
                $cubeShadowEl.transform("translate3d(0px, " + (swiperWidth / 2 + params.shadowOffset) + "px, " + -swiperWidth / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + params.shadowScale + ")");
            } else {
                var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                var scale1 = params.shadowScale;
                var scale2 = params.shadowScale / multiplier;
                var offset2 = params.shadowOffset;
                $cubeShadowEl.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (swiperHeight / 2 + offset2) + "px, " + -swiperHeight / 2 / scale2 + "px) rotateX(-90deg)");
            }
        }
        var zFactor = browser2.isSafari || browser2.isWebView ? -swiperSize / 2 : 0;
        $wrapperEl.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)");
    },
    setTransition: function setTransition10(duration) {
        var swiper = this;
        var $el = swiper.$el, slides = swiper.slides;
        slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
            $el.find(".swiper-cube-shadow").transition(duration);
        }
    }
};
var EffectCube = {
    name: "effect-cube",
    params: {
        cubeEffect: {
            slideShadows: true,
            shadow: true,
            shadowOffset: 20,
            shadowScale: 0.94
        }
    },
    create: function create18() {
        var swiper = this;
        bindModuleMethods(swiper, {
            cubeEffect: _extends$3({}, Cube)
        });
    },
    on: {
        beforeInit: function beforeInit5(swiper) {
            if (swiper.params.effect !== "cube") return;
            swiper.classNames.push(swiper.params.containerModifierClass + "cube");
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            var overwriteParams = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: false,
                virtualTranslate: true
            };
            extend(swiper.params, overwriteParams);
            extend(swiper.originalParams, overwriteParams);
        },
        setTranslate: function setTranslate12(swiper) {
            if (swiper.params.effect !== "cube") return;
            swiper.cubeEffect.setTranslate();
        },
        setTransition: function setTransition11(swiper, duration) {
            if (swiper.params.effect !== "cube") return;
            swiper.cubeEffect.setTransition(duration);
        }
    }
};
function _extends$2() {
    _extends$2 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$2.apply(this, arguments);
}
var Flip = {
    setTranslate: function setTranslate13() {
        var swiper = this;
        var slides = swiper.slides, rtl = swiper.rtlTranslate;
        for(var i2 = 0; i2 < slides.length; i2 += 1){
            var $slideEl = slides.eq(i2);
            var progress = $slideEl[0].progress;
            if (swiper.params.flipEffect.limitRotation) {
                progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
            }
            var offset2 = $slideEl[0].swiperSlideOffset;
            var rotate = -180 * progress;
            var rotateY = rotate;
            var rotateX = 0;
            var tx = -offset2;
            var ty = 0;
            if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
                rotateX = -rotateY;
                rotateY = 0;
            } else if (rtl) {
                rotateY = -rotateY;
            }
            $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
            if (swiper.params.flipEffect.slideShadows) {
                var shadowBefore = swiper.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
                var shadowAfter = swiper.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                if (shadowBefore.length === 0) {
                    shadowBefore = $('<div class="swiper-slide-shadow-' + (swiper.isHorizontal() ? "left" : "top") + '"></div>');
                    $slideEl.append(shadowBefore);
                }
                if (shadowAfter.length === 0) {
                    shadowAfter = $('<div class="swiper-slide-shadow-' + (swiper.isHorizontal() ? "right" : "bottom") + '"></div>');
                    $slideEl.append(shadowAfter);
                }
                if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
            }
            $slideEl.transform("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)");
        }
    },
    setTransition: function setTransition12(duration) {
        var swiper = this;
        var slides = swiper.slides, activeIndex = swiper.activeIndex, $wrapperEl = swiper.$wrapperEl;
        slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
        if (swiper.params.virtualTranslate && duration !== 0) {
            var eventTriggered = false;
            slides.eq(activeIndex).transitionEnd(function onTransitionEnd3() {
                if (eventTriggered) return;
                if (!swiper || swiper.destroyed) return;
                eventTriggered = true;
                swiper.animating = false;
                var triggerEvents = [
                    "webkitTransitionEnd",
                    "transitionend"
                ];
                for(var i2 = 0; i2 < triggerEvents.length; i2 += 1){
                    $wrapperEl.trigger(triggerEvents[i2]);
                }
            });
        }
    }
};
var EffectFlip = {
    name: "effect-flip",
    params: {
        flipEffect: {
            slideShadows: true,
            limitRotation: true
        }
    },
    create: function create19() {
        var swiper = this;
        bindModuleMethods(swiper, {
            flipEffect: _extends$2({}, Flip)
        });
    },
    on: {
        beforeInit: function beforeInit6(swiper) {
            if (swiper.params.effect !== "flip") return;
            swiper.classNames.push(swiper.params.containerModifierClass + "flip");
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            var overwriteParams = {
                slidesPerView: 1,
                slidesPerColumn: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: true
            };
            extend(swiper.params, overwriteParams);
            extend(swiper.originalParams, overwriteParams);
        },
        setTranslate: function setTranslate14(swiper) {
            if (swiper.params.effect !== "flip") return;
            swiper.flipEffect.setTranslate();
        },
        setTransition: function setTransition13(swiper, duration) {
            if (swiper.params.effect !== "flip") return;
            swiper.flipEffect.setTransition(duration);
        }
    }
};
function _extends$1() {
    _extends$1 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$1.apply(this, arguments);
}
var Coverflow = {
    setTranslate: function setTranslate15() {
        var swiper = this;
        var swiperWidth = swiper.width, swiperHeight = swiper.height, slides = swiper.slides, slidesSizesGrid = swiper.slidesSizesGrid;
        var params = swiper.params.coverflowEffect;
        var isHorizontal = swiper.isHorizontal();
        var transform2 = swiper.translate;
        var center = isHorizontal ? -transform2 + swiperWidth / 2 : -transform2 + swiperHeight / 2;
        var rotate = isHorizontal ? params.rotate : -params.rotate;
        var translate2 = params.depth;
        for(var i2 = 0, length = slides.length; i2 < length; i2 += 1){
            var $slideEl = slides.eq(i2);
            var slideSize = slidesSizesGrid[i2];
            var slideOffset = $slideEl[0].swiperSlideOffset;
            var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
            var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
            var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
            var translateZ = -translate2 * Math.abs(offsetMultiplier);
            var stretch = params.stretch;
            if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
                stretch = parseFloat(params.stretch) / 100 * slideSize;
            }
            var translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
            var translateX = isHorizontal ? stretch * offsetMultiplier : 0;
            var scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
            if (Math.abs(translateX) < 1e-3) translateX = 0;
            if (Math.abs(translateY) < 1e-3) translateY = 0;
            if (Math.abs(translateZ) < 1e-3) translateZ = 0;
            if (Math.abs(rotateY) < 1e-3) rotateY = 0;
            if (Math.abs(rotateX) < 1e-3) rotateX = 0;
            if (Math.abs(scale) < 1e-3) scale = 0;
            var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg) scale(" + scale + ")";
            $slideEl.transform(slideTransform);
            $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
            if (params.slideShadows) {
                var $shadowBeforeEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
                var $shadowAfterEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
                if ($shadowBeforeEl.length === 0) {
                    $shadowBeforeEl = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "left" : "top") + '"></div>');
                    $slideEl.append($shadowBeforeEl);
                }
                if ($shadowAfterEl.length === 0) {
                    $shadowAfterEl = $('<div class="swiper-slide-shadow-' + (isHorizontal ? "right" : "bottom") + '"></div>');
                    $slideEl.append($shadowAfterEl);
                }
                if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
            }
        }
    },
    setTransition: function setTransition14(duration) {
        var swiper = this;
        swiper.slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
    }
};
var EffectCoverflow = {
    name: "effect-coverflow",
    params: {
        coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            scale: 1,
            modifier: 1,
            slideShadows: true
        }
    },
    create: function create20() {
        var swiper = this;
        bindModuleMethods(swiper, {
            coverflowEffect: _extends$1({}, Coverflow)
        });
    },
    on: {
        beforeInit: function beforeInit7(swiper) {
            if (swiper.params.effect !== "coverflow") return;
            swiper.classNames.push(swiper.params.containerModifierClass + "coverflow");
            swiper.classNames.push(swiper.params.containerModifierClass + "3d");
            swiper.params.watchSlidesProgress = true;
            swiper.originalParams.watchSlidesProgress = true;
        },
        setTranslate: function setTranslate16(swiper) {
            if (swiper.params.effect !== "coverflow") return;
            swiper.coverflowEffect.setTranslate();
        },
        setTransition: function setTransition15(swiper, duration) {
            if (swiper.params.effect !== "coverflow") return;
            swiper.coverflowEffect.setTransition(duration);
        }
    }
};
function _extends2() {
    _extends2 = Object.assign || function(target) {
        for(var i2 = 1; i2 < arguments.length; i2++){
            var source = arguments[i2];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends2.apply(this, arguments);
}
var Thumbs = {
    init: function init21() {
        var swiper = this;
        var thumbsParams = swiper.params.thumbs;
        if (swiper.thumbs.initialized) return false;
        swiper.thumbs.initialized = true;
        var SwiperClass = swiper.constructor;
        if (thumbsParams.swiper instanceof SwiperClass) {
            swiper.thumbs.swiper = thumbsParams.swiper;
            extend(swiper.thumbs.swiper.originalParams, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
            extend(swiper.thumbs.swiper.params, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
        } else if (isObject2(thumbsParams.swiper)) {
            swiper.thumbs.swiper = new SwiperClass(extend({}, thumbsParams.swiper, {
                watchSlidesVisibility: true,
                watchSlidesProgress: true,
                slideToClickedSlide: false
            }));
            swiper.thumbs.swiperCreated = true;
        }
        swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
        swiper.thumbs.swiper.on("tap", swiper.thumbs.onThumbClick);
        return true;
    },
    onThumbClick: function onThumbClick() {
        var swiper = this;
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        var clickedIndex = thumbsSwiper.clickedIndex;
        var clickedSlide = thumbsSwiper.clickedSlide;
        if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
        if (typeof clickedIndex === "undefined" || clickedIndex === null) return;
        var slideToIndex;
        if (thumbsSwiper.params.loop) {
            slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr("data-swiper-slide-index"), 10);
        } else {
            slideToIndex = clickedIndex;
        }
        if (swiper.params.loop) {
            var currentIndex = swiper.activeIndex;
            if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
                swiper.loopFix();
                swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
                currentIndex = swiper.activeIndex;
            }
            var prevIndex = swiper.slides.eq(currentIndex).prevAll('[data-swiper-slide-index="' + slideToIndex + '"]').eq(0).index();
            var nextIndex = swiper.slides.eq(currentIndex).nextAll('[data-swiper-slide-index="' + slideToIndex + '"]').eq(0).index();
            if (typeof prevIndex === "undefined") slideToIndex = nextIndex;
            else if (typeof nextIndex === "undefined") slideToIndex = prevIndex;
            else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
            else slideToIndex = prevIndex;
        }
        swiper.slideTo(slideToIndex);
    },
    update: function update7(initial) {
        var swiper = this;
        var thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        var slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
        var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
        var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
            var currentThumbsIndex = thumbsSwiper.activeIndex;
            var newThumbsIndex;
            var direction;
            if (thumbsSwiper.params.loop) {
                if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
                    thumbsSwiper.loopFix();
                    thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
                    currentThumbsIndex = thumbsSwiper.activeIndex;
                }
                var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll('[data-swiper-slide-index="' + swiper.realIndex + '"]').eq(0).index();
                var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll('[data-swiper-slide-index="' + swiper.realIndex + '"]').eq(0).index();
                if (typeof prevThumbsIndex === "undefined") {
                    newThumbsIndex = nextThumbsIndex;
                } else if (typeof nextThumbsIndex === "undefined") {
                    newThumbsIndex = prevThumbsIndex;
                } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
                    newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
                } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
                    newThumbsIndex = nextThumbsIndex;
                } else {
                    newThumbsIndex = prevThumbsIndex;
                }
                direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
            } else {
                newThumbsIndex = swiper.realIndex;
                direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
            }
            if (useOffset) {
                newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
            }
            if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                if (thumbsSwiper.params.centeredSlides) {
                    if (newThumbsIndex > currentThumbsIndex) {
                        newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                    } else {
                        newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                    }
                }
                thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
            }
        }
        var thumbsToActivate = 1;
        var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
            thumbsToActivate = swiper.params.slidesPerView;
        }
        if (!swiper.params.thumbs.multipleActiveThumbs) {
            thumbsToActivate = 1;
        }
        thumbsToActivate = Math.floor(thumbsToActivate);
        thumbsSwiper.slides.removeClass(thumbActiveClass);
        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
            for(var i2 = 0; i2 < thumbsToActivate; i2 += 1){
                thumbsSwiper.$wrapperEl.children('[data-swiper-slide-index="' + (swiper.realIndex + i2) + '"]').addClass(thumbActiveClass);
            }
        } else {
            for(var _i = 0; _i < thumbsToActivate; _i += 1){
                thumbsSwiper.slides.eq(swiper.realIndex + _i).addClass(thumbActiveClass);
            }
        }
    }
};
var Thumbs$1 = {
    name: "thumbs",
    params: {
        thumbs: {
            swiper: null,
            multipleActiveThumbs: true,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-container-thumbs"
        }
    },
    create: function create21() {
        var swiper = this;
        bindModuleMethods(swiper, {
            thumbs: _extends2({
                swiper: null,
                initialized: false
            }, Thumbs)
        });
    },
    on: {
        beforeInit: function beforeInit8(swiper) {
            var thumbs = swiper.params.thumbs;
            if (!thumbs || !thumbs.swiper) return;
            swiper.thumbs.init();
            swiper.thumbs.update(true);
        },
        slideChange: function slideChange5(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
        },
        update: function update8(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
        },
        resize: function resize3(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
        },
        observerUpdate: function observerUpdate3(swiper) {
            if (!swiper.thumbs.swiper) return;
            swiper.thumbs.update();
        },
        setTransition: function setTransition16(swiper, duration) {
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) return;
            thumbsSwiper.setTransition(duration);
        },
        beforeDestroy: function beforeDestroy(swiper) {
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) return;
            if (swiper.thumbs.swiperCreated && thumbsSwiper) {
                thumbsSwiper.destroy();
            }
        }
    }
};
var components = [
    Virtual$1,
    Keyboard$1,
    Mousewheel$1,
    Navigation$1,
    Pagination$1,
    Scrollbar$1,
    Parallax$1,
    Zoom$1,
    Lazy$1,
    Controller$1,
    A11y$1,
    History$1,
    HashNavigation$1,
    Autoplay$1,
    EffectFade,
    EffectCube,
    EffectFlip,
    EffectCoverflow,
    Thumbs$1
];
Swiper$1.use(components);
var indexCss = "@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA') format('woff');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-container-vertical>.swiper-wrapper{-ms-flex-direction:column;flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:-ms-flexbox;display:flex;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform, -webkit-transform;-webkit-box-sizing:content-box;box-sizing:content-box}.swiper-container-android .swiper-slide,.swiper-wrapper{-webkit-transform:translate3d(0px,0,0);transform:translate3d(0px,0,0)}.swiper-container-multirow>.swiper-wrapper{-ms-flex-wrap:wrap;flex-wrap:wrap}.swiper-container-multirow-column>.swiper-wrapper{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-direction:column;flex-direction:column}.swiper-container-free-mode>.swiper-wrapper{-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;margin:0 auto}.swiper-container-pointer-events{-ms-touch-action:pan-y;touch-action:pan-y}.swiper-container-pointer-events.swiper-container-vertical{-ms-touch-action:pan-x;touch-action:pan-x}.swiper-slide{-ms-flex-negative:0;flex-shrink:0;width:100%;height:100%;position:relative;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform, -webkit-transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{-ms-flex-align:start;align-items:flex-start;-webkit-transition-property:height,-webkit-transform;transition-property:height,-webkit-transform;transition-property:transform,height;transition-property:transform,height,-webkit-transform}.swiper-container-3d{-webkit-perspective:1200px;perspective:1200px}.swiper-container-3d .swiper-cube-shadow,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-wrapper{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:-webkit-gradient(linear,right top, left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-right{background-image:-webkit-gradient(linear,left top, right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-top{background-image:-webkit-gradient(linear,left bottom, left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:-webkit-gradient(linear,left top, left bottom,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-container-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-container-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-container-horizontal.swiper-container-css-mode>.swiper-wrapper{-webkit-scroll-snap-type:x mandatory;-ms-scroll-snap-type:x mandatory;scroll-snap-type:x mandatory}.swiper-container-vertical.swiper-container-css-mode>.swiper-wrapper{-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory}@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA') format('woff');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}.swiper-container{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-container-vertical>.swiper-wrapper{-ms-flex-direction:column;flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:-ms-flexbox;display:flex;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform, -webkit-transform;-webkit-box-sizing:content-box;box-sizing:content-box}.swiper-container-android .swiper-slide,.swiper-wrapper{-webkit-transform:translate3d(0px,0,0);transform:translate3d(0px,0,0)}.swiper-container-multirow>.swiper-wrapper{-ms-flex-wrap:wrap;flex-wrap:wrap}.swiper-container-multirow-column>.swiper-wrapper{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-direction:column;flex-direction:column}.swiper-container-free-mode>.swiper-wrapper{-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;margin:0 auto}.swiper-container-pointer-events{-ms-touch-action:pan-y;touch-action:pan-y}.swiper-container-pointer-events.swiper-container-vertical{-ms-touch-action:pan-x;touch-action:pan-x}.swiper-slide{-ms-flex-negative:0;flex-shrink:0;width:100%;height:100%;position:relative;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;transition-property:transform;transition-property:transform, -webkit-transform}.swiper-slide-invisible-blank{visibility:hidden}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{-ms-flex-align:start;align-items:flex-start;-webkit-transition-property:height,-webkit-transform;transition-property:height,-webkit-transform;transition-property:transform,height;transition-property:transform,height,-webkit-transform}.swiper-container-3d{-webkit-perspective:1200px;perspective:1200px}.swiper-container-3d .swiper-cube-shadow,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-wrapper{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:-webkit-gradient(linear,right top, left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-right{background-image:-webkit-gradient(linear,left top, right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-top{background-image:-webkit-gradient(linear,left bottom, left top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:-webkit-gradient(linear,left top, left bottom,from(rgba(0,0,0,.5)),to(rgba(0,0,0,0)));background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-container-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-container-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-container-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-container-horizontal.swiper-container-css-mode>.swiper-wrapper{-webkit-scroll-snap-type:x mandatory;-ms-scroll-snap-type:x mandatory;scroll-snap-type:x mandatory}.swiper-container-vertical.swiper-container-css-mode>.swiper-wrapper{-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory}:root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:50%;width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;text-transform:none;font-variant:initial;line-height:1}.swiper-button-prev,.swiper-container-rtl .swiper-button-next{left:10px;right:auto}.swiper-button-prev:after,.swiper-container-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-container-rtl .swiper-button-prev{right:10px;left:auto}.swiper-button-next:after,.swiper-container-rtl .swiper-button-prev:after{content:'next'}.swiper-button-next.swiper-button-white,.swiper-button-prev.swiper-button-white{--swiper-navigation-color:#ffffff}.swiper-button-next.swiper-button-black,.swiper-button-prev.swiper-button-black{--swiper-navigation-color:#000000}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;-webkit-transition:.3s opacity;transition:.3s opacity;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-container-horizontal>.swiper-pagination-bullets,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transform:scale(.33);transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{-webkit-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{-webkit-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{-webkit-transform:scale(.66);transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{-webkit-transform:scale(.33);transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{-webkit-transform:scale(.66);transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{-webkit-transform:scale(.33);transform:scale(.33)}.swiper-pagination-bullet{width:8px;height:8px;display:inline-block;border-radius:50%;background:#000;opacity:.2}button.swiper-pagination-bullet{border:none;margin:0;padding:0;-webkit-box-shadow:none;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet-active{opacity:1;background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-container-vertical>.swiper-pagination-bullets{right:10px;top:50%;-webkit-transform:translate3d(0px,-50%,0);transform:translate3d(0px,-50%,0)}.swiper-container-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:6px 0;display:block}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);width:8px}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;-webkit-transition:.2s transform,.2s top;transition:.2s transform,.2s top}.swiper-container-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 4px}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%);white-space:nowrap}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:.2s transform,.2s left;transition:.2s transform,.2s left}.swiper-container-horizontal.swiper-container-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:.2s transform,.2s right;transition:.2s transform,.2s right}.swiper-pagination-progressbar{background:rgba(0,0,0,.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;-webkit-transform:scale(0);transform:scale(0);-webkit-transform-origin:left top;transform-origin:left top}.swiper-container-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{-webkit-transform-origin:right top;transform-origin:right top}.swiper-container-horizontal>.swiper-pagination-progressbar,.swiper-container-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-container-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-container-vertical>.swiper-pagination-progressbar{width:4px;height:100%;left:0;top:0}.swiper-pagination-white{--swiper-pagination-color:#ffffff}.swiper-pagination-black{--swiper-pagination-color:#000000}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0,0,0,.1)}.swiper-container-horizontal>.swiper-scrollbar{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-container-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0,0,0,.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;-o-object-fit:contain;object-fit:contain}.swiper-slide-zoomed{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;-webkit-transform-origin:50%;transform-origin:50%;-webkit-animation:swiper-preloader-spin 1s infinite linear;animation:swiper-preloader-spin 1s infinite linear;-webkit-box-sizing:border-box;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@-webkit-keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-container-fade.swiper-container-free-mode .swiper-slide{-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out}.swiper-container-fade .swiper-slide{pointer-events:none;-webkit-transition-property:opacity;transition-property:opacity}.swiper-container-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube{overflow:visible}.swiper-container-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;-webkit-transform-origin:0 0;transform-origin:0 0;width:100%;height:100%}.swiper-container-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-cube.swiper-container-rtl .swiper-slide{-webkit-transform-origin:100% 0;transform-origin:100% 0}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-next+.swiper-slide,.swiper-container-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-container-cube .swiper-slide-shadow-bottom,.swiper-container-cube .swiper-slide-shadow-left,.swiper-container-cube .swiper-slide-shadow-right,.swiper-container-cube .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-container-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;-webkit-filter:blur(50px);filter:blur(50px)}.swiper-container-flip{overflow:visible}.swiper-container-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-container-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-flip .swiper-slide-active,.swiper-container-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-flip .swiper-slide-shadow-bottom,.swiper-container-flip .swiper-slide-shadow-left,.swiper-container-flip .swiper-slide-shadow-right,.swiper-container-flip .swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}taro-swiper-core{display:block;height:150px}taro-swiper-core .swiper-container{height:100%}taro-swiper-core .swiper-pagination{font-size:0}taro-swiper-core .swiper-pagination.swiper-pagination-bullet{opacity:1}taro-swiper-core .swiper-pagination.swiper-pagination-hidden{display:none}";
var INSTANCE_ID = 0;
var Swiper = proxyCustomElement(class extends H {
    watchCurrent(newVal) {
        if (!this.isWillLoadCalled) return;
        const n = parseInt(newVal, 10);
        if (isNaN(n)) return;
        if (this.circular) {
            if (!this.swiper.isBeginning && !this.swiper.isEnd) {
                this.swiper.slideToLoop(n);
            }
        } else {
            this.swiper.slideTo(n);
        }
    }
    watchAutoplay(newVal) {
        if (!this.isWillLoadCalled || !this.swiper) return;
        const swiperAutoplay = this.swiper.autoplay;
        if (swiperAutoplay) {
            if (swiperAutoplay.running === newVal) return;
            if (newVal) {
                if (this.swiper.params && typeof this.swiper.params.autoplay === "object") {
                    if (this.swiper.params.autoplay.disableOnInteraction === true) {
                        this.swiper.params.autoplay.disableOnInteraction = false;
                    }
                    this.swiper.params.autoplay.delay = this.interval;
                }
                swiperAutoplay.start();
            } else {
                swiperAutoplay.stop();
            }
        }
    }
    watchDuration(newVal) {
        if (!this.isWillLoadCalled) return;
        this.swiper.params.speed = newVal;
    }
    watchInterval(newVal) {
        if (!this.isWillLoadCalled) return;
        if (typeof this.swiper.params.autoplay === "object") {
            this.swiper.params.autoplay.delay = newVal;
        }
    }
    watchSwiperWrapper(newVal) {
        if (!this.isWillLoadCalled) return;
        if (!newVal) return;
        this.el.appendChild = (newChild)=>{
            return newVal.appendChild(newChild);
        };
        this.el.insertBefore = (newChild, refChild)=>{
            return newVal.insertBefore(newChild, refChild);
        };
        this.el.replaceChild = (newChild, oldChild)=>{
            return newVal.replaceChild(newChild, oldChild);
        };
        this.el.removeChild = (oldChild)=>{
            return newVal.removeChild(oldChild);
        };
        this.el.addEventListener("DOMNodeInserted", this.handleSwiperSize);
        this.el.addEventListener("DOMNodeRemoved", this.handleSwiperSize);
    }
    watchCircular() {
        if (this.swiper) {
            this.swiper.destroy();
            this.handleInit();
        }
    }
    watchDisplayMultipleItems() {
        if (this.swiper) {
            this.swiper.destroy();
            this.handleInit();
        }
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
    }
    componentDidLoad() {
        var _a;
        this.handleInit();
        if (!this.swiper || !this.circular) return;
        const wrapper = (_a = this.swiper.$wrapperEl) === null || _a === void 0 ? void 0 : _a[0];
        this.observer = new MutationObserver(this.handleSwiperLoopListen);
        this.observer.observe(wrapper, {
            childList: true
        });
    }
    componentWillUpdate() {
        var _a, _b;
        if (!this.swiper) return;
        if (this.autoplay && !((_a = this.swiper.autoplay) === null || _a === void 0 ? void 0 : _a.running)) {
            (_b = this.swiper.autoplay) === null || _b === void 0 ? void 0 : _b.start();
        }
        this.swiper.update();
    }
    componentDidRender() {
        this.handleSwiperLoop();
    }
    disconnectedCallback() {
        var _a, _b, _c, _d, _e, _f;
        this.el.removeEventListener("DOMNodeInserted", this.handleSwiperSize);
        this.el.removeEventListener("DOMNodeRemoved", this.handleSwiperSize);
        (_b = (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect) === null || _b === void 0 ? void 0 : _b.call(_a);
        (_d = (_c = this.observerFirst) === null || _c === void 0 ? void 0 : _c.disconnect) === null || _d === void 0 ? void 0 : _d.call(_c);
        (_f = (_e = this.observerLast) === null || _e === void 0 ? void 0 : _e.disconnect) === null || _f === void 0 ? void 0 : _f.call(_e);
    }
    handleInit() {
        const { autoplay , circular , current , displayMultipleItems , duration , interval , vertical  } = this;
        const that = this;
        const options3 = {
            pagination: {
                el: `.taro-swiper-${this._id} > .swiper-container > .swiper-pagination`
            },
            direction: vertical ? "vertical" : "horizontal",
            loop: circular,
            slidesPerView: displayMultipleItems,
            initialSlide: current,
            speed: duration,
            observer: true,
            observeParents: true,
            zoom: this.zoom,
            on: {
                slideTo () {
                    that.current = this.realIndex;
                },
                slideChangeTransitionStart (_swiper) {
                    if (that.circular) {
                        if (_swiper.isBeginning || _swiper.isEnd) {
                            return;
                        }
                    }
                    that.onChange.emit({
                        current: this.realIndex,
                        source: ""
                    });
                },
                transitionEnd () {
                    that.onAnimationFinish.emit({
                        current: this.realIndex,
                        source: ""
                    });
                },
                observerUpdate (_swiper, e) {
                    const target = e.target;
                    const className = target && typeof target.className === "string" ? target.className : "";
                    if (className.includes("taro_page") && target.style.display !== "none") {
                        if (that.autoplay && target.contains(_swiper.$el[0])) {
                            if (that.circular) {
                                _swiper.slideToLoop(this.realIndex, 0);
                            } else {
                                _swiper.slideTo(this.realIndex);
                            }
                        }
                    }
                }
            }
        };
        if (autoplay) {
            options3.autoplay = {
                delay: interval,
                disableOnInteraction: false
            };
        }
        this.swiper = new Swiper$1(`.taro-swiper-${this._id} > .swiper-container`, options3);
        this.swiperWrapper = this.el.querySelector(`.taro-swiper-${this._id} > .swiper-container > .swiper-wrapper`);
    }
    render() {
        const { vertical , indicatorDots , indicatorColor , indicatorActiveColor  } = this;
        const hostStyle = {
            overflow: "hidden"
        };
        const style = {
            overflow: "visible"
        };
        if (this.full) {
            hostStyle.height = "100%";
            style.height = "100%";
        }
        const [, previousMargin] = /^(\d+)px/.exec(this.previousMargin) || [];
        const [, nextMargin] = /^(\d+)px/.exec(this.nextMargin) || [];
        const pM = parseInt(previousMargin) || 0;
        const nM = parseInt(nextMargin) || 0;
        if (vertical) {
            style.marginTop = `${pM}px`;
            style.marginBottom = `${nM}px`;
        } else {
            style.marginRight = `${nM}px`;
            style.marginLeft = `${pM}px`;
        }
        return h(Host, {
            class: `taro-swiper-${this._id}`,
            style: hostStyle
        }, h("div", {
            class: "swiper-container",
            style
        }, h("style", {
            type: "text/css"
        }, `
              .taro-swiper-${this._id} > .swiper-container > .swiper-pagination > .swiper-pagination-bullet { background: ${indicatorColor} }
              .taro-swiper-${this._id} > .swiper-container > .swiper-pagination > .swiper-pagination-bullet-active { background: ${indicatorActiveColor} }
            `), h("div", {
            class: "swiper-wrapper"
        }, h("slot", null)), h("div", {
            class: classnames("swiper-pagination", {
                "swiper-pagination-hidden": !indicatorDots,
                "swiper-pagination-bullets": indicatorDots
            })
        })));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "current": [
                "watchCurrent"
            ],
            "autoplay": [
                "watchAutoplay"
            ],
            "duration": [
                "watchDuration"
            ],
            "interval": [
                "watchInterval"
            ],
            "swiperWrapper": [
                "watchSwiperWrapper"
            ],
            "circular": [
                "watchCircular"
            ],
            "displayMultipleItems": [
                "watchDisplayMultipleItems"
            ]
        };
    }
    static get style() {
        return indexCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onAnimationFinish = createEvent(this, "animationfinish", 7);
        this._id = INSTANCE_ID++;
        this.handleSwiperLoopListen = ()=>{
            var _a, _b, _c;
            ((_a = this.observerFirst) === null || _a === void 0 ? void 0 : _a.disconnect) && this.observerFirst.disconnect();
            ((_b = this.observerLast) === null || _b === void 0 ? void 0 : _b.disconnect) && this.observerLast.disconnect();
            this.observerFirst = new MutationObserver(this.handleSwiperLoop);
            this.observerLast = new MutationObserver(this.handleSwiperLoop);
            const wrapper = (_c = this.swiper.$wrapperEl) === null || _c === void 0 ? void 0 : _c[0];
            const list = wrapper.querySelectorAll("taro-swiper-item-core:not(.swiper-slide-duplicate)");
            if (list.length >= 1) {
                this.observerFirst.observe(list[0], {
                    characterData: true
                });
            } else if (list.length >= 2) {
                this.observerLast.observe(list[list.length - 1], {
                    characterData: true
                });
            }
        };
        this.handleSwiperLoop = debounce2(()=>{
            if (this.swiper && this.circular) {
                this.swiper.loopFix();
            }
        }, 50);
        this.handleSwiperSize = debounce2(()=>{
            if (this.swiper && !this.circular) {
                this.swiper.updateSlides();
            }
        }, 50);
        this.swiperWrapper = void 0;
        this.swiper = void 0;
        this.isWillLoadCalled = false;
        this.indicatorDots = false;
        this.indicatorColor = "rgba(0, 0, 0, .3)";
        this.indicatorActiveColor = "#000000";
        this.autoplay = false;
        this.current = 0;
        this.interval = 5e3;
        this.duration = 500;
        this.circular = false;
        this.vertical = false;
        this.previousMargin = "0px";
        this.nextMargin = "0px";
        this.displayMultipleItems = 1;
        this.full = false;
        this.zoom = false;
        this.observer = void 0;
        this.observerFirst = void 0;
        this.observerLast = void 0;
    }
}, [
    4,
    "taro-swiper-core",
    {
        "indicatorDots": [
            4,
            "indicator-dots"
        ],
        "indicatorColor": [
            1,
            "indicator-color"
        ],
        "indicatorActiveColor": [
            1,
            "indicator-active-color"
        ],
        "autoplay": [
            4
        ],
        "current": [
            2
        ],
        "interval": [
            2
        ],
        "duration": [
            2
        ],
        "circular": [
            4
        ],
        "vertical": [
            4
        ],
        "previousMargin": [
            1,
            "previous-margin"
        ],
        "nextMargin": [
            1,
            "next-margin"
        ],
        "displayMultipleItems": [
            2,
            "display-multiple-items"
        ],
        "full": [
            4
        ],
        "zoom": [
            4
        ],
        "swiperWrapper": [
            32
        ],
        "swiper": [
            32
        ],
        "isWillLoadCalled": [
            32
        ],
        "observer": [
            32
        ],
        "observerFirst": [
            32
        ],
        "observerLast": [
            32
        ]
    }
]);
// node_modules/@tarojs/components/dist/components/taro-swiper-item-core.js
function isEqualTag(a, b) {
    return typeof a.tagName === "undefined" ? a.nodeType === b.nodeType : a.tagName === b.tagName;
}
function parseChildNodes(items, targets) {
    const list = Array.from(targets.values());
    for(let i2 = 0, j = 0; i2 < list.length; i2++, j++){
        const target = list[i2];
        let item = items.item(j);
        while(item && !isEqualTag(item, target)){
            item.remove();
            j++;
            item = items.item(j);
        }
        if (item && !item.isEqualNode(target)) {
            parseChildNodes(item.childNodes, target.childNodes);
        }
        while(i2 === list.length - 1 && j < items.length){
            j++;
            item = items.item(j);
            item === null || item === void 0 ? void 0 : item.remove();
        }
    }
}
var SwiperItem = proxyCustomElement(class extends H {
    componentDidRender() {
        var _a, _b, _c;
        const el = this.el;
        if (el.classList.contains("swiper-slide-duplicate")) {
            const list = Array.from(((_b = (_a = el.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.values()) || []).filter((e)=>e.tagName === "TARO-SWIPER-ITEM-CORE");
            if (list.length > 0) {
                parseChildNodes(el.childNodes, (_c = list[list.indexOf(el) === 0 ? list.length - 2 : 1]) === null || _c === void 0 ? void 0 : _c.childNodes);
            }
        }
    }
    render() {
        return h(Host, {
            class: "swiper-slide",
            "item-id": this.itemId
        });
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.itemId = void 0;
    }
}, [
    0,
    "taro-swiper-item-core",
    {
        "itemId": [
            1,
            "item-id"
        ]
    }
]);
// node_modules/@tarojs/taro-h5/dist/api/media/image/previewImage.js
var previewImage = (options3)=>__awaiter4(void 0, void 0, void 0, function*() {
        if (false) {
            defineCustomElement();
            defineCustomElement$1();
        }
        function loadImage2(url, loadFail) {
            return new Promise((resolve)=>{
                const item = document.createElement("taro-swiper-item-core");
                item.style.cssText = "display:flex;align-items:start;justify-content:center;overflow-y:scroll;";
                const image = new Image();
                image.style.maxWidth = "100%";
                image.src = url;
                const div = document.createElement("div");
                div.classList.add("swiper-zoom-container");
                div.style.cssText = "display:flex;align-items:center;justify-content:center;max-width:100%;min-height:100%;";
                div.appendChild(image);
                item.appendChild(div);
                resolve(item);
                if (isFunction(loadFail)) {
                    image.addEventListener("error", (err)=>{
                        loadFail({
                            errMsg: err.message
                        });
                    });
                }
            });
        }
        const isObject3 = shouldBeObject(options3);
        if (!isObject3.flag) {
            const res = {
                errMsg: `previewImage:fail ${isObject3.msg}`
            };
            console.error(res.errMsg);
            return Promise.reject(res);
        }
        const { urls =[] , current ="" , success , fail , complete  } = options3;
        const handle3 = new MethodHandler({
            name: "previewImage",
            success,
            fail,
            complete
        });
        const container = document.createElement("div");
        container.classList.add("preview-image");
        container.style.cssText = "position:fixed;top:0;left:0;z-index:1050;width:100%;height:100%;overflow:hidden;outline:0;background-color:#111;";
        container.addEventListener("click", ()=>{
            container.remove();
        });
        const swiper = document.createElement("taro-swiper-core");
        swiper.full = true;
        swiper.zoom = true;
        let children2 = [];
        try {
            children2 = yield Promise.all(urls.map((e)=>loadImage2(e, fail)));
        } catch (error) {
            return handle3.fail({
                errMsg: error
            });
        }
        for(let i2 = 0; i2 < children2.length; i2++){
            const child = children2[i2];
            swiper.appendChild(child);
        }
        const currentIndex = urls.indexOf(current);
        swiper.current = currentIndex;
        container.appendChild(swiper);
        document.body.appendChild(container);
        return handle3.success();
    });
// node_modules/@tarojs/taro-h5/dist/api/media/image/chooseImage.js
var chooseImage = function(options3) {
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res2 = {
            errMsg: `chooseImage:fail ${isObject3.msg}`
        };
        console.error(res2.errMsg);
        return Promise.reject(res2);
    }
    const { count =1 , success , fail , complete , imageId ="taroChooseImage" , sourceType =[
        "album",
        "camera"
    ]  } = options3;
    const handle3 = new MethodHandler({
        name: "chooseImage",
        success,
        fail,
        complete
    });
    const res = {
        tempFilePaths: [],
        tempFiles: []
    };
    const sourceTypeString = sourceType && sourceType.toString();
    const acceptableSourceType = [
        "user",
        "environment",
        "camera"
    ];
    if (count && typeof count !== "number") {
        res.errMsg = getParameterError({
            para: "count",
            correct: "Number",
            wrong: count
        });
        return handle3.fail(res);
    }
    let el = document.getElementById(imageId);
    if (!el) {
        const obj = document.createElement("input");
        obj.setAttribute("type", "file");
        obj.setAttribute("id", imageId);
        if (count > 1) {
            obj.setAttribute("multiple", "multiple");
        }
        if (acceptableSourceType.indexOf(sourceTypeString) > -1) {
            obj.setAttribute("capture", sourceTypeString);
        }
        obj.setAttribute("accept", "image/*");
        obj.setAttribute("style", "position: fixed; top: -4000px; left: -3000px; z-index: -300;");
        document.body.appendChild(obj);
        el = document.getElementById(imageId);
    } else {
        if (count > 1) {
            el.setAttribute("multiple", "multiple");
        } else {
            el.removeAttribute("multiple");
        }
        if (acceptableSourceType.indexOf(sourceTypeString) > -1) {
            el.setAttribute("capture", sourceTypeString);
        } else {
            el.removeAttribute("capture");
        }
    }
    return new Promise((resolve, reject)=>{
        const TaroMouseEvents = document.createEvent("MouseEvents");
        TaroMouseEvents.initEvent("click", true, true);
        if (el) {
            el.dispatchEvent(TaroMouseEvents);
            el.onchange = function(e) {
                const target = e.target;
                if (target) {
                    const files = target.files || [];
                    const arr = [
                        ...files
                    ];
                    arr && arr.forEach((item)=>{
                        var _a, _b;
                        const blob = new Blob([
                            item
                        ], {
                            type: item.type
                        });
                        const url = URL.createObjectURL(blob);
                        (_a = res.tempFilePaths) === null || _a === void 0 ? void 0 : _a.push(url);
                        (_b = res.tempFiles) === null || _b === void 0 ? void 0 : _b.push({
                            path: url,
                            size: item.size,
                            type: item.type,
                            originalFileObj: item
                        });
                    });
                    handle3.success(res, {
                        resolve,
                        reject
                    });
                    target.value = "";
                }
            };
        }
    });
};
// node_modules/@tarojs/taro-h5/dist/api/media/image/index.js
var saveImageToPhotosAlbum = temporarilyNotSupport("saveImageToPhotosAlbum");
var previewMedia = temporarilyNotSupport("previewMedia");
var compressImage = temporarilyNotSupport("compressImage");
var chooseMessageFile = temporarilyNotSupport("chooseMessageFile");
// node_modules/@tarojs/taro-h5/dist/api/media/live.js
var createLivePusherContext = temporarilyNotSupport("createLivePusherContext");
var createLivePlayerContext = temporarilyNotSupport("createLivePlayerContext");
// node_modules/@tarojs/taro-h5/dist/api/media/map.js
var createMapContext = temporarilyNotSupport("createMapContext");
// node_modules/@tarojs/taro-h5/dist/api/media/media-recorder.js
var createMediaRecorder = temporarilyNotSupport("createMediaRecorder");
// node_modules/@tarojs/taro-h5/dist/api/media/recorder.js
var stopRecord = temporarilyNotSupport("stopRecord");
var startRecord = temporarilyNotSupport("startRecord");
var getRecorderManager = temporarilyNotSupport("getRecorderManager");
// node_modules/@tarojs/taro-h5/dist/api/media/video/index.js
var saveVideoToPhotosAlbum = temporarilyNotSupport("saveVideoToPhotosAlbum");
var openVideoEditor = temporarilyNotSupport("openVideoEditor");
var getVideoInfo = temporarilyNotSupport("getVideoInfo");
var createVideoContext = (id, inst)=>{
    const el = findDOM(inst);
    return el === null || el === void 0 ? void 0 : el.querySelector(`taro-video-core[id=${id}]`);
};
var compressVideo = temporarilyNotSupport("compressVideo");
var chooseVideo = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res2 = {
            errMsg: `chooseVideo:fail ${isObject3.msg}`
        };
        console.error(res2.errMsg);
        return Promise.reject(res2);
    }
    const { success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "chooseVideo",
        success,
        fail,
        complete
    });
    const res = {
        tempFilePath: "",
        duration: 0,
        size: 0,
        height: 0,
        width: 0
    };
    const inputEl = document.createElement("input");
    inputEl.setAttribute("type", "file");
    inputEl.setAttribute("multiple", "multiple");
    inputEl.setAttribute("accept", "video/*");
    inputEl.setAttribute("style", "position: fixed; top: -4000px; left: -3000px; z-index: -300;");
    document.body.appendChild(inputEl);
    return new Promise((resolve, reject)=>{
        const TaroMouseEvents = document.createEvent("MouseEvents");
        TaroMouseEvents.initEvent("click", true, true);
        inputEl.dispatchEvent(TaroMouseEvents);
        inputEl.onchange = function(e) {
            var _a;
            const target = e.target;
            const file = (_a = target.files) === null || _a === void 0 ? void 0 : _a[0];
            const reader = new FileReader();
            reader.onload = function(event2) {
                var _a2;
                const videoEl = document.createElement("video");
                const url = (_a2 = event2.target) === null || _a2 === void 0 ? void 0 : _a2.result;
                videoEl.preload = "metadata";
                videoEl.src = url;
                videoEl.onloadedmetadata = ()=>{
                    res.tempFilePath = url;
                    res.duration = videoEl.duration;
                    res.size = event2.total;
                    res.height = videoEl.videoHeight;
                    res.width = videoEl.videoHeight;
                    return handle3.success(res, {
                        resolve,
                        reject
                    });
                };
            };
            if (file) {
                reader.readAsDataURL(file);
            }
        };
    }).finally(()=>{
        document.body.removeChild(inputEl);
    });
};
var chooseMedia = temporarilyNotSupport("chooseMedia");
// node_modules/@tarojs/taro-h5/dist/api/media/video-decoder.js
var createVideoDecoder = temporarilyNotSupport("createVideoDecoder");
// node_modules/@tarojs/taro-h5/dist/api/media/video-processing.js
var createMediaContainer = temporarilyNotSupport("createMediaContainer");
// node_modules/@tarojs/taro-h5/dist/api/media/voip.js
var updateVoIPChatMuteConfig = temporarilyNotSupport("updateVoIPChatMuteConfig");
var subscribeVoIPVideoMembers = temporarilyNotSupport("subscribeVoIPVideoMembers");
var setEnable1v1Chat = temporarilyNotSupport("setEnable1v1Chat");
var onVoIPVideoMembersChanged = temporarilyNotSupport("onVoIPVideoMembersChanged");
var onVoIPChatStateChanged = temporarilyNotSupport("onVoIPChatStateChanged");
var onVoIPChatSpeakersChanged = temporarilyNotSupport("onVoIPChatSpeakersChanged");
var onVoIPChatMembersChanged = temporarilyNotSupport("onVoIPChatMembersChanged");
var onVoIPChatInterrupted = temporarilyNotSupport("onVoIPChatInterrupted");
var offVoIPVideoMembersChanged = temporarilyNotSupport("offVoIPVideoMembersChanged");
var offVoIPChatStateChanged = temporarilyNotSupport("offVoIPChatStateChanged");
var offVoIPChatMembersChanged = temporarilyNotSupport("offVoIPChatMembersChanged");
var offVoIPChatInterrupted = temporarilyNotSupport("offVoIPChatInterrupted");
var joinVoIPChat = temporarilyNotSupport("joinVoIPChat");
var exitVoIPChat = temporarilyNotSupport("exitVoIPChat");
// node_modules/@tarojs/taro-h5/dist/api/navigate/index.js
var openEmbeddedMiniProgram = temporarilyNotSupport("openEmbeddedMiniProgram");
var navigateToMiniProgram = temporarilyNotSupport("navigateToMiniProgram");
var navigateBackMiniProgram = temporarilyNotSupport("navigateBackMiniProgram");
var exitMiniProgram = temporarilyNotSupport("exitMiniProgram");
var openBusinessView = temporarilyNotSupport("openBusinessView");
// node_modules/@tarojs/taro-h5/dist/api/network/utils.js
var NETWORK_TIMEOUT = 6e4;
var XHR_STATS = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
};
var setHeader = (xhr, header)=>{
    let headerKey;
    for(headerKey in header){
        xhr.setRequestHeader(headerKey, header[headerKey]);
    }
};
var convertObjectUrlToBlob = (url)=>{
    return new Promise((resolve, reject)=>{
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "blob";
        xhr.withCredentials = true;
        xhr.onload = function() {
            if (this.status === 200) {
                resolve(this.response);
            } else {
                reject({
                    status: this.status
                });
            }
        };
        xhr.send();
    });
};
// node_modules/@tarojs/taro-h5/dist/api/network/download.js
var createDownloadTask = ({ url , header , withCredentials =true , timeout , success , error  })=>{
    let timeoutInter;
    const apiName = "downloadFile";
    const xhr = new XMLHttpRequest();
    const callbackManager5 = {
        headersReceived: new CallbackManager(),
        progressUpdate: new CallbackManager()
    };
    xhr.open("GET", url, true);
    xhr.withCredentials = !!withCredentials;
    xhr.responseType = "blob";
    setHeader(xhr, header);
    xhr.onprogress = (e)=>{
        const { loaded , total  } = e;
        callbackManager5.progressUpdate.trigger({
            progress: Math.round(loaded / total * 100),
            totalBytesWritten: loaded,
            totalBytesExpectedToWrite: total
        });
    };
    xhr.onreadystatechange = ()=>{
        if (xhr.readyState !== XHR_STATS.HEADERS_RECEIVED) return;
        callbackManager5.headersReceived.trigger({
            header: xhr.getAllResponseHeaders()
        });
    };
    xhr.onload = ()=>{
        const response = xhr.response;
        const status2 = xhr.status;
        success({
            errMsg: `${apiName}:ok`,
            statusCode: status2,
            tempFilePath: window.URL.createObjectURL(response)
        });
    };
    xhr.onabort = ()=>{
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail abort`
        });
    };
    xhr.onerror = (e)=>{
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    };
    const abort = ()=>{
        xhr.abort();
    };
    const send = ()=>{
        xhr.send();
        timeoutInter = setTimeout(()=>{
            xhr.onabort = null;
            xhr.onload = null;
            xhr.onprogress = null;
            xhr.onreadystatechange = null;
            xhr.onerror = null;
            abort();
            error({
                errMsg: `${apiName}:fail timeout`
            });
        }, timeout || NETWORK_TIMEOUT);
    };
    send();
    const onHeadersReceived = callbackManager5.headersReceived.add;
    const offHeadersReceived = callbackManager5.headersReceived.remove;
    const onProgressUpdate = callbackManager5.progressUpdate.add;
    const offProgressUpdate = callbackManager5.progressUpdate.remove;
    return {
        abort,
        onHeadersReceived,
        offHeadersReceived,
        onProgressUpdate,
        offProgressUpdate
    };
};
var downloadFile = ({ url , header , withCredentials , timeout , success , fail , complete  })=>{
    let task;
    const result = new Promise((resolve, reject)=>{
        task = createDownloadTask({
            url,
            header,
            withCredentials,
            timeout,
            success: (res)=>{
                success && success(res);
                complete && complete(res);
                resolve(res);
            },
            error: (res)=>{
                fail && fail(res);
                complete && complete(res);
                reject(res);
            }
        });
    });
    result.headersReceive = task.onHeadersReceived;
    result.progress = task.onProgressUpdate;
    return new Proxy(result, {
        get (target, prop) {
            const object = prop in task ? task : target;
            const value = object[prop];
            return typeof value === "function" ? value.bind(object) : value;
        }
    });
};
// node_modules/@tarojs/taro-h5/dist/api/network/mdns.js
var stopLocalServiceDiscovery = temporarilyNotSupport("stopLocalServiceDiscovery");
var startLocalServiceDiscovery = temporarilyNotSupport("startLocalServiceDiscovery");
var onLocalServiceResolveFail = temporarilyNotSupport("onLocalServiceResolveFail");
var onLocalServiceLost = temporarilyNotSupport("onLocalServiceLost");
var onLocalServiceFound = temporarilyNotSupport("onLocalServiceFound");
var onLocalServiceDiscoveryStop = temporarilyNotSupport("onLocalServiceDiscoveryStop");
var offLocalServiceResolveFail = temporarilyNotSupport("offLocalServiceResolveFail");
var offLocalServiceLost = temporarilyNotSupport("offLocalServiceLost");
var offLocalServiceFound = temporarilyNotSupport("offLocalServiceFound");
var offLocalServiceDiscoveryStop = temporarilyNotSupport("offLocalServiceDiscoveryStop");
// node_modules/whatwg-fetch/fetch.js
var global2 = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
var support2 = {
    searchParams: "URLSearchParams" in global2,
    iterable: "Symbol" in global2 && "iterator" in Symbol,
    blob: "FileReader" in global2 && "Blob" in global2 && function() {
        try {
            new Blob();
            return true;
        } catch (e) {
            return false;
        }
    }(),
    formData: "FormData" in global2,
    arrayBuffer: "ArrayBuffer" in global2
};
function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support2.arrayBuffer) {
    viewClasses = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
    ];
    isArrayBufferView = ArrayBuffer.isView || function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
    if (typeof name !== "string") {
        name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
        throw new TypeError('Invalid character in header field name: "' + name + '"');
    }
    return name.toLowerCase();
}
function normalizeValue(value) {
    if (typeof value !== "string") {
        value = String(value);
    }
    return value;
}
function iteratorFor(items) {
    var iterator = {
        next: function() {
            var value = items.shift();
            return {
                done: value === void 0,
                value
            };
        }
    };
    if (support2.iterable) {
        iterator[Symbol.iterator] = function() {
            return iterator;
        };
    }
    return iterator;
}
function Headers(headers) {
    this.map = {};
    if (headers instanceof Headers) {
        headers.forEach(function(value, name) {
            this.append(name, value);
        }, this);
    } else if (Array.isArray(headers)) {
        headers.forEach(function(header) {
            this.append(header[0], header[1]);
        }, this);
    } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
        }, this);
    }
}
Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
    delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
    for(var name in this.map){
        if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
        }
    }
};
Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
        items.push(name);
    });
    return iteratorFor(items);
};
Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
        items.push(value);
    });
    return iteratorFor(items);
};
Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
        items.push([
            name,
            value
        ]);
    });
    return iteratorFor(items);
};
if (support2.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
    if (body.bodyUsed) {
        return Promise.reject(new TypeError("Already read"));
    }
    body.bodyUsed = true;
}
function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
        reader.onload = function() {
            resolve(reader.result);
        };
        reader.onerror = function() {
            reject(reader.error);
        };
    });
}
function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise;
}
function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise;
}
function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);
    for(var i2 = 0; i2 < view.length; i2++){
        chars[i2] = String.fromCharCode(view[i2]);
    }
    return chars.join("");
}
function bufferClone(buf) {
    if (buf.slice) {
        return buf.slice(0);
    } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
    }
}
function Body() {
    this.bodyUsed = false;
    this._initBody = function(body) {
        this.bodyUsed = this.bodyUsed;
        this._bodyInit = body;
        if (!body) {
            this._bodyText = "";
        } else if (typeof body === "string") {
            this._bodyText = body;
        } else if (support2.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
        } else if (support2.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
        } else if (support2.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
        } else if (support2.arrayBuffer && support2.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([
                this._bodyArrayBuffer
            ]);
        } else if (support2.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
        } else {
            this._bodyText = body = Object.prototype.toString.call(body);
        }
        if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
            } else if (support2.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
        }
    };
    if (support2.blob) {
        this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
                return rejected;
            }
            if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([
                    this._bodyArrayBuffer
                ]));
            } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
            } else {
                return Promise.resolve(new Blob([
                    this._bodyText
                ]));
            }
        };
        this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                    return isConsumed;
                }
                if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                    return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
                } else {
                    return Promise.resolve(this._bodyArrayBuffer);
                }
            } else {
                return this.blob().then(readBlobAsArrayBuffer);
            }
        };
    }
    this.text = function() {
        var rejected = consumed(this);
        if (rejected) {
            return rejected;
        }
        if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
        } else {
            return Promise.resolve(this._bodyText);
        }
    };
    if (support2.formData) {
        this.formData = function() {
            return this.text().then(decode);
        };
    }
    this.json = function() {
        return this.text().then(JSON.parse);
    };
    return this;
}
var methods = [
    "DELETE",
    "GET",
    "HEAD",
    "OPTIONS",
    "POST",
    "PUT"
];
function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options3) {
    if (!(this instanceof Request)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    options3 = options3 || {};
    var body = options3.body;
    if (input instanceof Request) {
        if (input.bodyUsed) {
            throw new TypeError("Already read");
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options3.headers) {
            this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        this.signal = input.signal;
        if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
        }
    } else {
        this.url = String(input);
    }
    this.credentials = options3.credentials || this.credentials || "same-origin";
    if (options3.headers || !this.headers) {
        this.headers = new Headers(options3.headers);
    }
    this.method = normalizeMethod(options3.method || this.method || "GET");
    this.mode = options3.mode || this.mode || null;
    this.signal = options3.signal || this.signal;
    this.referrer = null;
    if ((this.method === "GET" || this.method === "HEAD") && body) {
        throw new TypeError("Body not allowed for GET or HEAD requests");
    }
    this._initBody(body);
    if (this.method === "GET" || this.method === "HEAD") {
        if (options3.cache === "no-store" || options3.cache === "no-cache") {
            var reParamSearch = /([?&])_=[^&]*/;
            if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
            } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
            }
        }
    }
}
Request.prototype.clone = function() {
    return new Request(this, {
        body: this._bodyInit
    });
};
function decode(body) {
    var form = new FormData();
    body.trim().split("&").forEach(function(bytes) {
        if (bytes) {
            var split = bytes.split("=");
            var name = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
    });
    return form;
}
function parseHeaders(rawHeaders) {
    var headers = new Headers();
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
    preProcessedHeaders.split("\r").map(function(header) {
        return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
    }).forEach(function(line) {
        var parts = line.split(":");
        var key = parts.shift().trim();
        if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
        }
    });
    return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options3) {
    if (!(this instanceof Response)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    if (!options3) {
        options3 = {};
    }
    this.type = "default";
    this.status = options3.status === void 0 ? 200 : options3.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options3.statusText === void 0 ? "" : "" + options3.statusText;
    this.headers = new Headers(options3.headers);
    this.url = options3.url || "";
    this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
    });
};
Response.error = function() {
    var response = new Response(null, {
        status: 0,
        statusText: ""
    });
    response.type = "error";
    return response;
};
var redirectStatuses = [
    301,
    302,
    303,
    307,
    308
];
Response.redirect = function(url, status2) {
    if (redirectStatuses.indexOf(status2) === -1) {
        throw new RangeError("Invalid status code");
    }
    return new Response(null, {
        status: status2,
        headers: {
            location: url
        }
    });
};
var DOMException = global2.DOMException;
try {
    new DOMException();
} catch (err) {
    DOMException = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
    };
    DOMException.prototype = Object.create(Error.prototype);
    DOMException.prototype.constructor = DOMException;
}
function fetch2(input, init23) {
    return new Promise(function(resolve, reject) {
        var request2 = new Request(input, init23);
        if (request2.signal && request2.signal.aborted) {
            return reject(new DOMException("Aborted", "AbortError"));
        }
        var xhr = new XMLHttpRequest();
        function abortXhr() {
            xhr.abort();
        }
        xhr.onload = function() {
            var options3 = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options3.url = "responseURL" in xhr ? xhr.responseURL : options3.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            setTimeout(function() {
                resolve(new Response(body, options3));
            }, 0);
        };
        xhr.onerror = function() {
            setTimeout(function() {
                reject(new TypeError("Network request failed"));
            }, 0);
        };
        xhr.ontimeout = function() {
            setTimeout(function() {
                reject(new TypeError("Network request failed"));
            }, 0);
        };
        xhr.onabort = function() {
            setTimeout(function() {
                reject(new DOMException("Aborted", "AbortError"));
            }, 0);
        };
        function fixUrl(url) {
            try {
                return url === "" && global2.location.href ? global2.location.href : url;
            } catch (e) {
                return url;
            }
        }
        xhr.open(request2.method, fixUrl(request2.url), true);
        if (request2.credentials === "include") {
            xhr.withCredentials = true;
        } else if (request2.credentials === "omit") {
            xhr.withCredentials = false;
        }
        if ("responseType" in xhr) {
            if (support2.blob) {
                xhr.responseType = "blob";
            } else if (support2.arrayBuffer && request2.headers.get("Content-Type") && request2.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                xhr.responseType = "arraybuffer";
            }
        }
        if (init23 && typeof init23.headers === "object" && !(init23.headers instanceof Headers)) {
            Object.getOwnPropertyNames(init23.headers).forEach(function(name) {
                xhr.setRequestHeader(name, normalizeValue(init23.headers[name]));
            });
        } else {
            request2.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
            });
        }
        if (request2.signal) {
            request2.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    request2.signal.removeEventListener("abort", abortXhr);
                }
            };
        }
        xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
    });
}
fetch2.polyfill = true;
if (!global2.fetch) {
    global2.fetch = fetch2;
    global2.Headers = Headers;
    global2.Request = Request;
    global2.Response = Response;
}
// node_modules/jsonp-retry/dist/jsonp.esm.js
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) {
            return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
        }
        var test2 = {};
        for(var i2 = 0; i2 < 10; i2++){
            test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join("") !== "0123456789") {
            return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
        }
        return true;
    } catch (err) {
        return false;
    }
}
var objectAssign$1 = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from){
            if (hasOwnProperty2.call(from, key)) {
                to[key] = from[key];
            }
        }
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i2 = 0; i2 < symbols.length; i2++){
                if (propIsEnumerable.call(from, symbols[i2])) {
                    to[symbols[i2]] = from[symbols[i2]];
                }
            }
        }
    }
    return to;
};
var enc = encodeURIComponent;
function serializeParams2(params) {
    if (!params) {
        return "";
    }
    return Object.keys(params).map(function(item) {
        return item + "=" + enc(params[item]);
    }).join("&");
}
function isFunction3(fn) {
    return typeof fn === "function";
}
function getUrlQueryParamByName(url, name) {
    if (!url) {
        url = window.location.href;
    }
    name = name.replace(/[[]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)");
    var results = regex.exec(url);
    if (!results) {
        return null;
    }
    if (!results[2]) {
        return "";
    }
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}
function updateQueryStringParamByName(url, name, value) {
    var re = new RegExp("([?&])" + name + "=.*?(&|$)", "i");
    var separator = url.indexOf("?") !== -1 ? "&" : "?";
    if (url.match(re)) {
        return url.replace(re, "$1" + name + "=" + value + "$2");
    }
    return url + separator + name + "=" + value;
}
var win$1 = typeof window !== "undefined" ? window : global;
var localStorageName = "localStorage";
var storage = win$1[localStorageName];
var store = {
    disabled: false,
    set: function set(key, val) {
        if (val === void 0) {
            return store.remove(key);
        }
        storage.setItem(key, store.serialize(val));
        return val;
    },
    get: function get(key, defaultVal) {
        var val = store.deserialize(storage.getItem(key));
        return val === void 0 ? defaultVal : val;
    },
    remove: function remove2(key) {
        storage.removeItem(key);
    },
    clear: function clear() {
        storage.clear();
    },
    has: function has(key) {
        return store.get(key) !== void 0;
    },
    forEach: function forEach(callback) {
        for(var i2 = 0; i2 < storage.length; i2++){
            var key = storage.key(i2);
            callback(key, store.get(key));
        }
    },
    getAll: function getAll() {
        var ret = {};
        store.forEach(function(key, val) {
            ret[key] = val;
        });
        return ret;
    },
    serialize: function serialize(value) {
        return JSON.stringify(value);
    },
    deserialize: function deserialize(value) {
        if (typeof value !== "string") {
            return;
        }
        try {
            return JSON.parse(value);
        } catch (err) {
            return value || void 0;
        }
    }
};
try {
    testKey = "__store__";
    store.set(testKey, testKey);
    if (store.get(testKey) !== testKey) {
        store.disabled = true;
    }
    store.remove(testKey);
} catch (err) {
    store.disabled = true;
}
var testKey;
store.enabled = !store.disabled;
var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var win2 = typeof window !== "undefined" ? window : global;
var canUsePromise = function() {
    return "Promise" in win2 && _typeof2(isFunction3(Promise));
}();
var noop = function noop2() {};
var encodeC = encodeURIComponent;
var doc2 = win2.document;
var head = doc2 ? doc2.head || doc2.getElementsByTagName("head")[0] : null;
var TIMEOUT_CONST = 2e3;
var defaultConfig = {
    timeout: TIMEOUT_CONST,
    retryTimes: 2,
    backup: null,
    params: {},
    jsonp: "callback",
    name: null,
    cache: false,
    useStore: false,
    storeCheck: null,
    storeSign: null,
    storeCheckKey: null,
    dataCheck: null,
    charset: "UTF-8"
};
var timestamp = new Date().getTime();
function jsonp$1(url, opts, cb) {
    if (isFunction3(url)) {
        cb = url;
        opts = {};
    } else if (url && (typeof url === "undefined" ? "undefined" : _typeof2(url)) === "object") {
        cb = opts;
        opts = url || {};
        url = opts.url;
    }
    if (isFunction3(opts)) {
        cb = opts;
        opts = {};
    }
    if (!opts) {
        opts = {};
    }
    opts = objectAssign$1({}, defaultConfig, opts);
    url = url || opts.url;
    cb = cb || noop;
    if (!url || typeof url !== "string") {
        cb(new Error("Param url is needed!"));
        if (!jsonp$1.promiseClose && canUsePromise) {
            return new Promise(function(resolve, reject) {
                return reject(new Error("Param url is needed!"));
            });
        }
        return;
    }
    var urlWithParams = generateJsonpUrlWithParams(url, opts.params);
    var datafromStore = getDataFromStore({
        useStore: opts.useStore,
        storeKey: urlWithParams,
        storeCheck: opts.storeCheck,
        storeCheckKey: opts.storeCheckKey,
        storeSign: opts.storeSign,
        dataCheck: opts.dataCheck
    });
    if (datafromStore) {
        cb(null, datafromStore);
        if (!jsonp$1.promiseClose && canUsePromise) {
            return new Promise(function(resolve) {
                return resolve(datafromStore);
            });
        }
        return;
    }
    opts.originalUrl = urlWithParams;
    if (!jsonp$1.promiseClose && canUsePromise) {
        return new Promise(function(resolve, reject) {
            fetchData(urlWithParams, opts, function(err, data) {
                if (err) {
                    cb(err);
                    return reject(err);
                }
                cb(null, data);
                resolve(data);
            });
        });
    }
    fetchData(urlWithParams, opts, cb);
}
function generateJsonpUrlWithParams(url, params) {
    params = typeof params === "string" ? params : serializeParams2(params);
    url += (~url.indexOf("?") ? "&" : "?") + ("" + params);
    url = url.replace("?&", "?");
    return url;
}
function fetchData(url, opts, cb) {
    var originalUrl = opts.originalUrl;
    var charset = opts.charset;
    var jsonpUrlQueryParam = getUrlQueryParamByName(url, opts.jsonp);
    var funcId = (jsonpUrlQueryParam === "?" ? false : jsonpUrlQueryParam) || opts.name || "__jsonp" + timestamp++;
    var gotoBackupInfo = arguments[3] || null;
    if (jsonpUrlQueryParam) {
        if (jsonpUrlQueryParam === "?") {
            url = updateQueryStringParamByName(url, opts.jsonp, encodeC(funcId));
        }
    } else {
        url += (url.split("").pop() === "&" ? "" : "&") + (opts.jsonp + "=" + encodeC(funcId));
    }
    if (!opts.cache) {
        url += (url.split("").pop() === "&" ? "" : "&") + ("_=" + new Date().getTime());
    }
    clearTimeout(win2["timer_" + funcId]);
    var prevFunc = win2[funcId];
    win2[funcId] = function(data) {
        prevFunc && prevFunc(data);
        cleanup(funcId);
        if (gotoBackupInfo) {
            data.__$$backupCall = gotoBackupInfo;
        }
        if (opts.dataCheck) {
            if (opts.dataCheck(data) !== false) {
                setDataToStore({
                    useStore: opts.useStore,
                    storeKey: originalUrl,
                    data
                });
                return cb(null, data);
            }
            if (fallback(originalUrl, opts, cb) === false) {
                cb(new Error("Data check error, and no fallback"));
            }
        } else {
            setDataToStore({
                useStore: opts.useStore,
                storeKey: originalUrl,
                data
            });
            cb(null, data);
        }
    };
    var script = appendScriptTagToHead({
        url,
        charset
    });
    var timeout = opts.timeout != null ? opts.timeout : TIMEOUT_CONST;
    win2["timer_" + funcId] = setTimeout(function() {
        cleanup(funcId);
        if (typeof opts.retryTimes === "number" && opts.retryTimes > 0) {
            opts.retryTimes--;
            return fetchData(originalUrl, opts, cb);
        }
        if (fallback(originalUrl, opts, cb) === false) {
            return cb(new Error("Timeout and no data return"));
        }
    }, timeout);
    function cleanup(funcId2) {
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
        win2[funcId2] = noop;
        clearTimeout(win2["timer_" + funcId2]);
    }
}
function storeCheckFn(storeData, storeCheckKey, storeSign) {
    if (storeData && storeCheckKey && storeSign) {
        return storeData[storeCheckKey] && storeData[storeCheckKey] === storeSign;
    }
    return false;
}
function getDataFromStore(_ref) {
    var useStore = _ref.useStore, storeKey = _ref.storeKey, storeCheck = _ref.storeCheck, storeCheckKey = _ref.storeCheckKey, storeSign = _ref.storeSign, dataCheck = _ref.dataCheck;
    useStore = useStore ? store.enabled : false;
    if (useStore) {
        var storeData = store.get(storeKey);
        storeCheck = storeCheck || storeCheckFn;
        if (storeCheck(storeData, storeCheckKey, storeSign)) {
            if (!dataCheck || storeData && dataCheck && dataCheck(storeData) !== false) {
                return storeData;
            }
        }
    }
    return null;
}
function getDataFromStoreWithoutCheck(_ref2) {
    var useStore = _ref2.useStore, storeKey = _ref2.storeKey, dataCheck = _ref2.dataCheck;
    useStore = useStore ? store.enabled : false;
    if (useStore) {
        var storeData = store.get(storeKey);
        if (!dataCheck || storeData && dataCheck && dataCheck(storeData) !== false) {
            return storeData;
        }
    }
    return null;
}
function setDataToStore(_ref3) {
    var useStore = _ref3.useStore, storeKey = _ref3.storeKey, data = _ref3.data;
    useStore = useStore ? store.enabled : false;
    if (useStore) {
        store.set(storeKey, data);
    }
}
function fallback(url, opts, cb) {
    var backup = opts.backup;
    var backupWithParams = void 0;
    if (backup) {
        if (typeof backup === "string") {
            delete opts.backup;
            backupWithParams = generateJsonpUrlWithParams(backup, opts.params);
            return fetchData(backupWithParams, opts, cb, {
                backup
            });
        } else if (Array.isArray(backup)) {
            if (backup.length) {
                var backupUrl = backup.shift();
                backupWithParams = generateJsonpUrlWithParams(backupUrl, opts.params);
                return fetchData(backupWithParams, opts, cb, {
                    backup: backupUrl
                });
            }
        }
    }
    var dataFromStoreWithoutCheck = getDataFromStoreWithoutCheck({
        useStore: opts.useStore,
        storeKey: url,
        dataCheck: opts.dataCheck
    });
    if (dataFromStoreWithoutCheck) {
        cb(null, dataFromStoreWithoutCheck);
        return true;
    }
    return false;
}
function appendScriptTagToHead(_ref4) {
    var url = _ref4.url, charset = _ref4.charset;
    if (!doc2) {
        return;
    }
    var script = doc2.createElement("script");
    script.type = "text/javascript";
    if (charset) {
        script.charset = charset;
    }
    script.src = url;
    head.appendChild(script);
    return script;
}
var jsonp_esm_default = jsonp$1;
// node_modules/@tarojs/taro-h5/dist/api/network/request/index.js
var { Link: Link2  } = Taro;
function generateRequestUrlWithParams(url, params) {
    params = typeof params === "string" ? params : serializeParams(params);
    if (params) {
        url += (~url.indexOf("?") ? "&" : "?") + params;
    }
    url = url.replace("?&", "?");
    return url;
}
function _request(options3) {
    options3 = options3 || {};
    if (typeof options3 === "string") {
        options3 = {
            url: options3
        };
    }
    const { success , complete , fail  } = options3;
    let url = options3.url;
    const params = {};
    const res = {};
    if (options3.jsonp) {
        Object.assign(params, options3);
        params.params = options3.data;
        params.cache = options3.jsonpCache;
        if (typeof options3.jsonp === "string") {
            params.name = options3.jsonp;
        }
        delete params.jsonp;
        return jsonp_esm_default(url, params).then((data)=>{
            res.statusCode = 200;
            res.data = data;
            isFunction(success) && success(res);
            isFunction(complete) && complete(res);
            return res;
        }).catch((err)=>{
            isFunction(fail) && fail(err);
            isFunction(complete) && complete(res);
            return Promise.reject(err);
        });
    }
    params.method = options3.method || "GET";
    const methodUpper = params.method.toUpperCase();
    params.cache = options3.cache || "default";
    if (methodUpper === "GET" || methodUpper === "HEAD") {
        url = generateRequestUrlWithParams(url, options3.data);
    } else if (Object.prototype.toString.call(options3.data) === "[object Object]") {
        options3.header = options3.header || {};
        const keyOfContentType = Object.keys(options3.header).find((item)=>item.toLowerCase() === "content-type");
        if (!keyOfContentType) {
            options3.header["Content-Type"] = "application/json";
        }
        const contentType = options3.header[keyOfContentType || "Content-Type"];
        if (contentType.indexOf("application/json") >= 0) {
            params.body = JSON.stringify(options3.data);
        } else if (contentType.indexOf("application/x-www-form-urlencoded") >= 0) {
            params.body = serializeParams(options3.data);
        } else {
            params.body = options3.data;
        }
    } else {
        params.body = options3.data;
    }
    if (options3.header) {
        params.headers = options3.header;
    }
    if (options3.mode) {
        params.mode = options3.mode;
    }
    if (options3.signal) {
        params.signal = options3.signal;
    }
    params.credentials = options3.credentials;
    return fetch(url, params).then((response)=>{
        if (!response) {
            const errorResponse = {
                ok: false
            };
            throw errorResponse;
        }
        res.statusCode = response.status;
        res.header = {};
        for (const key of response.headers.keys()){
            res.header[key] = response.headers.get(key);
        }
        if (options3.responseType === "arraybuffer") {
            return response.arrayBuffer();
        }
        if (res.statusCode !== 204) {
            if (options3.dataType === "json" || typeof options3.dataType === "undefined") {
                return response.json().catch(()=>{
                    return null;
                });
            }
        }
        if (options3.responseType === "text" || options3.dataType === "text") {
            return response.text();
        }
        return Promise.resolve(null);
    }).then((data)=>{
        res.data = data;
        isFunction(success) && success(res);
        isFunction(complete) && complete(res);
        return res;
    }).catch((err)=>{
        isFunction(fail) && fail(err);
        isFunction(complete) && complete(res);
        err.statusCode = res.statusCode;
        err.errMsg = err.message;
        return Promise.reject(err);
    });
}
function taroInterceptor(chain) {
    return _request(chain.requestParams);
}
var link = new Link2(taroInterceptor);
var request = link.request.bind(link);
var addInterceptor = link.addInterceptor.bind(link);
// node_modules/@tarojs/taro-h5/dist/api/network/tcp.js
var createTCPSocket = temporarilyNotSupport("createTCPSocket");
// node_modules/@tarojs/taro-h5/dist/api/network/udp.js
var createUDPSocket = temporarilyNotSupport("createUDPSocket");
// node_modules/@tarojs/taro-h5/dist/api/network/upload.js
var createUploadTask = ({ url , filePath , formData ={} , name , header , timeout , fileName , withCredentials =true , success , error  })=>{
    let timeoutInter;
    let formKey;
    const apiName = "uploadFile";
    const xhr = new XMLHttpRequest();
    const form = new FormData();
    const callbackManager5 = {
        headersReceived: new CallbackManager(),
        progressUpdate: new CallbackManager()
    };
    xhr.open("POST", url);
    xhr.withCredentials = !!withCredentials;
    setHeader(xhr, header);
    for(formKey in formData){
        form.append(formKey, formData[formKey]);
    }
    xhr.upload.onprogress = (e)=>{
        const { loaded , total  } = e;
        callbackManager5.progressUpdate.trigger({
            progress: Math.round(loaded / total * 100),
            totalBytesSent: loaded,
            totalBytesExpectedToSend: total
        });
    };
    xhr.onreadystatechange = ()=>{
        if (xhr.readyState !== XHR_STATS.HEADERS_RECEIVED) return;
        callbackManager5.headersReceived.trigger({
            header: xhr.getAllResponseHeaders()
        });
    };
    xhr.onload = ()=>{
        const status2 = xhr.status;
        clearTimeout(timeoutInter);
        success({
            errMsg: `${apiName}:ok`,
            statusCode: status2,
            data: xhr.responseText || xhr.response
        });
    };
    xhr.onabort = ()=>{
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail abort`
        });
    };
    xhr.onerror = (e)=>{
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    };
    const abort = ()=>{
        clearTimeout(timeoutInter);
        xhr.abort();
    };
    const send = ()=>{
        xhr.send(form);
        timeoutInter = setTimeout(()=>{
            xhr.onabort = null;
            xhr.onload = null;
            xhr.upload.onprogress = null;
            xhr.onreadystatechange = null;
            xhr.onerror = null;
            abort();
            error({
                errMsg: `${apiName}:fail timeout`
            });
        }, timeout || NETWORK_TIMEOUT);
    };
    convertObjectUrlToBlob(filePath).then((fileObj)=>{
        if (!fileName) {
            fileName = typeof fileObj !== "string" && fileObj.name;
        }
        form.append(name, fileObj, fileName || `file-${Date.now()}`);
        send();
    }).catch((e)=>{
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    });
    const onHeadersReceived = callbackManager5.headersReceived.add;
    const offHeadersReceived = callbackManager5.headersReceived.remove;
    const onProgressUpdate = callbackManager5.progressUpdate.add;
    const offProgressUpdate = callbackManager5.progressUpdate.remove;
    return {
        abort,
        onHeadersReceived,
        offHeadersReceived,
        onProgressUpdate,
        offProgressUpdate
    };
};
var uploadFile = ({ url , filePath , name , header , formData , timeout , fileName , withCredentials , success , fail , complete  })=>{
    let task;
    const result = new Promise((resolve, reject)=>{
        task = createUploadTask({
            url,
            header,
            name,
            filePath,
            formData,
            timeout,
            fileName,
            withCredentials,
            success: (res)=>{
                success && success(res);
                complete && complete(res);
                resolve(res);
            },
            error: (res)=>{
                fail && fail(res);
                complete && complete(res);
                reject(res);
            }
        });
    });
    result.headersReceive = task.onHeadersReceived;
    result.progress = task.onProgressUpdate;
    return new Proxy(result, {
        get (target, prop) {
            const object = prop in task ? task : target;
            const value = object[prop];
            return typeof value === "function" ? value.bind(object) : value;
        }
    });
};
// node_modules/@tarojs/taro-h5/dist/api/network/websocket/socketTask.js
var SocketTask = class {
    get readyState() {
        return this.ws.readyState;
    }
    send(opts = {}) {
        if (typeof opts !== "object" || !opts) opts = {};
        const { data ="" , success , fail , complete  } = opts;
        if (this.readyState !== 1) {
            const res2 = {
                errMsg: "SocketTask.send:fail SocketTask.readState is not OPEN"
            };
            console.error(res2.errMsg);
            isFunction(fail) && fail(res2);
            isFunction(complete) && complete(res2);
            return Promise.reject(res2);
        }
        this.ws.send(data);
        const res = {
            errMsg: "sendSocketMessage:ok"
        };
        isFunction(success) && success(res);
        isFunction(complete) && complete(res);
        return Promise.resolve(res);
    }
    close(opts = {}) {
        if (typeof opts !== "object" || !opts) opts = {};
        const { code =1e3 , reason ="server complete,close" , success , complete  } = opts;
        this.closeDetail = {
            code,
            reason
        };
        this._destroyWhenClose && this._destroyWhenClose();
        this.ws.close();
        const res = {
            errMsg: "closeSocket:ok"
        };
        isFunction(success) && success(res);
        isFunction(complete) && complete(res);
        return Promise.resolve(res);
    }
    onOpen(func) {
        this.ws.onopen = func;
    }
    onMessage(func) {
        this.ws.onmessage = func;
    }
    onClose(func) {
        this.ws.onclose = ()=>{
            this._destroyWhenClose && this._destroyWhenClose();
            func(this.closeDetail || {
                code: 1006,
                reason: "abnormal closure"
            });
        };
    }
    onError(func) {
        this.ws.onerror = func;
    }
    constructor(url, protocols){
        if (protocols && protocols.length) {
            this.ws = new WebSocket(url, protocols);
        } else {
            this.ws = new WebSocket(url);
        }
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSING = 2;
        this.CLOSED = 3;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/network/websocket/index.js
var socketTasks = [];
var socketsCounter = 1;
function sendSocketMessage() {
    console.warn("Deprecated.Please use socketTask.send instead.");
}
function onSocketOpen() {
    console.warn("Deprecated.Please use socketTask.onOpen instead.");
}
function onSocketMessage() {
    console.warn("Deprecated.Please use socketTask.onMessage instead.");
}
function onSocketError() {
    console.warn("Deprecated.Please use socketTask.onError instead.");
}
function onSocketClose() {
    console.warn("Deprecated.Please use socketTask.onClose instead.");
}
function connectSocket(options3) {
    const name = "connectSocket";
    return new Promise((resolve, reject)=>{
        const isObject3 = shouldBeObject(options3);
        if (!isObject3.flag) {
            const res = {
                errMsg: `${name}:fail ${isObject3.msg}`
            };
            console.error(res.errMsg);
            return reject(res);
        }
        const { url , protocols , success , fail , complete  } = options3;
        const handle3 = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        if (typeof url !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "url",
                    correct: "String",
                    wrong: url
                })
            }, {
                resolve,
                reject
            });
        }
        if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
            return handle3.fail({
                errMsg: `request:fail invalid url "${url}"`
            }, {
                resolve,
                reject
            });
        }
        const _protocols = Array.isArray(protocols) ? protocols : null;
        if (socketTasks.length > 1) {
            return handle3.fail({
                errMsg: "\u540C\u65F6\u6700\u591A\u53D1\u8D77 2 \u4E2A socket \u8BF7\u6C42\uFF0C\u66F4\u591A\u8BF7\u53C2\u8003\u6587\u6863\u3002"
            }, {
                resolve,
                reject
            });
        }
        const task = new SocketTask(url, _protocols);
        task._destroyWhenClose = function() {
            socketTasks = socketTasks.filter((socketTask)=>socketTask !== this);
        };
        socketTasks.push(task);
        handle3.success({
            socketTaskId: socketsCounter++
        });
        return resolve(task);
    });
}
function closeSocket() {
    console.warn("Deprecated.Please use socketTask.close instead.");
}
// node_modules/@tarojs/taro-h5/dist/api/open-api/account.js
var getAccountInfoSync = temporarilyNotSupport("getAccountInfoSync");
// node_modules/@tarojs/taro-h5/dist/api/open-api/address.js
var chooseAddress = temporarilyNotSupport("chooseAddress");
// node_modules/@tarojs/taro-h5/dist/api/open-api/authorize.js
var authorizeForMiniProgram = temporarilyNotSupport("authorizeForMiniProgram");
var authorize = temporarilyNotSupport("authorize");
// node_modules/@tarojs/taro-h5/dist/api/open-api/card.js
var openCard = temporarilyNotSupport("openCard");
var addCard = temporarilyNotSupport("addCard");
// node_modules/@tarojs/taro-h5/dist/api/open-api/channels-live.js
var reserveChannelsLive = temporarilyNotSupport("reserveChannelsLive");
var openChannelsLive = temporarilyNotSupport("openChannelsLive");
var openChannelsEvent = temporarilyNotSupport("openChannelsEvent");
var openChannelsActivity = temporarilyNotSupport("openChannelsActivity");
var getChannelsLiveNoticeInfo = temporarilyNotSupport("getChannelsLiveNoticeInfo");
var getChannelsLiveInfo = temporarilyNotSupport("getChannelsLiveInfo");
// node_modules/@tarojs/taro-h5/dist/api/open-api/customer-service.js
var openCustomerServiceChat = temporarilyNotSupport("openCustomerServiceChat");
// node_modules/@tarojs/taro-h5/dist/api/open-api/facial.js
var checkIsSupportFacialRecognition = temporarilyNotSupport("checkIsSupportFacialRecognition");
var startFacialRecognitionVerify = temporarilyNotSupport("startFacialRecognitionVerify");
var startFacialRecognitionVerifyAndUploadVideo = temporarilyNotSupport("startFacialRecognitionVerifyAndUploadVideo");
var faceVerifyForPay = temporarilyNotSupport("faceVerifyForPay");
// node_modules/@tarojs/taro-h5/dist/api/open-api/favorites.js
var addVideoToFavorites = temporarilyNotSupport("addVideoToFavorites");
var addFileToFavorites = temporarilyNotSupport("addFileToFavorites");
var checkIsAddedToMyMiniProgram = temporarilyNotSupport("checkIsAddedToMyMiniProgram");
// node_modules/@tarojs/taro-h5/dist/api/open-api/group.js
var getGroupEnterInfo = temporarilyNotSupport("getGroupEnterInfo");
// node_modules/@tarojs/taro-h5/dist/api/open-api/invoice.js
var chooseInvoiceTitle = temporarilyNotSupport("chooseInvoiceTitle");
var chooseInvoice = temporarilyNotSupport("chooseInvoice");
// node_modules/@tarojs/taro-h5/dist/api/open-api/license-plate.js
var chooseLicensePlate = temporarilyNotSupport("chooseLicensePlate");
// node_modules/@tarojs/taro-h5/dist/api/open-api/login.js
var pluginLogin = temporarilyNotSupport("pluginLogin");
var login = temporarilyNotSupport("login");
var checkSession = temporarilyNotSupport("checkSession");
// node_modules/@tarojs/taro-h5/dist/api/open-api/red-package.js
var showRedPackage = temporarilyNotSupport("showRedPackage");
// node_modules/@tarojs/taro-h5/dist/api/open-api/settings.js
var openSetting = temporarilyNotSupport("openSetting");
var getSetting = temporarilyNotSupport("getSetting");
// node_modules/@tarojs/taro-h5/dist/api/open-api/soter.js
var startSoterAuthentication = temporarilyNotSupport("startSoterAuthentication");
var checkIsSupportSoterAuthentication = temporarilyNotSupport("checkIsSupportSoterAuthentication");
var checkIsSoterEnrolledInDevice = temporarilyNotSupport("checkIsSoterEnrolledInDevice");
// node_modules/@tarojs/taro-h5/dist/api/open-api/subscribe-message.js
var requestSubscribeMessage = temporarilyNotSupport("requestSubscribeMessage");
// node_modules/@tarojs/taro-h5/dist/api/open-api/user-info.js
var getUserProfile = temporarilyNotSupport("getUserProfile");
var getUserInfo = temporarilyNotSupport("getUserInfo");
// node_modules/@tarojs/taro-h5/dist/api/open-api/werun.js
var shareToWeRun = temporarilyNotSupport("shareToWeRun");
var getWeRunData = temporarilyNotSupport("getWeRunData");
// node_modules/@tarojs/taro-h5/dist/api/payment/index.js
var requestPayment = temporarilyNotSupport("requestPayment");
var requestOrderPayment = temporarilyNotSupport("requestOrderPayment");
// node_modules/@tarojs/taro-h5/dist/api/share/index.js
var updateShareMenu = temporarilyNotSupport("updateShareMenu");
var showShareMenu = temporarilyNotSupport("showShareMenu");
var showShareImageMenu = temporarilyNotSupport("showShareImageMenu");
var shareVideoMessage = temporarilyNotSupport("shareVideoMessage");
var shareFileMessage = temporarilyNotSupport("shareFileMessage");
var onCopyUrl = temporarilyNotSupport("onCopyUrl");
var offCopyUrl = temporarilyNotSupport("offCopyUrl");
var hideShareMenu = temporarilyNotSupport("hideShareMenu");
var getShareInfo = temporarilyNotSupport("getShareInfo");
var authPrivateMessage = temporarilyNotSupport("authPrivateMessage");
// node_modules/@tarojs/taro-h5/dist/api/swan/index.js
var setPageInfo = temporarilyNotSupport("setPageInfo");
var ocrIdCard = temporarilyNotSupport("ocrIdCard");
var ocrBankCard = temporarilyNotSupport("ocrBankCard");
var ocrDrivingLicense = temporarilyNotSupport("ocrDrivingLicense");
var ocrVehicleLicense = temporarilyNotSupport("ocrVehicleLicense");
var textReview = temporarilyNotSupport("textReview");
var textToAudio = temporarilyNotSupport("textToAudio");
var imageAudit = temporarilyNotSupport("imageAudit");
var advancedGeneralIdentify = temporarilyNotSupport("advancedGeneralIdentify");
var objectDetectIdentify = temporarilyNotSupport("objectDetectIdentify");
var carClassify = temporarilyNotSupport("carClassify");
var dishClassify = temporarilyNotSupport("dishClassify");
var logoClassify = temporarilyNotSupport("logoClassify");
var animalClassify = temporarilyNotSupport("animalClassify");
var plantClassify = temporarilyNotSupport("plantClassify");
var getSwanId = temporarilyNotSupport("getSwanId");
var requestPolymerPayment = temporarilyNotSupport("requestPolymerPayment");
var navigateToSmartGameProgram = temporarilyNotSupport("navigateToSmartGameProgram");
var navigateToSmartProgram = temporarilyNotSupport("navigateToSmartProgram");
var navigateBackSmartProgram = temporarilyNotSupport("navigateBackSmartProgram");
var preloadSubPackage = temporarilyNotSupport("preloadSubPackage");
// node_modules/@tarojs/taro-h5/dist/api/ui/animation/index.js
var StyleSheet = class {
    constructor(){
        this.$style = null;
        this.sheet = null;
        this.appendStyleSheet = ()=>{
            if (this.$style) {
                const head2 = document.getElementsByTagName("head")[0];
                this.$style.setAttribute("type", "text/css");
                this.$style.setAttribute("data-type", "Taro");
                head2.appendChild(this.$style);
                this.sheet = this.$style.sheet;
            }
            if (this.sheet && !("insertRule" in this.sheet)) {
                console.warn("\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 stylesheet.insertRule \u63A5\u53E3");
            }
        };
        this.add = (cssText, index2 = 0)=>{
            var _a;
            if (this.sheet === null) {
                this.appendStyleSheet();
            }
            (_a = this.sheet) === null || _a === void 0 ? void 0 : _a.insertRule(cssText, index2);
        };
        this.$style = document.createElement("style");
    }
};
var styleSheet = new StyleSheet();
var TRANSITION_END = "transitionend";
var TRANSFORM = "transform";
var $detect = document.createElement("div");
$detect.style.cssText = "-webkit-animation-name:webkit;-moz-animation-name:moz;-ms-animation-name:ms;animation-name:standard;";
if ($detect.style["animation-name"] === "standard") {
    TRANSITION_END = "transitionend";
    TRANSFORM = "transform";
} else if ($detect.style["-webkit-animation-name"] === "webkit") {
    TRANSITION_END = "webkitTransitionEnd";
    TRANSFORM = "-webkit-transform";
} else if ($detect.style["-moz-animation-name"] === "moz") {
    TRANSITION_END = "mozTransitionEnd";
    TRANSFORM = "-moz-transform";
} else if ($detect.style["-ms-animation-name"] === "ms") {
    TRANSITION_END = "msTransitionEnd";
    TRANSFORM = "-ms-transform";
}
var animId = 0;
var Animation = class {
    transformUnit(...args) {
        const ret = [];
        args.forEach((each2)=>{
            ret.push(isNaN(each2) ? each2 : `${each2}${this.unit}`);
        });
        return ret;
    }
    setDefault(duration, delay, timingFunction, transformOrigin) {
        this.DEFAULT = {
            duration,
            delay,
            timingFunction,
            transformOrigin
        };
    }
    matrix(a, b, c, d, tx, ty) {
        this.transform.push(`matrix(${a}, ${b}, ${c}, ${d}, ${tx}, ${ty})`);
        return this;
    }
    matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) {
        this.transform.push(`matrix3d(${a1}, ${b1}, ${c1}, ${d1}, ${a2}, ${b2}, ${c2}, ${d2}, ${a3}, ${b3}, ${c3}, ${d3}, ${a4}, ${b4}, ${c4}, ${d4})`);
        return this;
    }
    rotate(angle) {
        this.transform.push(`rotate(${angle}deg)`);
        return this;
    }
    rotate3d(x, y, z, angle) {
        if (typeof y !== "number") {
            this.transform.push(`rotate3d(${x})`);
        } else {
            this.transform.push(`rotate3d(${x}, ${y || 0}, ${z || 0}, ${angle || 0}deg)`);
        }
        return this;
    }
    rotateX(angle) {
        this.transform.push(`rotateX(${angle}deg)`);
        return this;
    }
    rotateY(angle) {
        this.transform.push(`rotateY(${angle}deg)`);
        return this;
    }
    rotateZ(angle) {
        this.transform.push(`rotateZ(${angle}deg)`);
        return this;
    }
    scale(x, y) {
        this.transform.push(`scale(${x}, ${y})`);
        return this;
    }
    scale3d(x, y, z) {
        this.transform.push(`scale3d(${x}, ${y}, ${z})`);
        return this;
    }
    scaleX(scale) {
        this.transform.push(`scaleX(${scale})`);
        return this;
    }
    scaleY(scale) {
        this.transform.push(`scaleY(${scale})`);
        return this;
    }
    scaleZ(scale) {
        this.transform.push(`scaleZ(${scale})`);
        return this;
    }
    skew(x, y) {
        this.transform.push(`skew(${x}, ${y})`);
        return this;
    }
    skewX(angle) {
        this.transform.push(`skewX(${angle})`);
        return this;
    }
    skewY(angle) {
        this.transform.push(`skewY(${angle})`);
        return this;
    }
    translate(x, y) {
        [x, y] = this.transformUnit(x, y);
        this.transform.push(`translate(${x}, ${y})`);
        return this;
    }
    translate3d(x, y, z) {
        [x, y, z] = this.transformUnit(x, y, z);
        this.transform.push(`translate3d(${x}, ${y}, ${z})`);
        return this;
    }
    translateX(translate2) {
        [translate2] = this.transformUnit(translate2);
        this.transform.push(`translateX(${translate2})`);
        return this;
    }
    translateY(translate2) {
        [translate2] = this.transformUnit(translate2);
        this.transform.push(`translateY(${translate2})`);
        return this;
    }
    translateZ(translate2) {
        [translate2] = this.transformUnit(translate2);
        this.transform.push(`translateZ(${translate2})`);
        return this;
    }
    opacity(value) {
        this.rules.push(`opacity: ${value}`);
        return this;
    }
    backgroundColor(value) {
        this.rules.push(`background-color: ${value}`);
        return this;
    }
    width(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`width: ${value}`);
        return this;
    }
    height(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`height: ${value}`);
        return this;
    }
    top(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`top: ${value}`);
        return this;
    }
    right(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`right: ${value}`);
        return this;
    }
    bottom(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`bottom: ${value}`);
        return this;
    }
    left(value) {
        [value] = this.transformUnit(value);
        this.rules.push(`left: ${value}`);
        return this;
    }
    step(arg = {}) {
        const { DEFAULT  } = this;
        const { duration =DEFAULT.duration , delay =DEFAULT.delay , timingFunction =DEFAULT.timingFunction , transformOrigin =DEFAULT.transformOrigin  } = arg;
        this.steps.push([
            this.rules.map((rule)=>`${rule}!important`).join(";"),
            `${this.transform.join(" ")}!important`,
            `${TRANSFORM}-origin: ${transformOrigin}`,
            `transition: all ${duration}ms ${timingFunction} ${delay}ms`
        ].filter((item)=>item !== "" && item !== `${TRANSFORM}:`).join(";"));
        this.rules = [];
        this.transform = [
            `${TRANSFORM}:`
        ];
        return this;
    }
    createAnimationData() {
        const animIndex = `taro-h5-poly-fill/${this.id}/create-animation__${this.animationMapCount++}`;
        this.animationMap[animIndex] = this.steps.length;
        this.steps.forEach((step, index2)=>{
            const selector = index2 === 0 ? `[animation="${animIndex}"], [data-animation="${animIndex}"]` : `[animation="${animIndex}--${index2}"], [data-animation="${animIndex}--${index2}"]`;
            styleSheet.add(`${selector} { ${step} }`);
        });
        this.steps = [];
        return animIndex;
    }
    export() {
        return this.createAnimationData();
    }
    constructor({ duration =400 , delay =0 , timingFunction ="linear" , transformOrigin ="50% 50% 0" , unit ="px"  } = {}){
        this.rules = [];
        this.transform = [
            `${TRANSFORM}:`
        ];
        this.steps = [];
        this.animationMap = {};
        this.animationMapCount = 0;
        this.setDefault(duration, delay, timingFunction, transformOrigin);
        this.unit = unit;
        let animAttr = "animation";
        this.id = ++animId;
        document.body.addEventListener(TRANSITION_END, (e)=>{
            const target = e.target;
            if (target.getAttribute(animAttr) === null) {
                animAttr = "data-animation";
            }
            const animData = target.getAttribute(animAttr);
            if (animData === null) return;
            const [animName, animPath] = animData.split("__");
            if (animName === `taro-h5-poly-fill/${this.id}/create-animation`) {
                const [animIndex, __stepIndex = 0] = animPath.split("--");
                const stepIndex = Number(__stepIndex);
                const animStepsCount = this.animationMap[`${animName}__${animIndex}`];
                const animStepsMaxIndex = animStepsCount - 1;
                if (stepIndex < animStepsMaxIndex) {
                    target.setAttribute(animAttr, `${animName}__${animIndex}--${stepIndex + 1}`);
                    if (animAttr === "animation") {
                        target.setAttribute("data-animation", `${animName}__${animIndex}--${stepIndex + 1}`);
                    }
                }
            }
        });
    }
};
var createAnimation = (option)=>{
    return new Animation(option);
};
// node_modules/@tarojs/taro-h5/dist/api/ui/background.js
var setBackgroundTextStyle = temporarilyNotSupport("setBackgroundTextStyle");
var setBackgroundColor = temporarilyNotSupport("setBackgroundColor");
// node_modules/@tarojs/taro-h5/dist/api/ui/custom-component.js
var nextTick4 = Taro.nextTick;
// node_modules/@tarojs/taro-h5/dist/api/ui/fonts.js
var loadFontFace = (options3)=>__awaiter4(void 0, void 0, void 0, function*() {
        options3 = Object.assign({
            global: false
        }, options3);
        const { success , fail , complete , family , source , desc ={}  } = options3;
        const handle3 = new MethodHandler({
            name: "loadFontFace",
            success,
            fail,
            complete
        });
        const fonts = document.fonts;
        if (fonts) {
            const fontFace = new FontFace(family, source, desc);
            try {
                yield fontFace.load();
                fonts.add(fontFace);
                return handle3.success({});
            } catch (error) {
                return handle3.fail({
                    errMsg: error.message || error
                });
            }
        } else {
            const style = document.createElement("style");
            let innerText = `font-family:"${family}";src:${source};font-style:${desc.style || "normal"};font-weight:${desc.weight || "normal"};font-variant:${desc.variant || "normal"};`;
            if (desc.ascentOverride) {
                innerText += `ascent-override:${desc.ascentOverride};`;
            }
            if (desc.descentOverride) {
                innerText += `descent-override:${desc.descentOverride};`;
            }
            if (desc.featureSettings) {
                innerText += `font-feature-settings:${desc.featureSettings};`;
            }
            if (desc.lineGapOverride) {
                innerText += `line-gap-override:${desc.lineGapOverride};`;
            }
            if (desc.stretch) {
                innerText += `font-stretch:${desc.stretch};`;
            }
            if (desc.unicodeRange) {
                innerText += `unicode-range:${desc.unicodeRange};`;
            }
            if (desc.variationSettings) {
                innerText += `font-variation-settings:${desc.variationSettings};`;
            }
            style.innerText = `@font-face{${innerText}}`;
            document.head.appendChild(style);
            return handle3.success();
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/actionSheet.js
var noop3 = function() {};
var ActionSheet = class {
    create(options3 = {}) {
        return new Promise((resolve)=>{
            const { maskStyle , actionSheetStyle , menuStyle , cellStyle , cancelStyle  } = this.style;
            const config = Object.assign(Object.assign({}, this.options), options3);
            this.lastConfig = config;
            this.el = document.createElement("div");
            this.el.className = "taro__actionSheet";
            this.el.style.opacity = "0";
            this.el.style.transition = "opacity 0.2s linear";
            this.mask = document.createElement("div");
            this.mask.setAttribute("style", inlineStyle(maskStyle));
            this.actionSheet = document.createElement("div");
            this.actionSheet.setAttribute("style", inlineStyle(actionSheetStyle));
            this.menu = document.createElement("div");
            this.menu.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, menuStyle), {
                color: config.itemColor
            })));
            this.cells = config.itemList.map((item, index2)=>{
                const cell = document.createElement("div");
                cell.className = "taro-actionsheet__cell";
                cell.setAttribute("style", inlineStyle(cellStyle));
                cell.textContent = item;
                cell.dataset.tapIndex = `${index2}`;
                cell.onclick = (e)=>{
                    this.hide();
                    const target = e.currentTarget;
                    const index3 = Number(target === null || target === void 0 ? void 0 : target.dataset.tapIndex) || 0;
                    resolve(index3);
                };
                return cell;
            });
            this.cancel = document.createElement("div");
            this.cancel.setAttribute("style", inlineStyle(cancelStyle));
            this.cancel.textContent = "\u53D6\u6D88";
            this.cells.forEach((item)=>this.menu.appendChild(item));
            this.actionSheet.appendChild(this.menu);
            this.actionSheet.appendChild(this.cancel);
            this.el.appendChild(this.mask);
            this.el.appendChild(this.actionSheet);
            const cb = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.mask.onclick = cb;
            this.cancel.onclick = cb;
            document.body.appendChild(this.el);
            setTimeout(()=>{
                this.el.style.opacity = "1";
                setTransform(this.actionSheet, "translate(0, 0)");
            }, 0);
        });
    }
    show(options3 = {}) {
        return new Promise((resolve)=>{
            const config = Object.assign(Object.assign({}, this.options), options3);
            this.lastConfig = config;
            if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
            if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
            if (config.itemColor) this.menu.style.color = config.itemColor;
            const { cellStyle  } = this.style;
            config.itemList.forEach((item, index2)=>{
                let cell;
                if (this.cells[index2]) {
                    cell = this.cells[index2];
                } else {
                    cell = document.createElement("div");
                    cell.className = "taro-actionsheet__cell";
                    cell.setAttribute("style", inlineStyle(cellStyle));
                    cell.dataset.tapIndex = `${index2}`;
                    this.cells.push(cell);
                    this.menu.appendChild(cell);
                }
                cell.textContent = item;
                cell.onclick = (e)=>{
                    this.hide();
                    const target = e.currentTarget;
                    const index3 = Number(target === null || target === void 0 ? void 0 : target.dataset.tapIndex) || 0;
                    resolve(index3);
                };
            });
            const cellsLen = this.cells.length;
            const itemListLen = config.itemList.length;
            if (cellsLen > itemListLen) {
                for(let i2 = itemListLen; i2 < cellsLen; i2++){
                    this.menu.removeChild(this.cells[i2]);
                }
                this.cells.splice(itemListLen);
            }
            const cb = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.mask.onclick = cb;
            this.cancel.onclick = cb;
            this.el.style.display = "block";
            setTimeout(()=>{
                this.el.style.opacity = "1";
                setTransform(this.actionSheet, "translate(0, 0)");
            }, 0);
        });
    }
    hide() {
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.hideOpacityTimer = setTimeout(()=>{
            this.el.style.opacity = "0";
            setTransform(this.actionSheet, "translate(0, 100%)");
            this.hideDisplayTimer = setTimeout(()=>{
                this.el.style.display = "none";
            }, 200);
        }, 0);
    }
    constructor(){
        this.options = {
            itemList: [],
            itemColor: "#000000",
            success: noop3,
            fail: noop3,
            complete: noop3
        };
        this.style = {
            maskStyle: {
                position: "fixed",
                "z-index": "1000",
                top: "0",
                right: "0",
                left: "0",
                bottom: "0",
                background: "rgba(0,0,0,0.6)"
            },
            actionSheetStyle: {
                "z-index": "4999",
                position: "fixed",
                left: "0",
                bottom: "0",
                "-webkit-transform": "translate(0, 100%)",
                transform: "translate(0, 100%)",
                width: "100%",
                "line-height": "1.6",
                background: "#EFEFF4",
                "-webkit-transition": "-webkit-transform .3s",
                transition: "transform .3s"
            },
            menuStyle: {
                "background-color": "#FCFCFD"
            },
            cellStyle: {
                position: "relative",
                padding: "10px 0",
                "text-align": "center",
                "font-size": "18px"
            },
            cancelStyle: {
                "margin-top": "6px",
                padding: "10px 0",
                "text-align": "center",
                "font-size": "18px",
                color: "#000000",
                "background-color": "#FCFCFD"
            }
        };
        this.lastConfig = {};
    }
};
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/modal.js
var Modal = class {
    create(options3 = {}) {
        return new Promise((resolve)=>{
            var _a, _b;
            const { maskStyle , modalStyle , titleStyle , textStyle , footStyle , btnStyle  } = this.style;
            const config = Object.assign(Object.assign({}, this.options), options3);
            this.el = document.createElement("div");
            this.el.className = "taro__modal";
            this.el.style.opacity = "0";
            this.el.style.transition = "opacity 0.2s linear";
            const mask = document.createElement("div");
            mask.className = "taro-modal__mask";
            mask.setAttribute("style", inlineStyle(maskStyle));
            const modal2 = document.createElement("div");
            modal2.className = "taro-modal__content";
            modal2.setAttribute("style", inlineStyle(modalStyle));
            const titleCSS = config.title ? titleStyle : Object.assign(Object.assign({}, titleStyle), {
                display: "none"
            });
            this.title = document.createElement("div");
            this.title.className = "taro-modal__title";
            this.title.setAttribute("style", inlineStyle(titleCSS));
            this.title.textContent = config.title;
            const textCSS = config.title ? textStyle : Object.assign(Object.assign({}, textStyle), {
                padding: "40px 20px 26px",
                color: "#353535"
            });
            this.text = document.createElement("div");
            this.text.className = "taro-modal__text";
            this.text.setAttribute("style", inlineStyle(textCSS));
            this.text.textContent = config.content;
            const foot = document.createElement("div");
            foot.className = "taro-modal__foot";
            foot.setAttribute("style", inlineStyle(footStyle));
            const cancelCSS = Object.assign(Object.assign({}, btnStyle), {
                color: config.cancelColor,
                display: config.showCancel ? "block" : "none"
            });
            this.cancel = document.createElement("div");
            this.cancel.className = "taro-model__btn taro-model__cancel";
            this.cancel.setAttribute("style", inlineStyle(cancelCSS));
            this.cancel.textContent = config.cancelText;
            this.cancel.onclick = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.confirm = document.createElement("div");
            this.confirm.className = "taro-model__btn taro-model__confirm";
            this.confirm.setAttribute("style", inlineStyle(btnStyle));
            this.confirm.style.color = config.confirmColor;
            this.confirm.textContent = config.confirmText;
            this.confirm.onclick = ()=>{
                this.hide();
                resolve("confirm");
            };
            foot.appendChild(this.cancel);
            foot.appendChild(this.confirm);
            modal2.appendChild(this.title);
            modal2.appendChild(this.text);
            modal2.appendChild(foot);
            this.el.appendChild(mask);
            this.el.appendChild(modal2);
            document.body.appendChild(this.el);
            setTimeout(()=>{
                this.el.style.opacity = "1";
            }, 0);
            this.currentPath = (_b = (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        });
    }
    show(options3 = {}) {
        return new Promise((resolve)=>{
            var _a, _b;
            const config = Object.assign(Object.assign({}, this.options), options3);
            if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
            if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
            const { textStyle  } = this.style;
            if (config.title) {
                this.title.textContent = config.title;
                this.title.style.display = "block";
                this.text.setAttribute("style", inlineStyle(textStyle));
            } else {
                this.title.textContent = "";
                this.title.style.display = "none";
                const textCSS = Object.assign(Object.assign({}, textStyle), {
                    padding: "40px 20px 26px",
                    color: "#353535"
                });
                this.text.setAttribute("style", inlineStyle(textCSS));
            }
            this.text.textContent = config.content || "";
            this.cancel.style.display = config.showCancel ? "block" : "none";
            this.cancel.textContent = config.cancelText || "";
            this.cancel.style.color = config.cancelColor || "";
            this.confirm.textContent = config.confirmText || "";
            this.confirm.style.color = config.confirmColor || "";
            this.cancel.onclick = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.confirm.onclick = ()=>{
                this.hide();
                resolve("confirm");
            };
            this.el.style.display = "block";
            setTimeout(()=>{
                this.el.style.opacity = "1";
            }, 0);
            this.currentPath = (_b = (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        });
    }
    hide() {
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.currentPath = null;
        this.hideOpacityTimer = setTimeout(()=>{
            this.el.style.opacity = "0";
            this.hideDisplayTimer = setTimeout(()=>{
                this.el.style.display = "none";
            }, 200);
        }, 0);
    }
    constructor(){
        this.options = {
            title: "",
            content: "",
            showCancel: true,
            cancelText: "\u53D6\u6D88",
            cancelColor: "#000000",
            confirmText: "\u786E\u5B9A",
            confirmColor: "#3CC51F"
        };
        this.style = {
            maskStyle: {
                position: "fixed",
                "z-index": "1000",
                top: "0",
                right: "0",
                left: "0",
                bottom: "0",
                background: "rgba(0,0,0,0.6)"
            },
            modalStyle: {
                "z-index": "4999",
                position: "fixed",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                width: "80%",
                "max-width": "300px",
                "border-radius": "3px",
                "text-align": "center",
                "line-height": "1.6",
                overflow: "hidden",
                background: "#FFFFFF"
            },
            titleStyle: {
                padding: "20px 24px 9px",
                "font-size": "18px"
            },
            textStyle: {
                padding: "0 24px 12px",
                "min-height": "40px",
                "font-size": "15px",
                "line-height": "1.3",
                color: "#808080"
            },
            footStyle: {
                position: "relative",
                "line-height": "48px",
                "font-size": "18px",
                display: "flex"
            },
            btnStyle: {
                position: "relative",
                "-webkit-box-flex": "1",
                "-webkit-flex": "1",
                flex: "1"
            }
        };
    }
};
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/toast.js
var Toast = class {
    create(options3 = {}, _type = "toast") {
        var _a, _b;
        const { maskStyle , toastStyle , successStyle , errrorStyle , loadingStyle , imageStyle , textStyle  } = this.style;
        const config = Object.assign(Object.assign(Object.assign({}, this.options), options3), {
            _type
        });
        this.el = document.createElement("div");
        this.el.className = "taro__toast";
        this.el.style.opacity = "0";
        this.el.style.transition = "opacity 0.1s linear";
        this.mask = document.createElement("div");
        this.mask.setAttribute("style", inlineStyle(maskStyle));
        this.mask.style.display = config.mask ? "block" : "none";
        this.icon = document.createElement("p");
        if (config.image) {
            this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, imageStyle), {
                "background-image": `url(${config.image})`
            })));
        } else {
            const iconStyle = config.icon === "loading" ? loadingStyle : config.icon === "error" ? errrorStyle : successStyle;
            this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, iconStyle), config.icon === "none" ? {
                display: "none"
            } : {})));
        }
        this.toast = document.createElement("div");
        this.toast.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, toastStyle), config.icon === "none" ? {
            "min-height": "0",
            padding: "10px 15px"
        } : {})));
        this.title = document.createElement("p");
        this.title.setAttribute("style", inlineStyle(textStyle));
        this.title.textContent = config.title;
        this.toast.appendChild(this.icon);
        this.toast.appendChild(this.title);
        this.el.appendChild(this.mask);
        this.el.appendChild(this.toast);
        document.body.appendChild(this.el);
        setTimeout(()=>{
            this.el.style.opacity = "1";
        }, 0);
        this.type = config._type;
        config.duration >= 0 && this.hide(config.duration, this.type);
        this.currentPath = (_b = (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        return "";
    }
    show(options3 = {}, _type = "toast") {
        var _a, _b;
        const config = Object.assign(Object.assign(Object.assign({}, this.options), options3), {
            _type
        });
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.title.textContent = config.title || "";
        this.mask.style.display = config.mask ? "block" : "none";
        const { toastStyle , successStyle , errrorStyle , loadingStyle , imageStyle  } = this.style;
        if (config.image) {
            this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, imageStyle), {
                "background-image": `url(${config.image})`
            })));
        } else {
            if (!config.image && config.icon) {
                const iconStyle = config.icon === "loading" ? loadingStyle : config.icon === "error" ? errrorStyle : successStyle;
                this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, iconStyle), config.icon === "none" ? {
                    display: "none"
                } : {})));
            }
        }
        this.toast.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, toastStyle), config.icon === "none" ? {
            "min-height": "0",
            padding: "10px 15px"
        } : {})));
        this.el.style.display = "block";
        setTimeout(()=>{
            this.el.style.opacity = "1";
        }, 0);
        this.type = config._type;
        config.duration >= 0 && this.hide(config.duration, this.type);
        this.currentPath = (_b = (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        return "";
    }
    hide(duration = 0, type = "") {
        if (type && type !== this.type) return;
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.currentPath = null;
        this.hideOpacityTimer = setTimeout(()=>{
            this.el.style.opacity = "0";
            this.hideDisplayTimer = setTimeout(()=>{
                this.el.style.display = "none";
            }, 100);
        }, duration);
    }
    constructor(){
        this.options = {
            title: "",
            icon: "none",
            image: "",
            duration: 1500,
            mask: false
        };
        this.style = {
            maskStyle: {
                position: "fixed",
                "z-index": "1000",
                top: "0",
                right: "0",
                left: "0",
                bottom: "0"
            },
            toastStyle: {
                "z-index": "5000",
                "box-sizing": "border-box",
                display: "flex",
                "flex-direction": "column",
                "justify-content": "center",
                "-webkit-justify-content": "center",
                position: "fixed",
                top: "50%",
                left: "50%",
                "min-width": "120px",
                "max-width": "200px",
                "min-height": "120px",
                padding: "15px",
                transform: "translate(-50%, -50%)",
                "border-radius": "5px",
                "text-align": "center",
                "line-height": "1.6",
                color: "#FFFFFF",
                background: "rgba(17, 17, 17, 0.7)"
            },
            successStyle: {
                margin: "6px auto",
                width: "38px",
                height: "38px",
                background: "transparent url(data:image/svg+xml;base64,PHN2ZyB0PSIxNjM5NTQ4OTYzMjA0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjQzNDgiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNMjE5Ljk1MiA1MTIuNTc2bDIxMC40MzIgMjEwLjQzMi00NS4yNDggNDUuMjU2LTIxMC40MzItMjEwLjQzMnoiIHAtaWQ9IjQzNDkiIGZpbGw9IiNmZmZmZmYiPjwvcGF0aD48cGF0aCBkPSJNNzk5LjY3MiAyNjIuMjY0bDQ1LjI1NiA0NS4yNTYtNDYwLjQ2NCA0NjAuNDY0LTQ1LjI1Ni00NS4yNTZ6IiBwLWlkPSI0MzUwIiBmaWxsPSIjZmZmZmZmIj48L3BhdGg+PC9zdmc+) no-repeat",
                "background-size": "100%"
            },
            errrorStyle: {
                margin: "6px auto",
                width: "38px",
                height: "38px",
                background: "transparent url(data:image/svg+xml;base64,PHN2ZyB0PSIxNjM5NTUxMDU1MTgzIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjE0MDc2IiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNTggNjQgNjQgMjY0LjU4IDY0IDUxMnMyMDAuNTggNDQ4IDQ0OCA0NDggNDQ4LTIwMC41OCA0NDgtNDQ4Uzc1OS40MiA2NCA1MTIgNjR6IG0wIDc1MmEzNiAzNiAwIDEgMSAzNi0zNiAzNiAzNiAwIDAgMS0zNiAzNnogbTUxLjgzLTU1MS45NUw1NDggNjM2YTM2IDM2IDAgMCAxLTcyIDBsLTE1LjgzLTM3MS45NWMtMC4xLTEuMzMtMC4xNy0yLjY4LTAuMTctNC4wNWE1MiA1MiAwIDAgMSAxMDQgMGMwIDEuMzctMC4wNyAyLjcyLTAuMTcgNC4wNXoiIHAtaWQ9IjE0MDc3IiBmaWxsPSIjZmZmZmZmIj48L3BhdGg+PC9zdmc+) no-repeat",
                "background-size": "100%"
            },
            loadingStyle: {
                margin: "6px auto",
                width: "38px",
                height: "38px",
                "-webkit-animation": "taroLoading 1s steps(12, end) infinite",
                animation: "taroLoading 1s steps(12, end) infinite",
                background: "transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTlFOUU5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgLTMwKSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iIzk4OTY5NyIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzMCAxMDUuOTggNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjOUI5OTlBIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDYwIDc1Ljk4IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0EzQTFBMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSg5MCA2NSA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNBQkE5QUEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDU4LjY2IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0IyQjJCMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgxNTAgNTQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjQkFCOEI5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDE4MCA1MCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDMkMwQzEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTE1MCA0NS45OCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDQkNCQ0IiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTEyMCA0MS4zNCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNEMkQyRDIiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDM1IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0RBREFEQSIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgtNjAgMjQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTJFMkUyIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKC0zMCAtNS45OCA2NSkiLz48L3N2Zz4=) no-repeat",
                "background-size": "100%"
            },
            imageStyle: {
                margin: "6px auto",
                width: "40px",
                height: "40px",
                background: "transparent no-repeat",
                "background-size": "100%"
            },
            textStyle: {
                margin: "0",
                "font-size": "16px"
            }
        };
    }
};
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/index.js
var status = "default";
function init22(doc3) {
    if (status === "ready") return;
    const taroStyle = doc3.createElement("style");
    taroStyle.textContent = '@font-face{font-weight:normal;font-style:normal;font-family:"taro";src:url("data:application/x-font-ttf;charset=utf-8;base64, AAEAAAALAIAAAwAwR1NVQrD+s+0AAAE4AAAAQk9TLzJWs0t/AAABfAAAAFZjbWFwqVgGvgAAAeAAAAGGZ2x5Zph7qG0AAANwAAAAdGhlYWQRFoGhAAAA4AAAADZoaGVhCCsD7AAAALwAAAAkaG10eAg0AAAAAAHUAAAADGxvY2EADAA6AAADaAAAAAhtYXhwAQ4AJAAAARgAAAAgbmFtZYrphEEAAAPkAAACVXBvc3S3shtSAAAGPAAAADUAAQAAA+gAAABaA+gAAAAAA+gAAQAAAAAAAAAAAAAAAAAAAAMAAQAAAAEAAADih+FfDzz1AAsD6AAAAADXB57LAAAAANcHnssAAP/sA+gDOgAAAAgAAgAAAAAAAAABAAAAAwAYAAEAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKAB4ALAABREZMVAAIAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAAAAQK8AZAABQAIAnoCvAAAAIwCegK8AAAB4AAxAQIAAAIABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUGZFZABAAHjqCAPoAAAAWgPoABQAAAABAAAAAAAAA+gAAABkAAAD6AAAAAAABQAAAAMAAAAsAAAABAAAAV4AAQAAAAAAWAADAAEAAAAsAAMACgAAAV4ABAAsAAAABgAEAAEAAgB46gj//wAAAHjqCP//AAAAAAABAAYABgAAAAEAAgAAAQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAKAAAAAAAAAACAAAAeAAAAHgAAAABAADqCAAA6ggAAAACAAAAAAAAAAwAOgABAAD/7AAyABQAAgAANzMVFB4UKAAAAAABAAAAAAO7AzoAFwAAEy4BPwE+AR8BFjY3ATYWFycWFAcBBiInPQoGBwUHGgzLDCELAh0LHwsNCgr9uQoeCgGzCyEOCw0HCZMJAQoBvgkCCg0LHQv9sQsKAAAAAAAAEgDeAAEAAAAAAAAAHQAAAAEAAAAAAAEABAAdAAEAAAAAAAIABwAhAAEAAAAAAAMABAAoAAEAAAAAAAQABAAsAAEAAAAAAAUACwAwAAEAAAAAAAYABAA7AAEAAAAAAAoAKwA/AAEAAAAAAAsAEwBqAAMAAQQJAAAAOgB9AAMAAQQJAAEACAC3AAMAAQQJAAIADgC/AAMAAQQJAAMACADNAAMAAQQJAAQACADVAAMAAQQJAAUAFgDdAAMAAQQJAAYACADzAAMAAQQJAAoAVgD7AAMAAQQJAAsAJgFRCiAgQ3JlYXRlZCBieSBmb250LWNhcnJpZXIKICB3ZXVpUmVndWxhcndldWl3ZXVpVmVyc2lvbiAxLjB3ZXVpR2VuZXJhdGVkIGJ5IHN2ZzJ0dGYgZnJvbSBGb250ZWxsbyBwcm9qZWN0Lmh0dHA6Ly9mb250ZWxsby5jb20ACgAgACAAQwByAGUAYQB0AGUAZAAgAGIAeQAgAGYAbwBuAHQALQBjAGEAcgByAGkAZQByAAoAIAAgAHcAZQB1AGkAUgBlAGcAdQBsAGEAcgB3AGUAdQBpAHcAZQB1AGkAVgBlAHIAcwBpAG8AbgAgADEALgAwAHcAZQB1AGkARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAAIAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwECAQMBBAABeAd1bmlFQTA4AAAAAAA=") format("truetype");}@-webkit-keyframes taroLoading{0%{-webkit-transform:rotate3d(0, 0, 1, 0deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 360deg);transform:rotate3d(0, 0, 1, 360deg);}}@keyframes taroLoading{0%{-webkit-transform:rotate3d(0, 0, 1, 0deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 360deg);transform:rotate3d(0, 0, 1, 360deg);}}.taro-modal__foot:after {content: "";position: absolute;left: 0;top: 0;right: 0;height: 1px;border-top: 1px solid #D5D5D6;color: #D5D5D6;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleY(0.5);transform: scaleY(0.5);} .taro-model__btn:active {background-color: #EEEEEE}.taro-model__btn:not(:first-child):after {content: "";position: absolute;left: 0;top: 0;width: 1px;bottom: 0;border-left: 1px solid #D5D5D6;color: #D5D5D6;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleX(0.5);transform: scaleX(0.5);}.taro-actionsheet__cell:not(:first-child):after {content: "";position: absolute;left: 0;top: 0;right: 0;height: 1px;border-top: 1px solid #e5e5e5;color: #e5e5e5;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleY(0.5);transform: scaleY(0.5);}';
    doc3.querySelector("head").appendChild(taroStyle);
    status = "ready";
}
var toast = new Toast();
var modal = new Modal();
var actionSheet = new ActionSheet();
var showToast = (options3 = {
    title: ""
})=>{
    init22(document);
    options3 = Object.assign({
        title: "",
        icon: "success",
        image: "",
        duration: 1500,
        mask: false
    }, options3);
    const { success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "showToast",
        success,
        fail,
        complete
    });
    if (typeof options3.title !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: options3.title
            })
        });
    }
    if (typeof options3.duration !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "duration",
                correct: "Number",
                wrong: options3.duration
            })
        });
    }
    if (options3.image && typeof options3.image !== "string") options3.image = "";
    options3.mask = !!options3.mask;
    let errMsg = "";
    if (!toast.el) {
        errMsg = toast.create(options3, "toast");
    } else {
        errMsg = toast.show(options3, "toast");
    }
    return handle3.success({
        errMsg
    });
};
var hideToast = ({ noConflict =false , success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "hideToast",
        success,
        fail,
        complete
    });
    if (!toast.el) return handle3.success();
    toast.hide(0, noConflict ? "toast" : "");
    return handle3.success();
};
var showLoading = (options3 = {
    title: ""
})=>{
    init22(document);
    options3 = Object.assign({
        title: "",
        mask: false
    }, options3);
    const { success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "showLoading",
        success,
        fail,
        complete
    });
    const config = {
        icon: "loading",
        image: "",
        duration: -1
    };
    options3 = Object.assign({}, options3, config);
    if (typeof options3.title !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: options3.title
            })
        });
    }
    options3.mask = !!options3.mask;
    let errMsg = "";
    if (!toast.el) {
        errMsg = toast.create(options3, "loading");
    } else {
        errMsg = toast.show(options3, "loading");
    }
    return handle3.success({
        errMsg
    });
};
var hideLoading = ({ noConflict =false , success , fail , complete  } = {})=>{
    const handle3 = new MethodHandler({
        name: "hideLoading",
        success,
        fail,
        complete
    });
    if (!toast.el) return handle3.success();
    toast.hide(0, noConflict ? "loading" : "");
    return handle3.success();
};
var showModal = (options3 = {})=>__awaiter4(void 0, void 0, void 0, function*() {
        init22(document);
        options3 = Object.assign({
            title: "",
            content: "",
            showCancel: true,
            cancelText: "\u53D6\u6D88",
            cancelColor: "#000000",
            confirmText: "\u786E\u5B9A",
            confirmColor: "#3CC51F"
        }, options3);
        const { success , fail , complete  } = options3;
        const handle3 = new MethodHandler({
            name: "showModal",
            success,
            fail,
            complete
        });
        if (typeof options3.title !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "title",
                    correct: "String",
                    wrong: options3.title
                })
            });
        }
        if (typeof options3.content !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "content",
                    correct: "String",
                    wrong: options3.content
                })
            });
        }
        if (typeof options3.cancelText !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "cancelText",
                    correct: "String",
                    wrong: options3.cancelText
                })
            });
        }
        if (options3.cancelText.replace(/[\u0391-\uFFE5]/g, "aa").length > 8) {
            return handle3.fail({
                errMsg: "cancelText length should not larger then 4 Chinese characters"
            });
        }
        if (typeof options3.confirmText !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "confirmText",
                    correct: "String",
                    wrong: options3.confirmText
                })
            });
        }
        if (options3.confirmText.replace(/[\u0391-\uFFE5]/g, "aa").length > 8) {
            return handle3.fail({
                errMsg: "confirmText length should not larger then 4 Chinese characters"
            });
        }
        if (typeof options3.cancelColor !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "cancelColor",
                    correct: "String",
                    wrong: options3.cancelColor
                })
            });
        }
        if (typeof options3.confirmColor !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "confirmColor",
                    correct: "String",
                    wrong: options3.confirmColor
                })
            });
        }
        options3.showCancel = !!options3.showCancel;
        let result = "";
        if (!modal.el) {
            result = yield modal.create(options3);
        } else {
            result = yield modal.show(options3);
        }
        const res = {
            cancel: false,
            confirm: false
        };
        res[result] = true;
        return handle3.success(res);
    });
function hideModal() {
    if (!modal.el) return;
    modal.hide();
}
var showActionSheet = (options3 = {
    itemList: []
})=>__awaiter4(void 0, void 0, void 0, function*() {
        init22(document);
        options3 = Object.assign({
            itemColor: "#000000",
            itemList: []
        }, options3);
        const { success , fail , complete  } = options3;
        const handle3 = new MethodHandler({
            name: "showActionSheet",
            success,
            fail,
            complete
        });
        if (!Array.isArray(options3.itemList)) {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "itemList",
                    correct: "Array",
                    wrong: options3.itemList
                })
            });
        }
        if (options3.itemList.length < 1) {
            return handle3.fail({
                errMsg: "parameter error: parameter.itemList should have at least 1 item"
            });
        }
        if (options3.itemList.length > 6) {
            return handle3.fail({
                errMsg: "parameter error: parameter.itemList should not be large than 6"
            });
        }
        for(let i2 = 0; i2 < options3.itemList.length; i2++){
            if (typeof options3.itemList[i2] !== "string") {
                return handle3.fail({
                    errMsg: getParameterError({
                        para: `itemList[${i2}]`,
                        correct: "String",
                        wrong: options3.itemList[i2]
                    })
                });
            }
        }
        if (typeof options3.itemColor !== "string") {
            return handle3.fail({
                errMsg: getParameterError({
                    para: "itemColor",
                    correct: "String",
                    wrong: options3.itemColor
                })
            });
        }
        let result = "";
        if (!actionSheet.el) {
            result = yield actionSheet.create(options3);
        } else {
            result = yield actionSheet.show(options3);
        }
        if (typeof result === "string") {
            return handle3.fail({
                errMsg: result
            });
        } else {
            return handle3.success({
                tapIndex: result
            });
        }
    });
Taro.eventCenter.on("__afterTaroRouterChange", ()=>{
    var _a, _b;
    if (toast.currentPath && toast.currentPath !== ((_a = Current.page) === null || _a === void 0 ? void 0 : _a.path)) {
        hideToast();
        hideLoading();
    }
    if (modal.currentPath && modal.currentPath !== ((_b = Current.page) === null || _b === void 0 ? void 0 : _b.path)) {
        hideModal();
    }
});
var enableAlertBeforeUnload = temporarilyNotSupport("enableAlertBeforeUnload");
var disableAlertBeforeUnload = temporarilyNotSupport("disableAlertBeforeUnload");
// node_modules/@tarojs/taro-h5/dist/api/ui/menu.js
var getMenuButtonBoundingClientRect = temporarilyNotSupport("getMenuButtonBoundingClientRect");
// node_modules/@tarojs/taro-h5/dist/api/ui/navigation-bar/index.js
var showNavigationBarLoading = temporarilyNotSupport("showNavigationBarLoading");
function setNavigationBarTitle(options3) {
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `setNavigationBarTitle:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { title , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "setNavigationBarTitle",
        success,
        fail,
        complete
    });
    if (!title || typeof title !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: title
            })
        });
    }
    setTitle(title);
    return handle3.success();
}
var setNavigationBarColor = (options3)=>{
    const { backgroundColor , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "setNavigationBarColor",
        success,
        fail,
        complete
    });
    const meta = document.createElement("meta");
    meta.setAttribute("name", "theme-color");
    meta.setAttribute("content", backgroundColor);
    document.head.appendChild(meta);
    return handle3.success();
};
var hideNavigationBarLoading = temporarilyNotSupport("hideNavigationBarLoading");
var hideHomeButton = temporarilyNotSupport("hideHomeButton");
// node_modules/@tarojs/taro-h5/dist/api/ui/pull-down-refresh.js
var startPullDownRefresh = function({ success , fail , complete  } = {}) {
    const handle3 = new MethodHandler({
        name: "startPullDownRefresh",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroStartPullDownRefresh", {
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var stopPullDownRefresh = function({ success , fail , complete  } = {}) {
    const handle3 = new MethodHandler({
        name: "stopPullDownRefresh",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroStopPullDownRefresh", {
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
// node_modules/@tarojs/taro-h5/dist/api/ui/scroll/index.js
var timer;
var FRAME_DURATION = 17;
var pageScrollTo = ({ scrollTop , selector ="" , offsetTop =0 , duration =300 , success , fail , complete  })=>{
    let scrollFunc;
    const handle3 = new MethodHandler({
        name: "pageScrollTo",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        var _a, _b;
        try {
            if (scrollTop === void 0 && !selector) {
                return handle3.fail({
                    errMsg: 'scrollTop" \u6216 "selector" \u9700\u8981\u5176\u4E4B\u4E00'
                }, {
                    resolve,
                    reject
                });
            }
            const id = (_b = (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path) === null || _b === void 0 ? void 0 : _b.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, "\\$1");
            const el = id ? document.querySelector(`.taro_page#${id}`) : document.querySelector(".taro_page") || document.querySelector(".taro_router");
            if (!scrollFunc) {
                if (!el) {
                    scrollFunc = (pos)=>{
                        if (pos === void 0) {
                            return window.pageYOffset;
                        } else {
                            window.scrollTo(0, pos);
                        }
                    };
                } else {
                    scrollFunc = (pos)=>{
                        if (pos === void 0) {
                            return el.scrollTop;
                        } else {
                            el.scrollTop = pos;
                        }
                    };
                }
            }
            if (scrollTop && selector) {
                console.warn('"scrollTop" \u6216 "selector" \u5EFA\u8BAE\u53EA\u8BBE\u4E00\u4E2A\u503C\uFF0C\u5168\u90E8\u8BBE\u7F6E\u4F1A\u5FFD\u7565selector');
            }
            const from = scrollFunc();
            let to;
            if (selector) {
                const el2 = document.querySelector(selector);
                to = ((el2 === null || el2 === void 0 ? void 0 : el2.offsetTop) || 0) + offsetTop;
            } else {
                to = typeof scrollTop === "number" ? scrollTop : 0;
            }
            const delta = to - from;
            const frameCnt = duration / FRAME_DURATION;
            const easeFunc = getTimingFunc(easeInOut, frameCnt);
            const scroll2 = (frame = 0)=>{
                const dest = from + delta * easeFunc(frame);
                scrollFunc(dest);
                if (frame < frameCnt) {
                    timer && clearTimeout(timer);
                    timer = setTimeout(()=>{
                        scroll2(frame + 1);
                    }, FRAME_DURATION);
                } else {
                    return handle3.success({}, {
                        resolve,
                        reject
                    });
                }
            };
            scroll2();
        } catch (e) {
            return handle3.fail({
                errMsg: e.message
            }, {
                resolve,
                reject
            });
        }
    });
};
// node_modules/@tarojs/taro-h5/dist/api/ui/sticky.js
var setTopBarText = temporarilyNotSupport("setTopBarText");
// node_modules/@tarojs/taro-h5/dist/api/ui/tab-bar.js
var tabConf;
function initTabBarApis(config = {}) {
    tabConf = config.tabBar;
}
var showTabBarRedDot = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `showTabBarRedDot:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2 , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "showTabBarRedDot",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroShowTabBarRedDotHandler", {
            index: index2,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var showTabBar = (options3 = {})=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `showTabBar:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { animation , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "showTabBar",
        success,
        fail,
        complete
    });
    if (options3.hasOwnProperty("animation") && typeof animation !== "boolean") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "animation",
                correct: "Boolean",
                wrong: animation
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroShowTabBar", {
            animation,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var setTabBarStyle = (options3 = {})=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `setTabBarStyle:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { color , selectedColor , backgroundColor , borderStyle , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "setTabBarStyle",
        success,
        fail,
        complete
    });
    let errMsg;
    if (color && !isValidColor(color)) {
        errMsg = "color";
    } else if (selectedColor && !isValidColor(selectedColor)) {
        errMsg = "selectedColor";
    } else if (backgroundColor && !isValidColor(backgroundColor)) {
        errMsg = "backgroundColor";
    } else if (borderStyle && !/^(black|white)$/.test(borderStyle)) {
        errMsg = "borderStyle";
    }
    if (errMsg) {
        return handle3.fail({
            errMsg: `invalid ${errMsg}`
        });
    }
    if (!tabConf) {
        return handle3.fail();
    }
    const obj = {};
    if (color) obj.color = color;
    if (selectedColor) obj.selectedColor = selectedColor;
    if (backgroundColor) obj.backgroundColor = backgroundColor;
    if (borderStyle) obj.borderStyle = borderStyle;
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroSetTabBarStyle", {
            color,
            selectedColor,
            backgroundColor,
            borderStyle,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var setTabBarItem = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `setTabBarItem:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2 , text: text2 , iconPath , selectedIconPath , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "setTabBarItem",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroSetTabBarItem", {
            index: index2,
            text: text2,
            iconPath,
            selectedIconPath,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var setTabBarBadge = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `setTabBarBadge:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2 , text: text2 , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "setTabBarBadge",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    if (typeof text2 !== "string") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "text",
                correct: "String",
                wrong: text2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroSetTabBarBadge", {
            index: index2,
            text: text2,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var removeTabBarBadge = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `removeTabBarBadge:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2 , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "removeTabBarBadge",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroRemoveTabBarBadge", {
            index: index2,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var hideTabBarRedDot = (options3)=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `hideTabBarRedDot:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index: index2 , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "hideTabBarRedDot",
        success,
        fail,
        complete
    });
    if (typeof index2 !== "number") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index2
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroHideTabBarRedDotHandler", {
            index: index2,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var hideTabBar = (options3 = {})=>{
    const isObject3 = shouldBeObject(options3);
    if (!isObject3.flag) {
        const res = {
            errMsg: `hideTabBar:fail ${isObject3.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { animation , success , fail , complete  } = options3;
    const handle3 = new MethodHandler({
        name: "hideTabBar",
        success,
        fail,
        complete
    });
    if (options3.hasOwnProperty("animation") && typeof animation !== "boolean") {
        return handle3.fail({
            errMsg: getParameterError({
                para: "animation",
                correct: "Boolean",
                wrong: animation
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroHideTabBar", {
            animation,
            successHandler: (res = {})=>handle3.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle3.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
// node_modules/@tarojs/taro-h5/dist/api/ui/window.js
var callbackManager4 = new CallbackManager();
var resizeListener = ()=>{
    callbackManager4.trigger({
        windowWidth: window.screen.width,
        windowHeight: window.screen.height
    });
};
var setWindowSize = temporarilyNotSupport("setWindowSize");
var onWindowResize = (callback)=>{
    callbackManager4.add(callback);
    if (callbackManager4.count() === 1) {
        window.addEventListener("resize", resizeListener);
    }
};
var offWindowResize = (callback)=>{
    callbackManager4.remove(callback);
    if (callbackManager4.count() === 0) {
        window.removeEventListener("resize", resizeListener);
    }
};
// node_modules/@tarojs/taro-h5/dist/api/worker/index.js
var createWorker = temporarilyNotSupport("createWorker");
// node_modules/@tarojs/taro-h5/dist/api/wxml/IntersectionObserver.js
import("./intersection-observer-2ANYT6HD.js");
var TaroH5IntersectionObserver = class {
    get container() {
        const container = this._component !== null ? findDOM(this._component) || document : document;
        return container;
    }
    createInst() {
        this.disconnect();
        const { left =0 , top =0 , bottom =0 , right =0  } = this._rootMargin;
        return new IntersectionObserver((entries)=>{
            entries.forEach((entry)=>{
                const _callback = this._getCallbackByElement(entry.target);
                const result = {
                    boundingClientRect: entry.boundingClientRect,
                    intersectionRatio: entry.intersectionRatio,
                    intersectionRect: entry.intersectionRect,
                    relativeRect: entry.rootBounds || {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    },
                    time: entry.time
                };
                if (!this._isInited && this._options.initialRatio <= Math.min.apply(Math, this._options.thresholds)) {
                    return;
                }
                _callback && _callback.call(this, result);
            });
            this._isInited = true;
        }, {
            root: this._root,
            rootMargin: [
                `${top}px`,
                `${right}px`,
                `${bottom}px`,
                `${left}px`
            ].join(" "),
            threshold: this._options.thresholds
        });
    }
    disconnect() {
        if (this._observerInst) {
            let listener;
            while(listener = this._listeners.pop()){
                this._observerInst.unobserve(listener.element);
            }
            this._observerInst.disconnect();
        }
    }
    observe(targetSelector, callback) {
        if (this._listeners.length) return;
        if (!this._observerInst) {
            console.warn("Intersection observer will be ignored because no relative nodes are found.");
            return;
        }
        const nodeList = this._options.observeAll ? this.container.querySelectorAll(targetSelector) : [
            this.container.querySelector(targetSelector)
        ];
        nodeList.forEach((element)=>{
            if (!element) return;
            this._observerInst.observe(element);
            this._listeners.push({
                element,
                callback
            });
        });
    }
    relativeTo(selector, margins) {
        if (this._listeners.length) {
            console.error('Relative nodes cannot be added after "observe" call in IntersectionObserver');
            return this;
        }
        this._root = this.container.querySelector(selector) || null;
        if (margins) {
            this._rootMargin = margins;
        }
        this._observerInst = this.createInst();
        return this;
    }
    relativeToViewport(margins) {
        return this.relativeTo(".taro_page", margins);
    }
    _getCallbackByElement(element) {
        const listener = this._listeners.find((listener2)=>listener2.element === element);
        return listener ? listener.callback : null;
    }
    constructor(component, options3 = {}){
        this._options = {
            thresholds: [
                0
            ],
            initialRatio: 0,
            observeAll: false
        };
        this._listeners = [];
        this._rootMargin = {};
        this._isInited = false;
        this._component = component;
        Object.assign(this._options, options3);
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/MediaQueryObserver.js
function generateMediaQueryStr(descriptor) {
    const mediaQueryArr = [];
    const descriptorMenu = [
        "width",
        "minWidth",
        "maxWidth",
        "height",
        "minHeight",
        "maxHeight",
        "orientation"
    ];
    for (const item of descriptorMenu){
        if (item !== "orientation" && descriptor[item] && Number(descriptor[item]) >= 0) {
            mediaQueryArr.push(`(${toKebabCase(item)}: ${Number(descriptor[item])}px)`);
        }
        if (item === "orientation" && descriptor[item]) {
            mediaQueryArr.push(`(${toKebabCase(item)}: ${descriptor[item]})`);
        }
    }
    return mediaQueryArr.join(" and ");
}
var MediaQueryObserver = class {
    observe(descriptor, callback) {
        if (isFunction(callback)) {
            this._mediaQueryObserver = window.matchMedia(generateMediaQueryStr(descriptor));
            this._listener = (ev)=>{
                callback({
                    matches: ev.matches
                });
            };
            callback({
                matches: this._mediaQueryObserver.matches
            });
            if ("addEventListener" in this._mediaQueryObserver) {
                this._mediaQueryObserver.addEventListener("change", this._listener);
            } else {
                this._mediaQueryObserver.addListener(this._listener);
            }
        }
    }
    disconnect() {
        if (this._mediaQueryObserver && this._listener) {
            if ("removeEventListener" in this._mediaQueryObserver) {
                this._mediaQueryObserver.removeEventListener("change", this._listener);
            } else {
                this._mediaQueryObserver.removeListener(this._listener);
            }
        }
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/nodesRef.js
var NodesRef = class {
    context(cb) {
        const { _selector , _component , _single , _selectorQuery  } = this;
        _selectorQuery._push(_selector, _component, _single, {
            context: true
        }, cb);
        return _selectorQuery;
    }
    node(cb) {
        const { _selector , _component , _single , _selectorQuery  } = this;
        _selectorQuery._push(_selector, _component, _single, {
            nodeCanvasType: true,
            node: true
        }, cb);
        return _selectorQuery;
    }
    boundingClientRect(cb) {
        const { _selector , _component , _single , _selectorQuery  } = this;
        _selectorQuery._push(_selector, _component, _single, {
            id: true,
            dataset: true,
            rect: true,
            size: true
        }, cb);
        return _selectorQuery;
    }
    scrollOffset(cb) {
        const { _selector , _component , _single , _selectorQuery  } = this;
        _selectorQuery._push(_selector, _component, _single, {
            id: true,
            dataset: true,
            scrollOffset: true
        }, cb);
        return _selectorQuery;
    }
    fields(fields, cb) {
        const { _selector , _component , _single , _selectorQuery  } = this;
        const { id , dataset , rect , size , scrollOffset , properties =[] , computedStyle =[]  } = fields;
        _selectorQuery._push(_selector, _component, _single, {
            id,
            dataset,
            rect,
            size,
            scrollOffset,
            properties,
            computedStyle
        }, cb);
        return _selectorQuery;
    }
    constructor(selector, querySelectorQuery, single){
        this._component = querySelectorQuery._component;
        this._selector = selector;
        this._selectorQuery = querySelectorQuery;
        this._single = single;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/selectorQuery.js
function filter2(fields, dom, selector) {
    if (!dom) return null;
    const isViewport = selector === ".taro_page";
    const { id , dataset , rect , size , scrollOffset , properties =[] , computedStyle =[] , nodeCanvasType , node , context  } = fields;
    const res = {};
    if (nodeCanvasType && node) {
        const tagName = dom.tagName;
        res.node = {
            id: dom.id,
            $taroElement: dom
        };
        if (/^taro-canvas-core/i.test(tagName)) {
            const type = dom.type || "";
            res.nodeCanvasType = type;
            const canvas = dom.getElementsByTagName("canvas")[0];
            if (/^(2d|webgl)/i.test(type) && canvas) {
                res.node = canvas;
            } else {
                res.node = null;
            }
        } else if (/^taro-scroll-view-core/i.test(tagName)) {
            res.nodeCanvasType = "";
            res.node = dom;
            dom.scrollTo = dom.mpScrollToMethod;
            dom.scrollIntoView = dom.mpScrollIntoViewMethod;
        } else {
            res.nodeCanvasType = "";
            res.node = dom;
        }
        return res;
    }
    if (context) {
        const tagName = dom.tagName;
        if (/^taro-video-core/i.test(tagName)) {
            return {
                context: dom
            };
        } else if (/^taro-canvas-core/i.test(tagName)) {
            const type = dom.type || "2d";
            const canvas = dom === null || dom === void 0 ? void 0 : dom.querySelector("canvas");
            const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(type);
            return {
                context: new CanvasContext(canvas, ctx)
            };
        } else if (/^taro-live-player-core/i.test(tagName)) {
            console.error("\u6682\u65F6\u4E0D\u652F\u6301\u901A\u8FC7 NodesRef.context \u83B7\u53D6 LivePlayerContext");
        } else if (/^taro-editor-core/i.test(tagName)) {
            console.error("\u6682\u65F6\u4E0D\u652F\u6301\u901A\u8FC7 NodesRef.context \u83B7\u53D6 EditorContext");
        } else if (/^taro-map-core/i.test(tagName)) {
            console.error("\u6682\u65F6\u4E0D\u652F\u6301\u901A\u8FC7 NodesRef.context \u83B7\u53D6 MapContext");
        }
        return;
    }
    if (id) res.id = dom.id;
    if (dataset) res.dataset = Object.assign({}, dom.dataset);
    if (rect || size) {
        const { left , right , top , bottom , width , height  } = dom.getBoundingClientRect();
        if (rect) {
            if (!isViewport) {
                res.left = left;
                res.right = right;
                res.top = top;
                res.bottom = bottom;
            } else {
                res.left = 0;
                res.right = 0;
                res.top = 0;
                res.bottom = 0;
            }
        }
        if (size) {
            if (!isViewport) {
                res.width = width;
                res.height = height;
            } else {
                res.width = dom.clientWidth;
                res.height = dom.clientHeight;
            }
        }
    }
    if (scrollOffset) {
        res.scrollLeft = dom.scrollLeft;
        res.scrollTop = dom.scrollTop;
    }
    if (properties.length) {
        properties.forEach((prop)=>{
            const attr2 = dom.getAttribute(prop);
            if (attr2) res[prop] = attr2;
        });
    }
    if (computedStyle.length) {
        const styles3 = window.getComputedStyle(dom);
        computedStyle.forEach((key)=>{
            const value = styles3.getPropertyValue(key) || styles3[key];
            if (value) res[key] = value;
        });
    }
    return res;
}
function queryBat(queue, cb) {
    const result = [];
    queue.forEach((item)=>{
        var _a;
        const { selector , single , fields , component  } = item;
        const container = component !== null ? findDOM(component) || document : document;
        let selectSelf = false;
        if (container !== document) {
            const $nodeList = (_a = container.parentNode) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector);
            if ($nodeList) {
                for(let i2 = 0, len = $nodeList.length; i2 < len; ++i2){
                    if (container === $nodeList[i2]) {
                        selectSelf = true;
                        break;
                    }
                }
            }
        }
        if (single) {
            const el = selectSelf === true ? container : container.querySelector(selector);
            result.push(filter2(fields, el, selector));
        } else {
            const $children = container.querySelectorAll(selector);
            const children2 = [];
            selectSelf === true && children2.push(container);
            for(let i2 = 0, len = $children.length; i2 < len; ++i2){
                children2.push($children[i2]);
            }
            result.push(children2.map((dom)=>filter2(fields, dom)));
        }
    });
    cb(result);
}
var SelectorQuery = class {
    in(component) {
        this._component = component;
        return this;
    }
    select(selector) {
        if (typeof selector === "string") selector = selector.replace(">>>", ">");
        return new NodesRef(selector, this, true);
    }
    selectAll(selector) {
        if (typeof selector === "string") selector = selector.replace(">>>", ">");
        return new NodesRef(selector, this, false);
    }
    selectViewport() {
        return new NodesRef(".taro_page", this, true);
    }
    exec(cb) {
        queryBat(this._queue, (res)=>{
            const _queueCb = this._queueCb;
            res.forEach((item, index2)=>{
                const cb2 = _queueCb[index2];
                isFunction(cb2) && cb2.call(this, item);
            });
            isFunction(cb) && cb.call(this, res);
        });
        return this;
    }
    _push(selector, component, single, fields, callback = null) {
        this._queue.push({
            component,
            selector,
            single,
            fields
        });
        this._queueCb.push(callback);
    }
    constructor(){
        this._defaultWebviewId = null;
        this._webviewId = null;
        this._queue = [];
        this._queueCb = [];
        this._component;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/index.js
var createSelectorQuery = ()=>{
    return new SelectorQuery();
};
var createIntersectionObserver = (component, options3)=>{
    return new TaroH5IntersectionObserver(component, options3);
};
var createMediaQueryObserver = ()=>{
    return new MediaQueryObserver();
};
// node_modules/@tarojs/taro-h5/dist/api/taro.js
var { Behavior: Behavior2 , getEnv: getEnv2 , ENV_TYPE: ENV_TYPE2 , Link: Link3 , interceptors: interceptors2 , getInitPxTransform: getInitPxTransform2 , Current: Current2 , options: options2 , eventCenter: eventCenter2 , Events: Events2 , preload  } = Taro;
var taro = {
    Behavior: Behavior2,
    getEnv: getEnv2,
    ENV_TYPE: ENV_TYPE2,
    Link: Link3,
    interceptors: interceptors2,
    Current: Current2,
    getCurrentInstance: getCurrentInstance2,
    options: options2,
    nextTick: nextTick4,
    eventCenter: eventCenter2,
    Events: Events2,
    preload,
    history,
    navigateBack,
    navigateTo,
    reLaunch,
    redirectTo,
    getCurrentPages,
    switchTab
};
var initPxTransform = getInitPxTransform2(taro);
var requirePlugin = permanentlyNotSupport("requirePlugin");
var pxTransform = function(size) {
    const config = taro.config;
    const baseFontSize = config.baseFontSize || 20;
    const designWidth = ((input = 0)=>isFunction(config.designWidth) ? config.designWidth(input) : config.designWidth)(size);
    const rootValue = baseFontSize / config.deviceRatio[designWidth] * 2;
    return Math.ceil(parseInt(size, 10) / rootValue * 1e4) / 1e4 + "rem";
};
var canIUseWebp = function() {
    const canvas = document.createElement("canvas");
    return canvas.toDataURL("image/webp").indexOf("data:image/webp") === 0;
};
taro.requirePlugin = requirePlugin;
taro.getApp = getApp2;
taro.pxTransform = pxTransform;
taro.initPxTransform = initPxTransform;
taro.canIUseWebp = canIUseWebp;
taro.useAddToFavorites = useAddToFavorites;
taro.useDidHide = useDidHide;
taro.useDidShow = useDidShow;
taro.useError = useError;
taro.useLaunch = useLaunch;
taro.useLoad = useLoad;
taro.useOptionMenuClick = useOptionMenuClick;
taro.usePageNotFound = usePageNotFound;
taro.usePageScroll = usePageScroll;
taro.usePullDownRefresh = usePullDownRefresh;
taro.usePullIntercept = usePullIntercept;
taro.useReachBottom = useReachBottom;
taro.useReady = useReady;
taro.useResize = useResize;
taro.useRouter = useRouter;
taro.useSaveExitState = useSaveExitState;
taro.useShareAppMessage = useShareAppMessage;
taro.useShareTimeline = useShareTimeline;
taro.useTabItemTap = useTabItemTap;
taro.useTitleClick = useTitleClick;
taro.useScope = useScope;
taro.useUnload = useUnload;
// node_modules/@tarojs/router/dist/tabbar.js
function initTabbar(config) {
    if (config.tabBar == null) {
        return;
    }
    const tabbar = document.createElement("taro-tabbar");
    const homePage = config.entryPagePath || (config.pages ? config.pages[0] : "");
    tabbar.conf = config.tabBar;
    tabbar.conf.homePage = history.location.pathname === "/" ? homePage : history.location.pathname;
    const routerConfig = config.router;
    tabbar.conf.mode = routerConfig && routerConfig.mode ? routerConfig.mode : "hash";
    if (routerConfig.customRoutes) {
        tabbar.conf.custom = true;
        tabbar.conf.customRoutes = routerConfig.customRoutes;
    } else {
        tabbar.conf.custom = false;
        tabbar.conf.customRoutes = {};
    }
    if (typeof routerConfig.basename !== "undefined") {
        tabbar.conf.basename = routerConfig.basename;
    }
    const container = document.getElementById("container");
    container === null || container === void 0 ? void 0 : container.appendChild(tabbar);
    initTabBarApis(config);
}
// node_modules/@tarojs/router/dist/router/multi-page.js
var MultiPageHandler = class {
    get appId() {
        return this.config.appId || "app";
    }
    get router() {
        return this.config.router || {};
    }
    get routerMode() {
        return this.router.mode || "hash";
    }
    get customRoutes() {
        return this.router.customRoutes || {};
    }
    get tabBarList() {
        var _a;
        return ((_a = this.config.tabBar) === null || _a === void 0 ? void 0 : _a.list) || [];
    }
    get PullDownRefresh() {
        return this.config.PullDownRefresh;
    }
    set pathname(p) {
        this.router.pathname = p;
    }
    get pathname() {
        return this.router.pathname;
    }
    get basename() {
        return this.router.basename || "";
    }
    get pageConfig() {
        return this.config.route;
    }
    get isTabBar() {
        var _a;
        const routePath = addLeadingSlash(stripBasename(this.pathname, this.basename));
        const pagePath = ((_a = Object.entries(this.customRoutes).find(([, target])=>{
            if (typeof target === "string") {
                return target === routePath;
            } else if ((target === null || target === void 0 ? void 0 : target.length) > 0) {
                return target.includes(routePath);
            }
            return false;
        })) === null || _a === void 0 ? void 0 : _a[0]) || routePath;
        return !!pagePath && this.tabBarList.some((t)=>t.pagePath === pagePath);
    }
    get search() {
        return location.search.substr(1);
    }
    getQuery(search = "", options3 = {}) {
        search = search ? `${search}&${this.search}` : this.search;
        const query = search ? import_query_string4.default.parse(search) : {};
        return Object.assign(Object.assign({}, query), options3);
    }
    mount() {
        setHistoryMode(this.routerMode, this.router.basename);
        const appId = this.appId;
        let app = document.getElementById(appId);
        if (!app) {
            app = document.createElement("div");
            app.id = appId;
        }
        app.classList.add("taro_router");
        if (this.tabBarList.length > 1) {
            const container = document.createElement("div");
            container.classList.add("taro-tabbar__container");
            container.id = "container";
            const panel = document.createElement("div");
            panel.classList.add("taro-tabbar__panel");
            panel.appendChild(app);
            container.appendChild(panel);
            document.body.appendChild(container);
            initTabbar(this.config);
        } else {
            document.body.appendChild(app);
        }
    }
    onReady(page, onLoad = true) {
        var _a;
        const pageEl = this.getPageContainer(page);
        if (pageEl && !(pageEl === null || pageEl === void 0 ? void 0 : pageEl["__isReady"])) {
            const el = pageEl.firstElementChild;
            (_a = el === null || el === void 0 ? void 0 : el["componentOnReady"]) === null || _a === void 0 ? void 0 : _a.call(el);
            onLoad && (pageEl["__page"] = page);
        }
    }
    load(page, pageConfig = {}) {
        var _a;
        if (!page) return;
        (_a = page.onLoad) === null || _a === void 0 ? void 0 : _a.call(page, this.getQuery("", page.options), ()=>{
            var _a2;
            const pageEl = this.getPageContainer(page);
            this.isTabBar && (pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_tabbar_page"));
            this.onReady(page, true);
            (_a2 = page.onShow) === null || _a2 === void 0 ? void 0 : _a2.call(page);
            this.bindPageEvents(page, pageEl, pageConfig);
        });
    }
    getPageContainer(page) {
        var _a;
        const path = page ? page === null || page === void 0 ? void 0 : page.path : (_a = Current.page) === null || _a === void 0 ? void 0 : _a.path;
        const id = path === null || path === void 0 ? void 0 : path.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, "\\$1");
        if (page) {
            return document.querySelector(`.taro_page#${id}`);
        }
        const el = id ? document.querySelector(`.taro_page#${id}`) : document.querySelector(".taro_page") || document.querySelector(".taro_router");
        return el || window;
    }
    bindPageEvents(page, pageEl, config = {}) {
        var _a;
        if (!pageEl) {
            pageEl = this.getPageContainer();
        }
        const distance = config.onReachBottomDistance || ((_a = this.config.window) === null || _a === void 0 ? void 0 : _a.onReachBottomDistance) || 50;
        bindPageScroll(page, pageEl, distance);
        bindPageResize(page);
    }
    constructor(config){
        this.config = config;
        this.mount();
    }
};
// node_modules/@tarojs/router/dist/router/mpa.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var createStampId2 = incrementId();
var launchStampId2 = createStampId2();
function createMultiRouter(app, config, framework) {
    var _a, _b, _c, _d, _e, _f;
    return __awaiter5(this, void 0, void 0, function*() {
        RouterConfig.config = config;
        const handler = new MultiPageHandler(config);
        const launchParam = {
            path: config.pageName,
            query: handler.getQuery(launchStampId2),
            scene: 0,
            shareTicket: "",
            referrerInfo: {}
        };
        eventCenter.trigger("__taroRouterLaunch", launchParam);
        (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, launchParam);
        app.onError && window.addEventListener("error", (e)=>{
            var _a2;
            return (_a2 = app.onError) === null || _a2 === void 0 ? void 0 : _a2.call(app, e.message);
        });
        const pathName = config.pageName;
        const pageConfig = handler.pageConfig;
        eventCenter.trigger("__taroRouterChange", {
            toLocation: {
                path: pathName
            }
        });
        let element;
        try {
            element = yield (_b = pageConfig.load) === null || _b === void 0 ? void 0 : _b.call(pageConfig);
            if (element instanceof Array) {
                element = element[0];
            }
        } catch (error) {
            throw new Error(error);
        }
        if (!element) return;
        let enablePullDownRefresh = ((_c = config === null || config === void 0 ? void 0 : config.window) === null || _c === void 0 ? void 0 : _c.enablePullDownRefresh) || false;
        if (pageConfig) {
            setTitle((_d = pageConfig.navigationBarTitleText) !== null && _d !== void 0 ? _d : document.title);
            if (typeof pageConfig.enablePullDownRefresh === "boolean") {
                enablePullDownRefresh = pageConfig.enablePullDownRefresh;
            }
        }
        const el = (_e = element.default) !== null && _e !== void 0 ? _e : element;
        const loadConfig = Object.assign({}, pageConfig);
        delete loadConfig["path"];
        delete loadConfig["load"];
        const page = createPageConfig(enablePullDownRefresh ? hooks.call("createPullDownComponent", el, location.pathname, framework, config.PullDownRefresh) : el, pathName + stringify(launchParam), {}, loadConfig);
        handler.load(page, pageConfig);
        (_f = app.onShow) === null || _f === void 0 ? void 0 : _f.call(app, launchParam);
    });
}
export { history, navigateTo, redirectTo, navigateBack, switchTab, reLaunch, getCurrentPages, createMultiRouter, createRouter, createRewardedVideoAd, createInterstitialAd, stopFaceDetect, initFaceDetect, faceDetect, isVKSupport, createVKSession, getOpenUserInfo, getUserCryptoManager, setEnableDebug, getRealtimeLogManager, getLogManager, reportPerformance, getPerformance, openSystemBluetoothSetting, openAppAuthorizeSetting, getWindowInfo, getSystemSetting, getDeviceInfo, getAppBaseInfo, getAppAuthorizeSetting, getSystemInfoSync, getSystemInfoAsync, getSystemInfo, updateWeChatApp, getUpdateManager, onUnhandledRejection, onThemeChange, onPageNotFound, onError, onAudioInterruptionEnd, onAudioInterruptionBegin, onAppShow, onAppHide, offUnhandledRejection, offThemeChange, offPageNotFound, offError, offAudioInterruptionEnd, offAudioInterruptionBegin, offAppShow, offAppHide, getLaunchOptionsSync, getEnterOptionsSync, env, canIUse, arrayBufferToBase64, base64ToArrayBuffer, createCanvasContext, canvasToTempFilePath, canvasPutImageData, canvasGetImageData, createOffscreenCanvas, cloud, reportMonitor, reportAnalytics, reportEvent, getExptInfoSync, stopAccelerometer, startAccelerometer, onAccelerometerChange, offAccelerometerChange, checkIsOpenAccessibility, getBatteryInfoSync, getBatteryInfo, stopBluetoothDevicesDiscovery, startBluetoothDevicesDiscovery, openBluetoothAdapter, onBluetoothDeviceFound, onBluetoothAdapterStateChange, offBluetoothDeviceFound, offBluetoothAdapterStateChange, makeBluetoothPair, isBluetoothDevicePaired, getConnectedBluetoothDevices, getBluetoothDevices, getBluetoothAdapterState, closeBluetoothAdapter, writeBLECharacteristicValue, setBLEMTU, readBLECharacteristicValue, onBLEMTUChange, onBLEConnectionStateChange, onBLECharacteristicValueChange, offBLEMTUChange, offBLEConnectionStateChange, offBLECharacteristicValueChange, notifyBLECharacteristicValueChange, getBLEMTU, getBLEDeviceServices, getBLEDeviceRSSI, getBLEDeviceCharacteristics, createBLEConnection, closeBLEConnection, onBLEPeripheralConnectionStateChanged, offBLEPeripheralConnectionStateChanged, createBLEPeripheralServer, addPhoneRepeatCalendar, addPhoneCalendar, setBackgroundFetchToken, onBackgroundFetchData, getBackgroundFetchToken, getBackgroundFetchData, setStorageSync, setStorage, revokeBufferURL, removeStorageSync, removeStorage, getStorageSync, getStorageInfoSync, getStorageInfo, getStorage, createBufferURL, clearStorageSync, clearStorage, setClipboardData, getClipboardData, stopCompass, startCompass, onCompassChange, offCompassChange, chooseContact, addPhoneContact, getRandomValues, stopGyroscope, startGyroscope, onGyroscopeChange, offGyroscopeChange, stopBeaconDiscovery, startBeaconDiscovery, onBeaconUpdate, onBeaconServiceChange, offBeaconUpdate, offBeaconServiceChange, getBeacons, onKeyboardHeightChange, offKeyboardHeightChange, hideKeyboard, getSelectedTextRange, onMemoryWarning, offMemoryWarning, stopDeviceMotionListening, startDeviceMotionListening, onDeviceMotionChange, offDeviceMotionChange, getNetworkType, onNetworkWeakChange, onNetworkStatusChange, offNetworkWeakChange, offNetworkStatusChange, getLocalIPAddress, stopHCE, startHCE, sendHCEMessage, onHCEMessage, offHCEMessage, getNFCAdapter, getHCEState, makePhoneCall, scanCode, setVisualEffectOnCapture, setScreenBrightness, setKeepScreenOn, onUserCaptureScreen, offUserCaptureScreen, getScreenBrightness, vibrateShort, vibrateLong, stopWifi, startWifi, setWifiList, onWifiConnectedWithPartialInfo, onWifiConnected, onGetWifiList, offWifiConnected, offGetWifiList, getWifiList, getConnectedWifi, connectWifi, getExtConfigSync, getExtConfig, saveFileToDisk, saveFile, removeSavedFile, openDocument, getSavedFileList, getSavedFileInfo, getFileSystemManager, getFileInfo, getApp2 as getApp, getCurrentInstance2 as getCurrentInstance, getLocation, chooseLocation, stopLocationUpdate, startLocationUpdateBackground, startLocationUpdate, openLocation, onLocationChangeError, onLocationChange, offLocationChangeError, offLocationChange, choosePoi, getFuzzyLocation, stopVoice, setInnerAudioOption, playVoice, pauseVoice, getAvailableAudioSources, createWebAudioContext, createMediaAudioPlayer, createInnerAudioContext, createAudioContext, stopBackgroundAudio, seekBackgroundAudio, playBackgroundAudio, pauseBackgroundAudio, onBackgroundAudioStop, onBackgroundAudioPlay, onBackgroundAudioPause, getBackgroundAudioPlayerState, getBackgroundAudioManager, createCameraContext, getImageInfo, previewImage, chooseImage, saveImageToPhotosAlbum, previewMedia, compressImage, chooseMessageFile, createLivePusherContext, createLivePlayerContext, createMapContext, createMediaRecorder, stopRecord, startRecord, getRecorderManager, saveVideoToPhotosAlbum, openVideoEditor, getVideoInfo, createVideoContext, compressVideo, chooseVideo, chooseMedia, createVideoDecoder, createMediaContainer, updateVoIPChatMuteConfig, subscribeVoIPVideoMembers, setEnable1v1Chat, onVoIPVideoMembersChanged, onVoIPChatStateChanged, onVoIPChatSpeakersChanged, onVoIPChatMembersChanged, onVoIPChatInterrupted, offVoIPVideoMembersChanged, offVoIPChatStateChanged, offVoIPChatMembersChanged, offVoIPChatInterrupted, joinVoIPChat, exitVoIPChat, openEmbeddedMiniProgram, navigateToMiniProgram, navigateBackMiniProgram, exitMiniProgram, openBusinessView, downloadFile, stopLocalServiceDiscovery, startLocalServiceDiscovery, onLocalServiceResolveFail, onLocalServiceLost, onLocalServiceFound, onLocalServiceDiscoveryStop, offLocalServiceResolveFail, offLocalServiceLost, offLocalServiceFound, offLocalServiceDiscoveryStop, request, addInterceptor, createTCPSocket, createUDPSocket, uploadFile, sendSocketMessage, onSocketOpen, onSocketMessage, onSocketError, onSocketClose, connectSocket, closeSocket, getAccountInfoSync, chooseAddress, authorizeForMiniProgram, authorize, openCard, addCard, reserveChannelsLive, openChannelsLive, openChannelsEvent, openChannelsActivity, getChannelsLiveNoticeInfo, getChannelsLiveInfo, openCustomerServiceChat, checkIsSupportFacialRecognition, startFacialRecognitionVerify, startFacialRecognitionVerifyAndUploadVideo, faceVerifyForPay, addVideoToFavorites, addFileToFavorites, checkIsAddedToMyMiniProgram, getGroupEnterInfo, chooseInvoiceTitle, chooseInvoice, chooseLicensePlate, pluginLogin, login, checkSession, showRedPackage, openSetting, getSetting, startSoterAuthentication, checkIsSupportSoterAuthentication, checkIsSoterEnrolledInDevice, requestSubscribeMessage, getUserProfile, getUserInfo, shareToWeRun, getWeRunData, requestPayment, requestOrderPayment, updateShareMenu, showShareMenu, showShareImageMenu, shareVideoMessage, shareFileMessage, onCopyUrl, offCopyUrl, hideShareMenu, getShareInfo, authPrivateMessage, setPageInfo, ocrIdCard, ocrBankCard, ocrDrivingLicense, ocrVehicleLicense, textReview, textToAudio, imageAudit, advancedGeneralIdentify, objectDetectIdentify, carClassify, dishClassify, logoClassify, animalClassify, plantClassify, getSwanId, requestPolymerPayment, navigateToSmartGameProgram, navigateToSmartProgram, navigateBackSmartProgram, preloadSubPackage, createAnimation, setBackgroundTextStyle, setBackgroundColor, nextTick4 as nextTick, loadFontFace, showToast, hideToast, showLoading, hideLoading, showModal, showActionSheet, enableAlertBeforeUnload, disableAlertBeforeUnload, getMenuButtonBoundingClientRect, showNavigationBarLoading, setNavigationBarTitle, setNavigationBarColor, hideNavigationBarLoading, hideHomeButton, startPullDownRefresh, stopPullDownRefresh, pageScrollTo, setTopBarText, initTabBarApis, showTabBarRedDot, showTabBar, setTabBarStyle, setTabBarItem, setTabBarBadge, removeTabBarBadge, hideTabBarRedDot, hideTabBar, setWindowSize, onWindowResize, offWindowResize, createWorker, createSelectorQuery, createIntersectionObserver, createMediaQueryObserver, Behavior2 as Behavior, getEnv2 as getEnv, ENV_TYPE2 as ENV_TYPE, Link3 as Link, interceptors2 as interceptors, Current2 as Current, options2 as options, eventCenter2 as eventCenter, Events2 as Events, preload, taro, initPxTransform, requirePlugin, pxTransform, canIUseWebp }; /*
object-assign
(c) Sindre Sorhus
@license MIT
*/  /*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/  /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */  /*! Universal Router | MIT License | https://www.kriasoft.com/universal-router/ */  /*!@license Copyright 2013, Heinrich Goebl, License: MIT, see https://github.com/hgoebl/mobile-detect.js*/  /*!__STENCIL_STATIC_IMPORT_SWITCH__*/  /*!mobile-detect v1.4.5 2021-03-13*/ 
