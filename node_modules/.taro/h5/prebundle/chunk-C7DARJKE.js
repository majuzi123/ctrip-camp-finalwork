// node_modules/@tarojs/shared/dist/shared.esm.js
var DEFAULT_EMPTY_ARRAY = "[]";
var NO_DEFAULT_VALUE = "";
var DEFAULT_TRUE = "!0";
var DEFAULT_FALSE = "!1";
var touchEvents = {
    bindTouchStart: NO_DEFAULT_VALUE,
    bindTouchMove: NO_DEFAULT_VALUE,
    bindTouchEnd: NO_DEFAULT_VALUE,
    bindTouchCancel: NO_DEFAULT_VALUE,
    bindLongTap: NO_DEFAULT_VALUE
};
var animation = {
    animation: NO_DEFAULT_VALUE,
    bindAnimationStart: NO_DEFAULT_VALUE,
    bindAnimationIteration: NO_DEFAULT_VALUE,
    bindAnimationEnd: NO_DEFAULT_VALUE,
    bindTransitionEnd: NO_DEFAULT_VALUE
};
function singleQuote(s) {
    return `'${s}'`;
}
var View = Object.assign(Object.assign({
    "hover-class": singleQuote("none"),
    "hover-stop-propagation": DEFAULT_FALSE,
    "hover-start-time": "50",
    "hover-stay-time": "400"
}, touchEvents), animation);
var Icon = {
    type: NO_DEFAULT_VALUE,
    size: "23",
    color: NO_DEFAULT_VALUE
};
var MapComp = Object.assign({
    longitude: NO_DEFAULT_VALUE,
    latitude: NO_DEFAULT_VALUE,
    scale: "16",
    markers: DEFAULT_EMPTY_ARRAY,
    covers: NO_DEFAULT_VALUE,
    polyline: DEFAULT_EMPTY_ARRAY,
    circles: DEFAULT_EMPTY_ARRAY,
    controls: DEFAULT_EMPTY_ARRAY,
    "include-points": DEFAULT_EMPTY_ARRAY,
    "show-location": NO_DEFAULT_VALUE,
    "layer-style": "1",
    bindMarkerTap: NO_DEFAULT_VALUE,
    bindControlTap: NO_DEFAULT_VALUE,
    bindCalloutTap: NO_DEFAULT_VALUE,
    bindUpdated: NO_DEFAULT_VALUE
}, touchEvents);
var Progress = {
    percent: NO_DEFAULT_VALUE,
    "stroke-width": "6",
    color: singleQuote("#09BB07"),
    activeColor: singleQuote("#09BB07"),
    backgroundColor: singleQuote("#EBEBEB"),
    active: DEFAULT_FALSE,
    "active-mode": singleQuote("backwards"),
    "show-info": DEFAULT_FALSE
};
var RichText = {
    nodes: DEFAULT_EMPTY_ARRAY
};
var Text = {
    selectable: DEFAULT_FALSE,
    space: NO_DEFAULT_VALUE,
    decode: DEFAULT_FALSE
};
var Button = Object.assign({
    size: singleQuote("default"),
    type: NO_DEFAULT_VALUE,
    plain: DEFAULT_FALSE,
    disabled: NO_DEFAULT_VALUE,
    loading: DEFAULT_FALSE,
    "form-type": NO_DEFAULT_VALUE,
    "open-type": NO_DEFAULT_VALUE,
    "hover-class": singleQuote("button-hover"),
    "hover-stop-propagation": DEFAULT_FALSE,
    "hover-start-time": "20",
    "hover-stay-time": "70",
    name: NO_DEFAULT_VALUE
}, touchEvents);
var Checkbox = {
    value: NO_DEFAULT_VALUE,
    disabled: NO_DEFAULT_VALUE,
    checked: DEFAULT_FALSE,
    color: singleQuote("#09BB07"),
    name: NO_DEFAULT_VALUE
};
var CheckboxGroup = {
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Form = {
    "report-submit": DEFAULT_FALSE,
    bindSubmit: NO_DEFAULT_VALUE,
    bindReset: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Input = {
    value: NO_DEFAULT_VALUE,
    type: singleQuote(NO_DEFAULT_VALUE),
    password: DEFAULT_FALSE,
    placeholder: NO_DEFAULT_VALUE,
    "placeholder-style": NO_DEFAULT_VALUE,
    "placeholder-class": singleQuote("input-placeholder"),
    disabled: NO_DEFAULT_VALUE,
    maxlength: "140",
    "cursor-spacing": "0",
    focus: DEFAULT_FALSE,
    "confirm-type": singleQuote("done"),
    "confirm-hold": DEFAULT_FALSE,
    cursor: "i.value.length",
    "selection-start": "-1",
    "selection-end": "-1",
    bindInput: NO_DEFAULT_VALUE,
    bindFocus: NO_DEFAULT_VALUE,
    bindBlur: NO_DEFAULT_VALUE,
    bindConfirm: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Label = {
    for: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Picker = {
    mode: singleQuote("selector"),
    disabled: NO_DEFAULT_VALUE,
    range: NO_DEFAULT_VALUE,
    "range-key": NO_DEFAULT_VALUE,
    value: NO_DEFAULT_VALUE,
    start: NO_DEFAULT_VALUE,
    end: NO_DEFAULT_VALUE,
    fields: singleQuote("day"),
    "custom-item": NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE,
    bindCancel: NO_DEFAULT_VALUE,
    bindChange: NO_DEFAULT_VALUE,
    bindColumnChange: NO_DEFAULT_VALUE
};
var PickerView = {
    value: NO_DEFAULT_VALUE,
    "indicator-style": NO_DEFAULT_VALUE,
    "indicator-class": NO_DEFAULT_VALUE,
    "mask-style": NO_DEFAULT_VALUE,
    "mask-class": NO_DEFAULT_VALUE,
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var PickerViewColumn = {
    name: NO_DEFAULT_VALUE
};
var Radio = {
    value: NO_DEFAULT_VALUE,
    checked: DEFAULT_FALSE,
    disabled: NO_DEFAULT_VALUE,
    color: singleQuote("#09BB07"),
    name: NO_DEFAULT_VALUE
};
var RadioGroup = {
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Slider = {
    min: "0",
    max: "100",
    step: "1",
    disabled: NO_DEFAULT_VALUE,
    value: "0",
    activeColor: singleQuote("#1aad19"),
    backgroundColor: singleQuote("#e9e9e9"),
    "block-size": "28",
    "block-color": singleQuote("#ffffff"),
    "show-value": DEFAULT_FALSE,
    bindChange: NO_DEFAULT_VALUE,
    bindChanging: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Switch = {
    checked: DEFAULT_FALSE,
    disabled: NO_DEFAULT_VALUE,
    type: singleQuote("switch"),
    color: singleQuote("#04BE02"),
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Textarea = {
    value: NO_DEFAULT_VALUE,
    placeholder: NO_DEFAULT_VALUE,
    "placeholder-style": NO_DEFAULT_VALUE,
    "placeholder-class": singleQuote("textarea-placeholder"),
    disabled: NO_DEFAULT_VALUE,
    maxlength: "140",
    "auto-focus": DEFAULT_FALSE,
    focus: DEFAULT_FALSE,
    "auto-height": DEFAULT_FALSE,
    fixed: DEFAULT_FALSE,
    "cursor-spacing": "0",
    cursor: "-1",
    "selection-start": "-1",
    "selection-end": "-1",
    bindFocus: NO_DEFAULT_VALUE,
    bindBlur: NO_DEFAULT_VALUE,
    bindLineChange: NO_DEFAULT_VALUE,
    bindInput: NO_DEFAULT_VALUE,
    bindConfirm: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var CoverImage = {
    src: NO_DEFAULT_VALUE,
    bindLoad: "eh",
    bindError: "eh"
};
var CoverView = Object.assign({
    "scroll-top": DEFAULT_FALSE
}, touchEvents);
var MovableArea = {
    "scale-area": DEFAULT_FALSE
};
var MovableView = Object.assign(Object.assign({
    direction: "none",
    inertia: DEFAULT_FALSE,
    "out-of-bounds": DEFAULT_FALSE,
    x: NO_DEFAULT_VALUE,
    y: NO_DEFAULT_VALUE,
    damping: "20",
    friction: "2",
    disabled: NO_DEFAULT_VALUE,
    scale: DEFAULT_FALSE,
    "scale-min": "0.5",
    "scale-max": "10",
    "scale-value": "1",
    bindChange: NO_DEFAULT_VALUE,
    bindScale: NO_DEFAULT_VALUE,
    bindHTouchMove: NO_DEFAULT_VALUE,
    bindVTouchMove: NO_DEFAULT_VALUE,
    width: singleQuote("10px"),
    height: singleQuote("10px")
}, touchEvents), animation);
var ScrollView = Object.assign(Object.assign({
    "scroll-x": DEFAULT_FALSE,
    "scroll-y": DEFAULT_FALSE,
    "upper-threshold": "50",
    "lower-threshold": "50",
    "scroll-top": NO_DEFAULT_VALUE,
    "scroll-left": NO_DEFAULT_VALUE,
    "scroll-into-view": NO_DEFAULT_VALUE,
    "scroll-with-animation": DEFAULT_FALSE,
    "enable-back-to-top": DEFAULT_FALSE,
    bindScrollToUpper: NO_DEFAULT_VALUE,
    bindScrollToLower: NO_DEFAULT_VALUE,
    bindScroll: NO_DEFAULT_VALUE
}, touchEvents), animation);
var Swiper = Object.assign({
    "indicator-dots": DEFAULT_FALSE,
    "indicator-color": singleQuote("rgba(0, 0, 0, .3)"),
    "indicator-active-color": singleQuote("#000000"),
    autoplay: DEFAULT_FALSE,
    current: "0",
    interval: "5000",
    duration: "500",
    circular: DEFAULT_FALSE,
    vertical: DEFAULT_FALSE,
    "previous-margin": singleQuote("0px"),
    "next-margin": singleQuote("0px"),
    "display-multiple-items": "1",
    bindChange: NO_DEFAULT_VALUE,
    bindTransition: NO_DEFAULT_VALUE,
    bindAnimationFinish: NO_DEFAULT_VALUE
}, touchEvents);
var SwiperItem = {
    "item-id": NO_DEFAULT_VALUE
};
var Navigator = {
    url: NO_DEFAULT_VALUE,
    "open-type": singleQuote("navigate"),
    delta: "1",
    "hover-class": singleQuote("navigator-hover"),
    "hover-stop-propagation": DEFAULT_FALSE,
    "hover-start-time": "50",
    "hover-stay-time": "600",
    bindSuccess: NO_DEFAULT_VALUE,
    bindFail: NO_DEFAULT_VALUE,
    bindComplete: NO_DEFAULT_VALUE
};
var Audio = {
    id: NO_DEFAULT_VALUE,
    src: NO_DEFAULT_VALUE,
    loop: DEFAULT_FALSE,
    controls: DEFAULT_FALSE,
    poster: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE,
    author: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE,
    bindPlay: NO_DEFAULT_VALUE,
    bindPause: NO_DEFAULT_VALUE,
    bindTimeUpdate: NO_DEFAULT_VALUE,
    bindEnded: NO_DEFAULT_VALUE
};
var Camera = {
    "device-position": singleQuote("back"),
    flash: singleQuote("auto"),
    bindStop: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE
};
var Image = Object.assign({
    src: NO_DEFAULT_VALUE,
    mode: singleQuote("scaleToFill"),
    "lazy-load": DEFAULT_FALSE,
    bindError: NO_DEFAULT_VALUE,
    bindLoad: NO_DEFAULT_VALUE
}, touchEvents);
var LivePlayer = Object.assign({
    src: NO_DEFAULT_VALUE,
    autoplay: DEFAULT_FALSE,
    muted: DEFAULT_FALSE,
    orientation: singleQuote("vertical"),
    "object-fit": singleQuote("contain"),
    "background-mute": DEFAULT_FALSE,
    "min-cache": "1",
    "max-cache": "3",
    bindStateChange: NO_DEFAULT_VALUE,
    bindFullScreenChange: NO_DEFAULT_VALUE,
    bindNetStatus: NO_DEFAULT_VALUE
}, animation);
var Video = Object.assign({
    src: NO_DEFAULT_VALUE,
    duration: NO_DEFAULT_VALUE,
    controls: DEFAULT_TRUE,
    "danmu-list": NO_DEFAULT_VALUE,
    "danmu-btn": NO_DEFAULT_VALUE,
    "enable-danmu": NO_DEFAULT_VALUE,
    autoplay: DEFAULT_FALSE,
    loop: DEFAULT_FALSE,
    muted: DEFAULT_FALSE,
    "initial-time": "0",
    "page-gesture": DEFAULT_FALSE,
    direction: NO_DEFAULT_VALUE,
    "show-progress": DEFAULT_TRUE,
    "show-fullscreen-btn": DEFAULT_TRUE,
    "show-play-btn": DEFAULT_TRUE,
    "show-center-play-btn": DEFAULT_TRUE,
    "enable-progress-gesture": DEFAULT_TRUE,
    "object-fit": singleQuote("contain"),
    poster: NO_DEFAULT_VALUE,
    "show-mute-btn": DEFAULT_FALSE,
    bindPlay: NO_DEFAULT_VALUE,
    bindPause: NO_DEFAULT_VALUE,
    bindEnded: NO_DEFAULT_VALUE,
    bindTimeUpdate: NO_DEFAULT_VALUE,
    bindFullScreenChange: NO_DEFAULT_VALUE,
    bindWaiting: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE
}, animation);
var Canvas = Object.assign({
    "canvas-id": NO_DEFAULT_VALUE,
    "disable-scroll": DEFAULT_FALSE,
    bindError: NO_DEFAULT_VALUE
}, touchEvents);
var Ad = {
    "unit-id": NO_DEFAULT_VALUE,
    "ad-intervals": NO_DEFAULT_VALUE,
    bindLoad: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE,
    bindClose: NO_DEFAULT_VALUE
};
var WebView = {
    src: NO_DEFAULT_VALUE,
    bindMessage: NO_DEFAULT_VALUE,
    bindLoad: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE
};
var Block = {};
var SlotView = {
    name: NO_DEFAULT_VALUE
};
var Slot = {
    name: NO_DEFAULT_VALUE
};
var NativeSlot = {
    name: NO_DEFAULT_VALUE
};
var internalComponents = {
    View,
    Icon,
    Progress,
    RichText,
    Text,
    Button,
    Checkbox,
    CheckboxGroup,
    Form,
    Input,
    Label,
    Picker,
    PickerView,
    PickerViewColumn,
    Radio,
    RadioGroup,
    Slider,
    Switch,
    CoverImage,
    Textarea,
    CoverView,
    MovableArea,
    MovableView,
    ScrollView,
    Swiper,
    SwiperItem,
    Navigator,
    Audio,
    Camera,
    Image,
    LivePlayer,
    Video,
    Canvas,
    Ad,
    WebView,
    Block,
    Map: MapComp,
    Slot,
    SlotView,
    NativeSlot
};
var Events = class {
    on(eventName, callback, context) {
        let event, node, tail, list;
        if (!callback) {
            return this;
        }
        eventName = eventName.split(Events.eventSplitter);
        this.callbacks || (this.callbacks = {});
        const calls = this.callbacks;
        while(event = eventName.shift()){
            list = calls[event];
            node = list ? list.tail : {};
            node.next = tail = {};
            node.context = context;
            node.callback = callback;
            calls[event] = {
                tail,
                next: list ? list.next : node
            };
        }
        return this;
    }
    once(events, callback, context) {
        const wrapper = (...args)=>{
            callback.apply(this, args);
            this.off(events, wrapper, context);
        };
        this.on(events, wrapper, context);
        return this;
    }
    off(events, callback, context) {
        let event, calls, node, tail, cb, ctx;
        if (!(calls = this.callbacks)) {
            return this;
        }
        if (!(events || callback || context)) {
            delete this.callbacks;
            return this;
        }
        events = events ? events.split(Events.eventSplitter) : Object.keys(calls);
        while(event = events.shift()){
            node = calls[event];
            delete calls[event];
            if (!node || !(callback || context)) {
                continue;
            }
            tail = node.tail;
            while((node = node.next) !== tail){
                cb = node.callback;
                ctx = node.context;
                if (callback && cb !== callback || context && ctx !== context) {
                    this.on(event, cb, ctx);
                }
            }
        }
        return this;
    }
    trigger(events) {
        let event, node, calls, tail;
        if (!(calls = this.callbacks)) {
            return this;
        }
        events = events.split(Events.eventSplitter);
        const rest = [].slice.call(arguments, 1);
        while(event = events.shift()){
            if (node = calls[event]) {
                tail = node.tail;
                while((node = node.next) !== tail){
                    node.callback.apply(node.context || this, rest);
                }
            }
        }
        return this;
    }
    constructor(opts){
        var _a;
        this.callbacks = (_a = opts === null || opts === void 0 ? void 0 : opts.callbacks) !== null && _a !== void 0 ? _a : {};
    }
};
Events.eventSplitter = ",";
function isString(o) {
    return typeof o === "string";
}
function isUndefined(o) {
    return typeof o === "undefined";
}
function isNull(o) {
    return o === null;
}
function isObject(o) {
    return o !== null && typeof o === "object";
}
function isFunction(o) {
    return typeof o === "function";
}
function isNumber(o) {
    return typeof o === "number";
}
var isArray = Array.isArray;
var HOOK_TYPE;
(function(HOOK_TYPE2) {
    HOOK_TYPE2[HOOK_TYPE2["SINGLE"] = 0] = "SINGLE";
    HOOK_TYPE2[HOOK_TYPE2["MULTI"] = 1] = "MULTI";
    HOOK_TYPE2[HOOK_TYPE2["WATERFALL"] = 2] = "WATERFALL";
})(HOOK_TYPE || (HOOK_TYPE = {}));
var defaultMiniLifecycle = {
    app: [
        "onLaunch",
        "onShow",
        "onHide"
    ],
    page: [
        "onLoad",
        "onUnload",
        "onReady",
        "onShow",
        "onHide",
        [
            "onPullDownRefresh",
            "onReachBottom",
            "onPageScroll",
            "onResize",
            "onTabItemTap",
            "onTitleClick",
            "onOptionMenuClick",
            "onPopMenuClick",
            "onPullIntercept",
            "onAddToFavorites"
        ],
        [
            "onShareAppMessage",
            "onShareTimeline"
        ]
    ],
    component: [
        "attached",
        "detached"
    ]
};
function TaroHook(type, initial) {
    return {
        type,
        initial: initial || null
    };
}
var TaroHooks = class extends Events {
    tapOneOrMany(hookName, callback) {
        const list = isFunction(callback) ? [
            callback
        ] : callback;
        list.forEach((cb)=>this.on(hookName, cb));
    }
    tap(hookName, callback) {
        const hooks2 = this.hooks;
        const { type , initial  } = hooks2[hookName];
        if (type === HOOK_TYPE.SINGLE) {
            this.off(hookName);
            this.on(hookName, isFunction(callback) ? callback : callback[callback.length - 1]);
        } else {
            initial && this.off(hookName, initial);
            this.tapOneOrMany(hookName, callback);
        }
    }
    call(hookName, ...rest) {
        var _a;
        const hook = this.hooks[hookName];
        if (!hook) return;
        const { type  } = hook;
        const calls = this.callbacks;
        if (!calls) return;
        const list = calls[hookName];
        if (list) {
            const tail = list.tail;
            let node = list.next;
            let args = rest;
            let res;
            while(node !== tail){
                res = (_a = node.callback) === null || _a === void 0 ? void 0 : _a.apply(node.context || this, args);
                if (type === HOOK_TYPE.WATERFALL) {
                    const params = [
                        res
                    ];
                    args = params;
                }
                node = node.next;
            }
            return res;
        }
    }
    isExist(hookName) {
        var _a;
        return Boolean((_a = this.callbacks) === null || _a === void 0 ? void 0 : _a[hookName]);
    }
    constructor(hooks2, opts){
        super(opts);
        this.hooks = hooks2;
        for(const hookName in hooks2){
            const { initial  } = hooks2[hookName];
            if (isFunction(initial)) {
                this.on(hookName, initial);
            }
        }
    }
};
var hooks = new TaroHooks({
    getMiniLifecycle: TaroHook(HOOK_TYPE.SINGLE, (defaultConfig)=>defaultConfig),
    getMiniLifecycleImpl: TaroHook(HOOK_TYPE.SINGLE, function() {
        return this.call("getMiniLifecycle", defaultMiniLifecycle);
    }),
    getLifecycle: TaroHook(HOOK_TYPE.SINGLE, (instance, lifecycle)=>instance[lifecycle]),
    getPathIndex: TaroHook(HOOK_TYPE.SINGLE, (indexOfNode)=>`[${indexOfNode}]`),
    getEventCenter: TaroHook(HOOK_TYPE.SINGLE, (Events2)=>new Events2()),
    isBubbleEvents: TaroHook(HOOK_TYPE.SINGLE, (eventName)=>{
        const BUBBLE_EVENTS = /* @__PURE__ */ new Set([
            "touchstart",
            "touchmove",
            "touchcancel",
            "touchend",
            "touchforcechange",
            "tap",
            "longpress",
            "longtap",
            "transitionend",
            "animationstart",
            "animationiteration",
            "animationend"
        ]);
        return BUBBLE_EVENTS.has(eventName);
    }),
    getSpecialNodes: TaroHook(HOOK_TYPE.SINGLE, ()=>[
            "view",
            "text",
            "image"
        ]),
    onRemoveAttribute: TaroHook(HOOK_TYPE.SINGLE),
    batchedEventUpdates: TaroHook(HOOK_TYPE.SINGLE),
    mergePageInstance: TaroHook(HOOK_TYPE.SINGLE),
    modifyPageObject: TaroHook(HOOK_TYPE.SINGLE),
    createPullDownComponent: TaroHook(HOOK_TYPE.SINGLE),
    getDOMNode: TaroHook(HOOK_TYPE.SINGLE),
    modifyHydrateData: TaroHook(HOOK_TYPE.SINGLE),
    modifySetAttrPayload: TaroHook(HOOK_TYPE.SINGLE),
    modifyRmAttrPayload: TaroHook(HOOK_TYPE.SINGLE),
    onAddEvent: TaroHook(HOOK_TYPE.SINGLE),
    modifyMpEvent: TaroHook(HOOK_TYPE.MULTI),
    modifyMpEventImpl: TaroHook(HOOK_TYPE.SINGLE, function(e) {
        try {
            this.call("modifyMpEvent", e);
        } catch (error) {
            console.warn("[Taro modifyMpEvent hook Error]: " + (error === null || error === void 0 ? void 0 : error.message));
        }
    }),
    modifyTaroEvent: TaroHook(HOOK_TYPE.MULTI),
    modifyDispatchEvent: TaroHook(HOOK_TYPE.MULTI),
    initNativeApi: TaroHook(HOOK_TYPE.MULTI),
    patchElement: TaroHook(HOOK_TYPE.MULTI)
});
var EMPTY_OBJ = {};
var noop = (..._)=>{};
function toDashed(s) {
    return s.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function toCamelCase(s) {
    let camel = "";
    let nextCap = false;
    for(let i = 0; i < s.length; i++){
        if (s[i] !== "-") {
            camel += nextCap ? s[i].toUpperCase() : s[i];
            nextCap = false;
        } else {
            nextCap = true;
        }
    }
    return camel;
}
function ensure(condition, msg2) {
    if (!condition) {
        if (true) {
            const reportIssue = "\n\u5982\u6709\u7591\u95EE\uFF0C\u8BF7\u63D0\u4EA4 issue \u81F3\uFF1Ahttps://github.com/nervjs/taro/issues";
            throw new Error(msg2 + reportIssue);
        } else {
            throw new Error(msg2);
        }
    }
}
function warn(condition, msg2) {
    if (true) {
        if (condition) {
            console.warn(`[taro warn] ${msg2}`);
        }
    }
}
var _loadTime = new Date().getTime().toString();
function getComponentsAlias(origin) {
    const mapping = {};
    const viewAttrs = origin.View;
    const extraList = {
        "#text": {},
        StaticView: viewAttrs,
        StaticImage: origin.Image,
        StaticText: origin.Text,
        PureView: viewAttrs,
        CatchView: viewAttrs
    };
    origin = Object.assign(Object.assign({}, origin), extraList);
    Object.keys(origin).sort((a, b)=>{
        const reg = /^(Static|Pure|Catch)*(View|Image|Text)$/;
        const isACommonly = reg.test(a);
        const isBCommonly = reg.test(b);
        if (isACommonly && isBCommonly) {
            return a > b ? 1 : -1;
        } else if (isACommonly) {
            return -1;
        } else if (isBCommonly) {
            return 1;
        } else {
            return a >= b ? 1 : -1;
        }
    }).forEach((key, num)=>{
        const obj = {
            _num: String(num)
        };
        Object.keys(origin[key]).filter((attr)=>!/^bind/.test(attr) && ![
                "focus",
                "blur"
            ].includes(attr)).sort().forEach((attr, index)=>{
            obj[toCamelCase(attr)] = "p" + index;
        });
        mapping[toDashed(key)] = obj;
    });
    return mapping;
}
// node_modules/@tarojs/runtime/dist/runtime.esm.js
var PROPERTY_THRESHOLD = 2046;
var SET_DATA = "\u5C0F\u7A0B\u5E8F setData";
var PAGE_INIT = "\u9875\u9762\u521D\u59CB\u5316";
var ROOT_STR = "root";
var DOCUMENT_FRAGMENT = "document-fragment";
var ID = "id";
var UID = "uid";
var CLASS = "class";
var STYLE = "style";
var FOCUS = "focus";
var VIEW = "view";
var STATIC_VIEW = "static-view";
var PURE_VIEW = "pure-view";
var VALUE = "value";
var INPUT = "input";
var CHANGE = "change";
var CUSTOM_WRAPPER = "custom-wrapper";
var TARGET = "target";
var CURRENT_TARGET = "currentTarget";
var TYPE = "type";
var CONFIRM = "confirm";
var TIME_STAMP = "timeStamp";
var KEY_CODE = "keyCode";
var TOUCHMOVE = "touchmove";
var CATCHMOVE = "catchMove";
var CATCH_VIEW = "catch-view";
var COMMENT = "comment";
var ON_LOAD = "onLoad";
var ON_READY = "onReady";
var ON_SHOW = "onShow";
var ON_HIDE = "onHide";
var OPTIONS = "options";
var EXTERNAL_CLASSES = "externalClasses";
var EVENT_CALLBACK_RESULT = "e_result";
var BEHAVIORS = "behaviors";
var CONTEXT_ACTIONS;
(function(CONTEXT_ACTIONS2) {
    CONTEXT_ACTIONS2["INIT"] = "0";
    CONTEXT_ACTIONS2["RESTORE"] = "1";
    CONTEXT_ACTIONS2["RECOVER"] = "2";
    CONTEXT_ACTIONS2["DESTORY"] = "3";
})(CONTEXT_ACTIONS || (CONTEXT_ACTIONS = {}));
var observers = [];
var MutationObserverImpl = class {
    observe(target, options2) {
        this.disconnect();
        this.target = target;
        this.options = options2 || {};
        observers.push(this);
    }
    disconnect() {
        this.target = null;
        const index = observers.indexOf(this);
        if (index >= 0) {
            observers.splice(index, 1);
        }
    }
    takeRecords() {
        return this.records.splice(0, this.records.length);
    }
    constructor(callback){
        this.records = [];
        this.callback = callback;
    }
};
var sidMatches = (observerTarget, target)=>{
    return !!observerTarget && observerTarget.sid === (target === null || target === void 0 ? void 0 : target.sid);
};
var isConcerned = (record, options2)=>{
    const { characterData , characterDataOldValue , attributes , attributeOldValue , childList  } = options2;
    switch(record.type){
        case "characterData":
            if (characterData) {
                if (!characterDataOldValue) record.oldValue = null;
                return true;
            }
            return false;
        case "attributes":
            if (attributes) {
                if (!attributeOldValue) record.oldValue = null;
                return true;
            }
            return false;
        case "childList":
            if (childList) {
                return true;
            }
            return false;
    }
};
var pendingMuatations = false;
function logMutation(observer, record) {
    observer.records.push(record);
    if (!pendingMuatations) {
        pendingMuatations = true;
        Promise.resolve().then(()=>{
            pendingMuatations = false;
            observers.forEach((observer2)=>{
                return observer2.callback(observer2.takeRecords());
            });
        });
    }
}
function recordMutation(record) {
    observers.forEach((observer)=>{
        const { options: options2  } = observer;
        for(let t = record.target; t; t = t.parentNode){
            if (sidMatches(observer.target, t) && isConcerned(record, options2)) {
                logMutation(observer, record);
                break;
            }
            if (!options2.subtree) break;
        }
    });
}
var MutationObserver = class {
    observe(...args) {
        this.core.observe(...args);
    }
    disconnect() {
        this.core.disconnect();
    }
    takeRecords() {
        return this.core.takeRecords();
    }
    static record(record) {
        recordMutation(record);
    }
    constructor(callback){
        if (ENABLE_MUTATION_OBSERVER) {
            this.core = new MutationObserverImpl(callback);
        } else {
            if (true) {
                console.warn("[Taro Warning] \u82E5\u8981\u4F7F\u7528 MutationObserver\uFF0C\u8BF7\u5728 Taro \u7F16\u8BD1\u914D\u7F6E\u4E2D\u8BBE\u7F6E 'mini.enableMutationObserver: true'");
            }
            this.core = {
                observe: noop,
                disconnect: noop,
                takeRecords: noop
            };
        }
    }
};
var incrementId = ()=>{
    const chatCodes = [];
    for(let i = 65; i <= 90; i++){
        chatCodes.push(i);
    }
    for(let i = 97; i <= 122; i++){
        chatCodes.push(i);
    }
    const chatCodesLen = chatCodes.length - 1;
    const list = [
        0,
        0
    ];
    return ()=>{
        const target = list.map((item)=>chatCodes[item]);
        const res = String.fromCharCode(...target);
        let tailIdx = list.length - 1;
        list[tailIdx]++;
        while(list[tailIdx] > chatCodesLen){
            list[tailIdx] = 0;
            tailIdx = tailIdx - 1;
            if (tailIdx < 0) {
                list.push(0);
                break;
            }
            list[tailIdx]++;
        }
        return res;
    };
};
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeName === COMMENT;
}
function isHasExtractProp(el) {
    const res = Object.keys(el.props).find((prop)=>{
        return !(/^(class|style|id)$/.test(prop) || prop.startsWith("data-"));
    });
    return Boolean(res);
}
function isParentBinded(node, type) {
    var _a;
    let res = false;
    while((node === null || node === void 0 ? void 0 : node.parentElement) && node.parentElement._path !== ROOT_STR){
        if ((_a = node.parentElement.__handlers[type]) === null || _a === void 0 ? void 0 : _a.length) {
            res = true;
            break;
        }
        node = node.parentElement;
    }
    return res;
}
function shortcutAttr(key) {
    switch(key){
        case STYLE:
            return "st";
        case ID:
            return UID;
        case CLASS:
            return "cl";
        default:
            return key;
    }
}
var customWrapperCache = /* @__PURE__ */ new Map();
function extend(ctor, methodName, options2) {
    if (isFunction(options2)) {
        options2 = {
            value: options2
        };
    }
    Object.defineProperty(ctor.prototype, methodName, Object.assign({
        configurable: true,
        enumerable: true
    }, options2));
}
var componentsAlias$1;
function getComponentsAlias2() {
    if (!componentsAlias$1) {
        componentsAlias$1 = getComponentsAlias(internalComponents);
    }
    return componentsAlias$1;
}
var ClassList = class extends Set {
    get value() {
        return [
            ...this
        ].filter((v)=>v !== "").join(" ");
    }
    add(s) {
        super.add(s);
        this._update();
        return this;
    }
    get length() {
        return this.size;
    }
    remove(s) {
        super.delete(s);
        this._update();
    }
    toggle(s) {
        if (super.has(s)) {
            super.delete(s);
        } else {
            super.add(s);
        }
        this._update();
    }
    replace(s1, s2) {
        super.delete(s1);
        super.add(s2);
        this._update();
    }
    contains(s) {
        return super.has(s);
    }
    toString() {
        return this.value;
    }
    _update() {
        this.el.className = this.value;
    }
    constructor(className, el){
        super();
        className.trim().split(/\s+/).forEach(super.add.bind(this));
        this.el = el;
    }
};
var EventSource = class extends Map {
    removeNode(child) {
        const { sid , uid  } = child;
        this.delete(sid);
        if (uid !== sid && uid) this.delete(uid);
    }
    removeNodeTree(child) {
        this.removeNode(child);
        const { childNodes  } = child;
        childNodes.forEach((node)=>this.removeNodeTree(node));
    }
};
var eventSource = new EventSource();
var env = {
    window: true ? window : EMPTY_OBJ,
    document: true ? document : EMPTY_OBJ
};
var SPECIAL_NODES;
var componentsAlias;
function hydrate(node) {
    if (!componentsAlias) {
        componentsAlias = getComponentsAlias2();
    }
    if (!SPECIAL_NODES) {
        SPECIAL_NODES = hooks.call("getSpecialNodes");
    }
    const nodeName = node.nodeName;
    if (isText(node)) {
        return {
            ["v"]: node.nodeValue,
            ["nn"]: componentsAlias[nodeName]._num
        };
    }
    const data = {
        ["nn"]: nodeName,
        sid: node.sid
    };
    if (node.uid !== node.sid) {
        data.uid = node.uid;
    }
    if (!node.isAnyEventBinded() && SPECIAL_NODES.indexOf(nodeName) > -1) {
        data["nn"] = `static-${nodeName}`;
        if (nodeName === VIEW && !isHasExtractProp(node)) {
            data["nn"] = PURE_VIEW;
        }
    }
    const { props  } = node;
    for(const prop in props){
        const propInCamelCase = toCamelCase(prop);
        if (!prop.startsWith("data-") && prop !== CLASS && prop !== STYLE && prop !== ID && propInCamelCase !== CATCHMOVE) {
            data[propInCamelCase] = props[prop];
        }
        if (nodeName === VIEW && propInCamelCase === CATCHMOVE && props[prop] !== false) {
            data["nn"] = CATCH_VIEW;
        }
    }
    let { childNodes  } = node;
    childNodes = childNodes.filter((node2)=>!isComment(node2));
    if (childNodes.length > 0) {
        data["cn"] = childNodes.map(hydrate);
    } else {
        data["cn"] = [];
    }
    if (node.className !== "") {
        data["cl"] = node.className;
    }
    const cssText = node.cssText;
    if (cssText !== "" && nodeName !== "swiper-item") {
        data["st"] = cssText;
    }
    hooks.call("modifyHydrateData", data);
    const nn = data["nn"];
    const componentAlias = componentsAlias[nn];
    if (componentAlias) {
        data["nn"] = componentAlias._num;
        for(const prop in data){
            if (prop in componentAlias) {
                data[componentAlias[prop]] = data[prop];
                delete data[prop];
            }
        }
    }
    return data;
}
var TaroEventTarget = class {
    addEventListener(type, handler, options2) {
        type = type.toLowerCase();
        hooks.call("onAddEvent", type, handler, options2, this);
        if (type === "regionchange") {
            this.addEventListener("begin", handler, options2);
            this.addEventListener("end", handler, options2);
            return;
        }
        let isCapture = Boolean(options2);
        let isOnce = false;
        if (isObject(options2)) {
            isCapture = Boolean(options2.capture);
            isOnce = Boolean(options2.once);
        }
        if (isOnce) {
            const wrapper = function() {
                handler.apply(this, arguments);
                this.removeEventListener(type, wrapper);
            };
            this.addEventListener(type, wrapper, Object.assign(Object.assign({}, options2), {
                once: false
            }));
            return;
        }
        warn(isCapture, "Taro \u6682\u672A\u5B9E\u73B0 event \u7684 capture \u7279\u6027\u3002");
        const oldHandler = handler;
        handler = function() {
            return oldHandler.apply(this, arguments);
        };
        handler.oldHandler = oldHandler;
        const handlers = this.__handlers[type];
        if (isArray(handlers)) {
            handlers.push(handler);
        } else {
            this.__handlers[type] = [
                handler
            ];
        }
    }
    removeEventListener(type, handler) {
        type = type.toLowerCase();
        if (type === "regionchange") {
            this.removeEventListener("begin", handler);
            this.removeEventListener("end", handler);
            return;
        }
        if (!handler) {
            return;
        }
        const handlers = this.__handlers[type];
        if (!isArray(handlers)) {
            return;
        }
        const index = handlers.findIndex((item)=>{
            if (item === handler || item.oldHandler === handler) return true;
        });
        warn(index === -1, `\u4E8B\u4EF6: '${type}' \u6CA1\u6709\u6CE8\u518C\u5728 DOM \u4E2D\uFF0C\u56E0\u6B64\u4E0D\u4F1A\u88AB\u79FB\u9664\u3002`);
        handlers.splice(index, 1);
    }
    isAnyEventBinded() {
        const handlers = this.__handlers;
        const isAnyEventBinded = Object.keys(handlers).find((key)=>handlers[key].length);
        return Boolean(isAnyEventBinded);
    }
    constructor(){
        this.__handlers = {};
    }
};
var CHILDNODES = "cn";
var nodeId = incrementId();
var TaroNode = class extends TaroEventTarget {
    updateChildNodes(isClean) {
        const cleanChildNodes = ()=>[];
        const rerenderChildNodes = ()=>{
            const childNodes = this.childNodes.filter((node)=>!isComment(node));
            return childNodes.map(hydrate);
        };
        this.enqueueUpdate({
            path: `${this._path}.${CHILDNODES}`,
            value: isClean ? cleanChildNodes : rerenderChildNodes
        });
    }
    get _root() {
        var _a;
        return ((_a = this.parentNode) === null || _a === void 0 ? void 0 : _a._root) || null;
    }
    findIndex(refChild) {
        const index = this.childNodes.indexOf(refChild);
        ensure(index !== -1, "The node to be replaced is not a child of this node.");
        return index;
    }
    get _path() {
        const parentNode = this.parentNode;
        if (parentNode) {
            const list = parentNode.childNodes.filter((node)=>!isComment(node));
            const indexOfNode = list.indexOf(this);
            const index = hooks.call("getPathIndex", indexOfNode);
            return `${parentNode._path}.${CHILDNODES}.${index}`;
        }
        return "";
    }
    get nextSibling() {
        const parentNode = this.parentNode;
        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) + 1]) || null;
    }
    get previousSibling() {
        const parentNode = this.parentNode;
        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) - 1]) || null;
    }
    get parentElement() {
        const parentNode = this.parentNode;
        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 1) {
            return parentNode;
        }
        return null;
    }
    get firstChild() {
        return this.childNodes[0] || null;
    }
    get lastChild() {
        const childNodes = this.childNodes;
        return childNodes[childNodes.length - 1] || null;
    }
    set textContent(text) {
        const removedNodes = this.childNodes.slice();
        const addedNodes = [];
        while(this.firstChild){
            this.removeChild(this.firstChild, {
                doUpdate: false
            });
        }
        if (text === "") {
            this.updateChildNodes(true);
        } else {
            const newText = env.document.createTextNode(text);
            addedNodes.push(newText);
            this.appendChild(newText);
            this.updateChildNodes();
        }
        MutationObserver.record({
            type: "childList",
            target: this,
            removedNodes,
            addedNodes
        });
    }
    insertBefore(newChild, refChild, isReplace) {
        if (newChild.nodeName === DOCUMENT_FRAGMENT) {
            newChild.childNodes.reduceRight((previousValue, currentValue)=>{
                this.insertBefore(currentValue, previousValue);
                return currentValue;
            }, refChild);
            return newChild;
        }
        newChild.remove({
            cleanRef: false
        });
        newChild.parentNode = this;
        if (refChild) {
            const index = this.findIndex(refChild);
            this.childNodes.splice(index, 0, newChild);
        } else {
            this.childNodes.push(newChild);
        }
        if (this._root) {
            if (!refChild) {
                const isOnlyChild = this.childNodes.length === 1;
                if (isOnlyChild) {
                    this.updateChildNodes();
                } else {
                    this.enqueueUpdate({
                        path: newChild._path,
                        value: this.hydrate(newChild)
                    });
                }
            } else if (isReplace) {
                this.enqueueUpdate({
                    path: newChild._path,
                    value: this.hydrate(newChild)
                });
            } else {
                this.updateChildNodes();
            }
        }
        MutationObserver.record({
            type: "childList",
            target: this,
            addedNodes: [
                newChild
            ],
            removedNodes: isReplace ? [
                refChild
            ] : [],
            nextSibling: isReplace ? refChild.nextSibling : refChild || null,
            previousSibling: newChild.previousSibling
        });
        return newChild;
    }
    appendChild(newChild) {
        return this.insertBefore(newChild);
    }
    replaceChild(newChild, oldChild) {
        if (oldChild.parentNode !== this) return;
        this.insertBefore(newChild, oldChild, true);
        oldChild.remove({
            doUpdate: false
        });
        return oldChild;
    }
    removeChild(child, options2 = {}) {
        const { cleanRef , doUpdate  } = options2;
        if (cleanRef !== false && doUpdate !== false) {
            MutationObserver.record({
                type: "childList",
                target: this,
                removedNodes: [
                    child
                ],
                nextSibling: child.nextSibling,
                previousSibling: child.previousSibling
            });
        }
        const index = this.findIndex(child);
        this.childNodes.splice(index, 1);
        child.parentNode = null;
        if (cleanRef !== false) {
            eventSource.removeNodeTree(child);
        }
        if (this._root && doUpdate !== false) {
            this.updateChildNodes();
        }
        return child;
    }
    remove(options2) {
        var _a;
        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this, options2);
    }
    hasChildNodes() {
        return this.childNodes.length > 0;
    }
    enqueueUpdate(payload) {
        var _a;
        (_a = this._root) === null || _a === void 0 ? void 0 : _a.enqueueUpdate(payload);
    }
    get ownerDocument() {
        return env.document;
    }
    static extend(methodName, options2) {
        extend(TaroNode, methodName, options2);
    }
    constructor(){
        super();
        this.parentNode = null;
        this.childNodes = [];
        this.hydrate = (node)=>()=>hydrate(node);
        this.uid = "_" + nodeId();
        this.sid = this.uid;
        eventSource.set(this.sid, this);
    }
};
var WEBKIT = "webkit";
var styleProperties = [
    "all",
    "appearance",
    "blockOverflow",
    "blockSize",
    "bottom",
    "clear",
    "contain",
    "content",
    "continue",
    "cursor",
    "direction",
    "display",
    "filter",
    "float",
    "gap",
    "height",
    "inset",
    "isolation",
    "left",
    "letterSpacing",
    "lightingColor",
    "markerSide",
    "mixBlendMode",
    "opacity",
    "order",
    "position",
    "quotes",
    "resize",
    "right",
    "rowGap",
    "tabSize",
    "tableLayout",
    "top",
    "userSelect",
    "verticalAlign",
    "visibility",
    "voiceFamily",
    "volume",
    "whiteSpace",
    "widows",
    "width",
    "zIndex",
    "pointerEvents"
];
function combine(prefix, list, excludeSelf) {
    !excludeSelf && styleProperties.push(prefix);
    list.forEach((item)=>{
        styleProperties.push(prefix + item);
        if (prefix === WEBKIT) {
            styleProperties.push("Webkit" + item);
        }
    });
}
var color = "Color";
var style = "Style";
var width = "Width";
var image = "Image";
var size = "Size";
var color_style_width = [
    color,
    style,
    width
];
var fitlength_fitwidth_image = [
    "FitLength",
    "FitWidth",
    image
];
var fitlength_fitwidth_image_radius = [
    ...fitlength_fitwidth_image,
    "Radius"
];
var color_style_width_fitlength_fitwidth_image = [
    ...color_style_width,
    ...fitlength_fitwidth_image
];
var endRadius_startRadius = [
    "EndRadius",
    "StartRadius"
];
var bottom_left_right_top = [
    "Bottom",
    "Left",
    "Right",
    "Top"
];
var end_start = [
    "End",
    "Start"
];
var content_items_self = [
    "Content",
    "Items",
    "Self"
];
var blockSize_height_inlineSize_width = [
    "BlockSize",
    "Height",
    "InlineSize",
    width
];
var after_before = [
    "After",
    "Before"
];
combine("borderBlock", color_style_width);
combine("borderBlockEnd", color_style_width);
combine("borderBlockStart", color_style_width);
combine("outline", [
    ...color_style_width,
    "Offset"
]);
combine("border", [
    ...color_style_width,
    "Boundary",
    "Break",
    "Collapse",
    "Radius",
    "Spacing"
]);
combine("borderFit", [
    "Length",
    width
]);
combine("borderInline", color_style_width);
combine("borderInlineEnd", color_style_width);
combine("borderInlineStart", color_style_width);
combine("borderLeft", color_style_width_fitlength_fitwidth_image);
combine("borderRight", color_style_width_fitlength_fitwidth_image);
combine("borderTop", color_style_width_fitlength_fitwidth_image);
combine("borderBottom", color_style_width_fitlength_fitwidth_image);
combine("textDecoration", [
    color,
    style,
    "Line"
]);
combine("textEmphasis", [
    color,
    style,
    "Position"
]);
combine("scrollMargin", bottom_left_right_top);
combine("scrollPadding", bottom_left_right_top);
combine("padding", bottom_left_right_top);
combine("margin", [
    ...bottom_left_right_top,
    "Trim"
]);
combine("scrollMarginBlock", end_start);
combine("scrollMarginInline", end_start);
combine("scrollPaddingBlock", end_start);
combine("scrollPaddingInline", end_start);
combine("gridColumn", end_start);
combine("gridRow", end_start);
combine("insetBlock", end_start);
combine("insetInline", end_start);
combine("marginBlock", end_start);
combine("marginInline", end_start);
combine("paddingBlock", end_start);
combine("paddingInline", end_start);
combine("pause", after_before);
combine("cue", after_before);
combine("mask", [
    "Clip",
    "Composite",
    image,
    "Mode",
    "Origin",
    "Position",
    "Repeat",
    size,
    "Type"
]);
combine("borderImage", [
    "Outset",
    "Repeat",
    "Slice",
    "Source",
    "Transform",
    width
]);
combine("maskBorder", [
    "Mode",
    "Outset",
    "Repeat",
    "Slice",
    "Source",
    width
]);
combine("font", [
    "Family",
    "FeatureSettings",
    "Kerning",
    "LanguageOverride",
    "MaxSize",
    "MinSize",
    "OpticalSizing",
    "Palette",
    size,
    "SizeAdjust",
    "Stretch",
    style,
    "Weight",
    "VariationSettings"
]);
combine("transform", [
    "Box",
    "Origin",
    style
]);
combine("background", [
    color,
    image,
    "Attachment",
    "BlendMode",
    "Clip",
    "Origin",
    "Position",
    "Repeat",
    size
]);
combine("listStyle", [
    image,
    "Position",
    "Type"
]);
combine("scrollSnap", [
    "Align",
    "Stop",
    "Type"
]);
combine("grid", [
    "Area",
    "AutoColumns",
    "AutoFlow",
    "AutoRows"
]);
combine("gridTemplate", [
    "Areas",
    "Columns",
    "Rows"
]);
combine("overflow", [
    "Block",
    "Inline",
    "Wrap",
    "X",
    "Y"
]);
combine("transition", [
    "Delay",
    "Duration",
    "Property",
    "TimingFunction"
]);
combine("color", [
    "Adjust",
    "InterpolationFilters",
    "Scheme"
]);
combine("textAlign", [
    "All",
    "Last"
]);
combine("page", [
    "BreakAfter",
    "BreakBefore",
    "BreakInside"
]);
combine("animation", [
    "Delay",
    "Direction",
    "Duration",
    "FillMode",
    "IterationCount",
    "Name",
    "PlayState",
    "TimingFunction"
]);
combine("flex", [
    "Basis",
    "Direction",
    "Flow",
    "Grow",
    "Shrink",
    "Wrap"
]);
combine("offset", [
    ...after_before,
    ...end_start,
    "Anchor",
    "Distance",
    "Path",
    "Position",
    "Rotate"
]);
combine("perspective", [
    "Origin"
]);
combine("clip", [
    "Path",
    "Rule"
]);
combine("flow", [
    "From",
    "Into"
]);
combine("align", [
    "Content",
    "Items",
    "Self"
], true);
combine("alignment", [
    "Adjust",
    "Baseline"
], true);
combine("borderStart", endRadius_startRadius, true);
combine("borderEnd", endRadius_startRadius, true);
combine("borderCorner", [
    "Fit",
    image,
    "ImageTransform"
], true);
combine("borderTopLeft", fitlength_fitwidth_image_radius, true);
combine("borderTopRight", fitlength_fitwidth_image_radius, true);
combine("borderBottomLeft", fitlength_fitwidth_image_radius, true);
combine("borderBottomRight", fitlength_fitwidth_image_radius, true);
combine("column", [
    "s",
    "Count",
    "Fill",
    "Gap",
    "Rule",
    "RuleColor",
    "RuleStyle",
    "RuleWidth",
    "Span",
    width
], true);
combine("break", [
    ...after_before,
    "Inside"
], true);
combine("wrap", [
    ...after_before,
    "Flow",
    "Inside",
    "Through"
], true);
combine("justify", content_items_self, true);
combine("place", content_items_self, true);
combine("max", [
    ...blockSize_height_inlineSize_width,
    "Lines"
], true);
combine("min", blockSize_height_inlineSize_width, true);
combine("line", [
    "Break",
    "Clamp",
    "Grid",
    "Height",
    "Padding",
    "Snap"
], true);
combine("inline", [
    "BoxAlign",
    size,
    "Sizing"
], true);
combine("text", [
    "CombineUpright",
    "GroupAlign",
    "Height",
    "Indent",
    "Justify",
    "Orientation",
    "Overflow",
    "Shadow",
    "SpaceCollapse",
    "SpaceTrim",
    "Spacing",
    "Transform",
    "UnderlinePosition",
    "Wrap"
], true);
combine("shape", [
    "ImageThreshold",
    "Inside",
    "Margin",
    "Outside"
], true);
combine("word", [
    "Break",
    "Spacing",
    "Wrap"
], true);
combine("object", [
    "Fit",
    "Position"
], true);
combine("box", [
    "DecorationBreak",
    "Shadow",
    "Sizing",
    "Snap"
], true);
combine(WEBKIT, [
    "LineClamp",
    "BoxOrient",
    "TextFillColor",
    "TextStroke",
    "TextStrokeColor",
    "TextStrokeWidth"
], true);
function recordCss(obj) {
    MutationObserver.record({
        type: "attributes",
        target: obj._element,
        attributeName: "style",
        oldValue: obj.cssText
    });
}
function enqueueUpdate(obj) {
    const element = obj._element;
    if (element._root) {
        element.enqueueUpdate({
            path: `${element._path}.${"st"}`,
            value: obj.cssText
        });
    }
}
function setStyle(newVal, styleKey) {
    warn(isString(newVal) && newVal.length > PROPERTY_THRESHOLD, `Style \u5C5E\u6027 ${styleKey} \u7684\u503C\u6570\u636E\u91CF\u8FC7\u5927\uFF0C\u53EF\u80FD\u4F1A\u5F71\u54CD\u6E32\u67D3\u6027\u80FD\uFF0C\u8003\u8651\u4F7F\u7528 CSS \u7C7B\u6216\u5176\u5B83\u65B9\u6848\u66FF\u4EE3\u3002`);
    const old = this[styleKey];
    if (old === newVal) return;
    !this._pending && recordCss(this);
    if (isNull(newVal) || isUndefined(newVal)) {
        this._usedStyleProp.delete(styleKey);
        delete this._value[styleKey];
    } else {
        this._usedStyleProp.add(styleKey);
        this._value[styleKey] = newVal;
    }
    !this._pending && enqueueUpdate(this);
}
function initStyle(ctor) {
    const properties = {};
    for(let i = 0; i < styleProperties.length; i++){
        const styleKey = styleProperties[i];
        properties[styleKey] = {
            get () {
                const val = this._value[styleKey];
                return isNull(val) || isUndefined(val) ? "" : val;
            },
            set (newVal) {
                setStyle.call(this, newVal, styleKey);
            }
        };
    }
    Object.defineProperties(ctor.prototype, properties);
}
function isCssVariable(propertyName) {
    return /^--/.test(propertyName);
}
var Style = class {
    setCssVariables(styleKey) {
        this.hasOwnProperty(styleKey) || Object.defineProperty(this, styleKey, {
            enumerable: true,
            configurable: true,
            get: ()=>{
                return this._value[styleKey] || "";
            },
            set: (newVal)=>{
                setStyle.call(this, newVal, styleKey);
            }
        });
    }
    get cssText() {
        if (!this._usedStyleProp.size) return "";
        const texts = [];
        this._usedStyleProp.forEach((key)=>{
            const val = this[key];
            if (isNull(val) || isUndefined(val)) return;
            let styleName = isCssVariable(key) ? key : toDashed(key);
            if (styleName.indexOf("webkit") === 0 || styleName.indexOf("Webkit") === 0) {
                styleName = `-${styleName}`;
            }
            texts.push(`${styleName}: ${val};`);
        });
        return texts.join(" ");
    }
    set cssText(str) {
        this._pending = true;
        recordCss(this);
        this._usedStyleProp.forEach((prop)=>{
            this.removeProperty(prop);
        });
        if (str === "" || isUndefined(str) || isNull(str)) {
            this._pending = false;
            enqueueUpdate(this);
            return;
        }
        const rules = str.split(";");
        for(let i = 0; i < rules.length; i++){
            const rule = rules[i].trim();
            if (rule === "") {
                continue;
            }
            const [propName, ...valList] = rule.split(":");
            const val = valList.join(":");
            if (isUndefined(val)) {
                continue;
            }
            this.setProperty(propName.trim(), val.trim());
        }
        this._pending = false;
        enqueueUpdate(this);
    }
    setProperty(propertyName, value) {
        if (propertyName[0] === "-") {
            this.setCssVariables(propertyName);
        } else {
            propertyName = toCamelCase(propertyName);
        }
        if (isNull(value) || isUndefined(value)) {
            this.removeProperty(propertyName);
        } else {
            this[propertyName] = value;
        }
    }
    removeProperty(propertyName) {
        propertyName = toCamelCase(propertyName);
        if (!this._usedStyleProp.has(propertyName)) {
            return "";
        }
        const value = this[propertyName];
        this[propertyName] = void 0;
        return value;
    }
    getPropertyValue(propertyName) {
        propertyName = toCamelCase(propertyName);
        const value = this[propertyName];
        if (!value) {
            return "";
        }
        return value;
    }
    constructor(element){
        this._element = element;
        this._usedStyleProp = /* @__PURE__ */ new Set();
        this._value = {};
    }
};
initStyle(Style);
function returnTrue() {
    return true;
}
function treeToArray(root, predict) {
    const array = [];
    const filter = predict !== null && predict !== void 0 ? predict : returnTrue;
    let object = root;
    while(object){
        if (object.nodeType === 1 && filter(object)) {
            array.push(object);
        }
        object = following(object, root);
    }
    return array;
}
function following(el, root) {
    const firstChild = el.firstChild;
    if (firstChild) {
        return firstChild;
    }
    let current = el;
    do {
        if (current === root) {
            return null;
        }
        const nextSibling = current.nextSibling;
        if (nextSibling) {
            return nextSibling;
        }
        current = current.parentElement;
    }while (current)
    return null;
}
var TaroElement = class extends TaroNode {
    _stopPropagation(event) {
        let target = this;
        while(target = target.parentNode){
            const listeners = target.__handlers[event.type];
            if (!isArray(listeners)) {
                continue;
            }
            for(let i = listeners.length; i--;){
                const l = listeners[i];
                l._stop = true;
            }
        }
    }
    get id() {
        return this.getAttribute(ID);
    }
    set id(val) {
        this.setAttribute(ID, val);
    }
    get className() {
        return this.getAttribute(CLASS) || "";
    }
    set className(val) {
        this.setAttribute(CLASS, val);
    }
    get cssText() {
        return this.getAttribute(STYLE) || "";
    }
    get classList() {
        return new ClassList(this.className, this);
    }
    get children() {
        return this.childNodes.filter(isElement);
    }
    get attributes() {
        const props = this.props;
        const propKeys = Object.keys(props);
        const style2 = this.style.cssText;
        const attrs = propKeys.map((key)=>({
                name: key,
                value: props[key]
            }));
        return attrs.concat(style2 ? {
            name: STYLE,
            value: style2
        } : []);
    }
    get textContent() {
        let text = "";
        const childNodes = this.childNodes;
        for(let i = 0; i < childNodes.length; i++){
            text += childNodes[i].textContent;
        }
        return text;
    }
    set textContent(text) {
        super.textContent = text;
    }
    hasAttribute(qualifiedName) {
        return !isUndefined(this.props[qualifiedName]);
    }
    hasAttributes() {
        return this.attributes.length > 0;
    }
    get focus() {
        return function() {
            this.setAttribute(FOCUS, true);
        };
    }
    set focus(value) {
        this.setAttribute(FOCUS, value);
    }
    blur() {
        this.setAttribute(FOCUS, false);
    }
    setAttribute(qualifiedName, value) {
        warn(isString(value) && value.length > PROPERTY_THRESHOLD, `\u5143\u7D20 ${this.nodeName} \u7684 ${qualifiedName} \u5C5E\u6027\u503C\u6570\u636E\u91CF\u8FC7\u5927\uFF0C\u53EF\u80FD\u4F1A\u5F71\u54CD\u6E32\u67D3\u6027\u80FD\u3002\u8003\u8651\u964D\u4F4E\u56FE\u7247\u8F6C\u4E3A base64 \u7684\u9608\u503C\u6216\u5728 CSS \u4E2D\u4F7F\u7528 base64\u3002`);
        const isPureView = this.nodeName === VIEW && !isHasExtractProp(this) && !this.isAnyEventBinded();
        if (qualifiedName !== STYLE) {
            MutationObserver.record({
                target: this,
                type: "attributes",
                attributeName: qualifiedName,
                oldValue: this.getAttribute(qualifiedName)
            });
        }
        switch(qualifiedName){
            case STYLE:
                this.style.cssText = value;
                break;
            case ID:
                if (this.uid !== this.sid) {
                    eventSource.delete(this.uid);
                }
                value = String(value);
                this.props[qualifiedName] = this.uid = value;
                eventSource.set(value, this);
                break;
            default:
                this.props[qualifiedName] = value;
                if (qualifiedName.startsWith("data-")) {
                    if (this.dataset === EMPTY_OBJ) {
                        this.dataset = /* @__PURE__ */ Object.create(null);
                    }
                    this.dataset[toCamelCase(qualifiedName.replace(/^data-/, ""))] = value;
                }
                break;
        }
        if (!this._root) return;
        const componentsAlias2 = getComponentsAlias2();
        const _alias = componentsAlias2[this.nodeName];
        const viewAlias = componentsAlias2[VIEW]._num;
        const staticViewAlias = componentsAlias2[STATIC_VIEW]._num;
        const catchViewAlias = componentsAlias2[CATCH_VIEW]._num;
        const _path = this._path;
        qualifiedName = shortcutAttr(qualifiedName);
        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);
        const payload = {
            path: `${_path}.${qualifiedNameInCamelCase}`,
            value: isFunction(value) ? ()=>value : value
        };
        hooks.call("modifySetAttrPayload", this, qualifiedName, payload, componentsAlias2);
        if (_alias) {
            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;
            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;
        }
        this.enqueueUpdate(payload);
        if (this.nodeName === VIEW) {
            if (qualifiedNameInCamelCase === CATCHMOVE) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: value ? catchViewAlias : this.isAnyEventBinded() ? viewAlias : staticViewAlias
                });
            } else if (isPureView && isHasExtractProp(this)) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: staticViewAlias
                });
            }
        }
    }
    removeAttribute(qualifiedName) {
        const isStaticView = this.nodeName === VIEW && isHasExtractProp(this) && !this.isAnyEventBinded();
        MutationObserver.record({
            target: this,
            type: "attributes",
            attributeName: qualifiedName,
            oldValue: this.getAttribute(qualifiedName)
        });
        if (qualifiedName === STYLE) {
            this.style.cssText = "";
        } else {
            const isInterrupt = hooks.call("onRemoveAttribute", this, qualifiedName);
            if (isInterrupt) {
                return;
            }
            if (!this.props.hasOwnProperty(qualifiedName)) {
                return;
            }
            delete this.props[qualifiedName];
        }
        if (!this._root) return;
        const componentsAlias2 = getComponentsAlias2();
        const _alias = componentsAlias2[this.nodeName];
        const viewAlias = componentsAlias2[VIEW]._num;
        const staticViewAlias = componentsAlias2[STATIC_VIEW]._num;
        const pureViewAlias = componentsAlias2[PURE_VIEW]._num;
        const _path = this._path;
        qualifiedName = shortcutAttr(qualifiedName);
        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);
        const payload = {
            path: `${_path}.${qualifiedNameInCamelCase}`,
            value: ""
        };
        hooks.call("modifyRmAttrPayload", this, qualifiedName, payload, componentsAlias2);
        if (_alias) {
            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;
            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;
        }
        this.enqueueUpdate(payload);
        if (this.nodeName === VIEW) {
            if (qualifiedNameInCamelCase === CATCHMOVE) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: this.isAnyEventBinded() ? viewAlias : isHasExtractProp(this) ? staticViewAlias : pureViewAlias
                });
            } else if (isStaticView && !isHasExtractProp(this)) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: pureViewAlias
                });
            }
        }
    }
    getAttribute(qualifiedName) {
        const attr = qualifiedName === STYLE ? this.style.cssText : this.props[qualifiedName];
        return attr !== null && attr !== void 0 ? attr : "";
    }
    getElementsByTagName(tagName) {
        return treeToArray(this, (el)=>{
            return el.nodeName === tagName || tagName === "*" && this !== el;
        });
    }
    getElementsByClassName(className) {
        return treeToArray(this, (el)=>{
            const classList = el.classList;
            const classNames = className.trim().split(/\s+/);
            return classNames.every((c)=>classList.has(c));
        });
    }
    dispatchEvent(event) {
        const cancelable = event.cancelable;
        const listeners = this.__handlers[event.type];
        if (!isArray(listeners)) {
            return false;
        }
        for(let i = listeners.length; i--;){
            const listener = listeners[i];
            let result;
            if (listener._stop) {
                listener._stop = false;
            } else {
                hooks.call("modifyDispatchEvent", event, this);
                result = listener.call(this, event);
            }
            if ((result === false || event._end) && cancelable) {
                event.defaultPrevented = true;
            }
            if (!isUndefined(result) && event.mpEvent) {
                event.mpEvent[EVENT_CALLBACK_RESULT] = result;
            }
            if (event._end && event._stop) {
                break;
            }
        }
        if (event._stop) {
            this._stopPropagation(event);
        } else {
            event._stop = true;
        }
        return listeners != null;
    }
    addEventListener(type, handler, options2) {
        const name = this.nodeName;
        const SPECIAL_NODES2 = hooks.call("getSpecialNodes");
        let sideEffect = true;
        if (isObject(options2) && options2.sideEffect === false) {
            sideEffect = false;
            delete options2.sideEffect;
        }
        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES2.indexOf(name) > -1) {
            const componentsAlias2 = getComponentsAlias2();
            const alias = componentsAlias2[name]._num;
            this.enqueueUpdate({
                path: `${this._path}.${"nn"}`,
                value: alias
            });
        }
        super.addEventListener(type, handler, options2);
    }
    removeEventListener(type, handler, sideEffect = true) {
        super.removeEventListener(type, handler);
        const name = this.nodeName;
        const SPECIAL_NODES2 = hooks.call("getSpecialNodes");
        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES2.indexOf(name) > -1) {
            const componentsAlias2 = getComponentsAlias2();
            const value = isHasExtractProp(this) ? `static-${name}` : `pure-${name}`;
            const valueAlias = componentsAlias2[value]._num;
            this.enqueueUpdate({
                path: `${this._path}.${"nn"}`,
                value: valueAlias
            });
        }
    }
    static extend(methodName, options2) {
        extend(TaroElement, methodName, options2);
    }
    constructor(){
        super();
        this.props = {};
        this.dataset = EMPTY_OBJ;
        this.nodeType = 1;
        this.style = new Style(this);
        hooks.call("patchElement", this);
    }
};
var options = {
    prerender: true,
    debug: false
};
function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for(let i = 0; i < list.length; i++){
        map[list[i]] = true;
    }
    return expectsLowerCase ? (val)=>!!map[val.toLowerCase()] : (val)=>!!map[val];
}
var internalCompsList = Object.keys(internalComponents).map((i)=>i.toLowerCase()).join(",");
var isMiniElements = makeMap(internalCompsList, true);
var isInlineElements = makeMap("a,i,abbr,iframe,select,acronym,slot,small,span,bdi,kbd,strong,big,map,sub,sup,br,mark,mark,meter,template,canvas,textarea,cite,object,time,code,output,u,data,picture,tt,datalist,var,dfn,del,q,em,s,embed,samp,b", true);
var isBlockElements = makeMap("address,fieldset,li,article,figcaption,main,aside,figure,nav,blockquote,footer,ol,details,form,p,dialog,h1,h2,h3,h4,h5,h6,pre,dd,header,section,div,hgroup,table,dl,hr,ul,dt", true);
options.html = {
    skipElements: /* @__PURE__ */ new Set([
        "style",
        "script"
    ]),
    voidElements: /* @__PURE__ */ new Set([
        "!doctype",
        "area",
        "base",
        "br",
        "col",
        "command",
        "embed",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
    ]),
    closingElements: /* @__PURE__ */ new Set([
        "html",
        "head",
        "body",
        "p",
        "dt",
        "dd",
        "li",
        "option",
        "thead",
        "th",
        "tbody",
        "tr",
        "td",
        "tfoot",
        "colgroup"
    ]),
    renderHTMLTag: false
};
if (false) {
    if (ENABLE_INNER_HTML) {
        TaroNode.extend("innerHTML", {
            set (html) {
                setInnerHTML.call(this, this, html);
            },
            get () {
                return "";
            }
        });
        if (ENABLE_ADJACENT_HTML) {
            TaroNode.extend("insertAdjacentHTML", insertAdjacentHTML);
        }
    }
    if (ENABLE_CLONE_NODE) {
        TaroNode.extend("cloneNode", cloneNode);
    }
    if (ENABLE_CONTAINS) {
        TaroNode.extend("contains", contains);
    }
    if (ENABLE_SIZE_APIS) {
        TaroElement.extend("getBoundingClientRect", getBoundingClientRectImpl);
    }
    if (ENABLE_TEMPLATE_CONTENT) {
        TaroElement.extend("content", {
            get () {
                return getTemplateContent(this);
            }
        });
    }
}
var TaroEvent = class {
    stopPropagation() {
        this._stop = true;
    }
    stopImmediatePropagation() {
        this._end = this._stop = true;
    }
    preventDefault() {
        this.defaultPrevented = true;
    }
    get target() {
        var _a, _b;
        const cacheTarget = this.cacheTarget;
        if (!cacheTarget) {
            const target = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.target) || null);
            const element = env.document.getElementById(target.id);
            target.dataset = element !== null ? element.dataset : EMPTY_OBJ;
            for(const key in (_b = this.mpEvent) === null || _b === void 0 ? void 0 : _b.detail){
                target[key] = this.mpEvent.detail[key];
            }
            this.cacheTarget = target;
            return target;
        } else {
            return cacheTarget;
        }
    }
    get currentTarget() {
        var _a, _b, _c, _d;
        const cacheCurrentTarget = this.cacheCurrentTarget;
        if (!cacheCurrentTarget) {
            const doc = env.document;
            const currentTarget = Object.create(((_a = this.mpEvent) === null || _a === void 0 ? void 0 : _a.currentTarget) || null);
            const element = doc.getElementById(currentTarget.id);
            const targetElement = doc.getElementById(((_c = (_b = this.mpEvent) === null || _b === void 0 ? void 0 : _b.target) === null || _c === void 0 ? void 0 : _c.id) || null);
            if (element === null || element && element === targetElement) {
                this.cacheCurrentTarget = this.target;
                return this.target;
            }
            currentTarget.dataset = element.dataset;
            for(const key in (_d = this.mpEvent) === null || _d === void 0 ? void 0 : _d.detail){
                currentTarget[key] = this.mpEvent.detail[key];
            }
            this.cacheCurrentTarget = currentTarget;
            return currentTarget;
        } else {
            return cacheCurrentTarget;
        }
    }
    constructor(type, opts, event){
        this._stop = false;
        this._end = false;
        this.defaultPrevented = false;
        this.button = 0;
        this.timeStamp = Date.now();
        this.type = type.toLowerCase();
        this.mpEvent = event;
        this.bubbles = Boolean(opts && opts.bubbles);
        this.cancelable = Boolean(opts && opts.cancelable);
    }
};
function createEvent(event, node) {
    if (typeof event === "string") {
        return new TaroEvent(event, {
            bubbles: true,
            cancelable: true
        });
    }
    const domEv = new TaroEvent(event.type, {
        bubbles: true,
        cancelable: true
    }, event);
    for(const key in event){
        if (key === CURRENT_TARGET || key === TARGET || key === TYPE || key === TIME_STAMP) {
            continue;
        } else {
            domEv[key] = event[key];
        }
    }
    if (domEv.type === CONFIRM && (node === null || node === void 0 ? void 0 : node.nodeName) === INPUT) {
        domEv[KEY_CODE] = 13;
    }
    return domEv;
}
var eventsBatch = {};
function getEventCBResult(event) {
    const result = event[EVENT_CALLBACK_RESULT];
    if (!isUndefined(result)) {
        delete event[EVENT_CALLBACK_RESULT];
    }
    return result;
}
function eventHandler(event) {
    var _a, _b;
    !event.type && Object.defineProperty(event, "type", {
        value: event._type
    });
    !event.detail && Object.defineProperty(event, "detail", {
        value: event._detail || Object.assign({}, event)
    });
    event.currentTarget = event.currentTarget || event.target || Object.assign({}, event);
    hooks.call("modifyMpEventImpl", event);
    const currentTarget = event.currentTarget;
    const id = ((_a = currentTarget.dataset) === null || _a === void 0 ? void 0 : _a.sid) || currentTarget.id || ((_b = event.detail) === null || _b === void 0 ? void 0 : _b.id) || "";
    const node = env.document.getElementById(id);
    if (node) {
        const dispatch = ()=>{
            const e = createEvent(event, node);
            hooks.call("modifyTaroEvent", e, node);
            node.dispatchEvent(e);
        };
        if (hooks.isExist("batchedEventUpdates")) {
            const type = event.type;
            if (!hooks.call("isBubbleEvents", type) || !isParentBinded(node, type) || type === TOUCHMOVE && !!node.props.catchMove) {
                hooks.call("batchedEventUpdates", ()=>{
                    if (eventsBatch[type]) {
                        eventsBatch[type].forEach((fn)=>fn());
                        delete eventsBatch[type];
                    }
                    dispatch();
                });
                return getEventCBResult(event);
            } else {
                (eventsBatch[type] || (eventsBatch[type] = [])).push(dispatch);
            }
        } else {
            dispatch();
            return getEventCBResult(event);
        }
    }
}
var FormElement = class extends TaroElement {
    get value() {
        const val = this.props[VALUE];
        return val == null ? "" : val;
    }
    set value(val) {
        this.setAttribute(VALUE, val);
    }
    dispatchEvent(event) {
        if (event.mpEvent) {
            const val = event.mpEvent.detail.value;
            if (event.type === CHANGE) {
                this.props.value = val;
            } else if (event.type === INPUT) {
                this.value = val;
            }
        }
        return super.dispatchEvent(event);
    }
};
var Performance = class {
    start(id) {
        if (!options.debug) {
            return;
        }
        this.recorder.set(id, Date.now());
    }
    stop(id) {
        if (!options.debug) {
            return;
        }
        const now2 = Date.now();
        const prev = this.recorder.get(id);
        this.recorder.delete(id);
        const time = now2 - prev;
        console.log(`${id} \u65F6\u957F\uFF1A ${time}ms`);
    }
    constructor(){
        this.recorder = /* @__PURE__ */ new Map();
    }
};
var perf = new Performance();
function findCustomWrapper(root, dataPathArr) {
    const list = dataPathArr.slice(1);
    let currentData = root;
    let customWrapper;
    let splitedPath = "";
    list.some((item, i)=>{
        const key = item.replace(/^\[(.+)\]$/, "$1").replace(/\bcn\b/g, "childNodes");
        currentData = currentData[key];
        if (isUndefined(currentData)) return true;
        if (currentData.nodeName === CUSTOM_WRAPPER) {
            const res = customWrapperCache.get(currentData.sid);
            if (res) {
                customWrapper = res;
                splitedPath = dataPathArr.slice(i + 2).join(".");
            }
        }
    });
    if (customWrapper) {
        return {
            customWrapper,
            splitedPath
        };
    }
}
var TaroRootElement = class extends TaroElement {
    get _path() {
        return ROOT_STR;
    }
    get _root() {
        return this;
    }
    enqueueUpdate(payload) {
        this.updatePayloads.push(payload);
        if (!this.pendingUpdate && this.ctx) {
            this.performUpdate();
        }
    }
    performUpdate(initRender = false, prerender) {
        this.pendingUpdate = true;
        const ctx = this.ctx;
        setTimeout(()=>{
            const setDataMark = `${SET_DATA} \u5F00\u59CB\u65F6\u95F4\u6233 ${Date.now()}`;
            perf.start(setDataMark);
            const data = /* @__PURE__ */ Object.create(null);
            const resetPaths = new Set(initRender ? [
                "root.cn.[0]",
                "root.cn[0]"
            ] : []);
            while(this.updatePayloads.length > 0){
                const { path , value  } = this.updatePayloads.shift();
                if (path.endsWith("cn")) {
                    resetPaths.add(path);
                }
                data[path] = value;
            }
            for(const path in data){
                resetPaths.forEach((p)=>{
                    if (path.includes(p) && path !== p) {
                        delete data[path];
                    }
                });
                const value = data[path];
                if (isFunction(value)) {
                    data[path] = value();
                }
            }
            if (isFunction(prerender)) return prerender(data);
            this.pendingUpdate = false;
            let normalUpdate = {};
            const customWrapperMap = /* @__PURE__ */ new Map();
            if (initRender) {
                normalUpdate = data;
            } else {
                for(const p in data){
                    const dataPathArr = p.split(".");
                    const found = findCustomWrapper(this, dataPathArr);
                    if (found) {
                        const { customWrapper , splitedPath  } = found;
                        customWrapperMap.set(customWrapper, Object.assign(Object.assign({}, customWrapperMap.get(customWrapper) || {}), {
                            [`i.${splitedPath}`]: data[p]
                        }));
                    } else {
                        normalUpdate[p] = data[p];
                    }
                }
            }
            const customWrapperCount = customWrapperMap.size;
            const isNeedNormalUpdate = Object.keys(normalUpdate).length > 0;
            const updateArrLen = customWrapperCount + (isNeedNormalUpdate ? 1 : 0);
            let executeTime = 0;
            const cb = ()=>{
                if (++executeTime === updateArrLen) {
                    perf.stop(setDataMark);
                    this.flushUpdateCallback();
                    initRender && perf.stop(PAGE_INIT);
                }
            };
            if (customWrapperCount) {
                customWrapperMap.forEach((data2, ctx2)=>{
                    if (options.debug) {
                        console.log("custom wrapper setData: ", data2);
                    }
                    ctx2.setData(data2, cb);
                });
            }
            if (isNeedNormalUpdate) {
                if (options.debug) {
                    console.log("page setData:", normalUpdate);
                }
                ctx.setData(normalUpdate, cb);
            }
        }, 0);
    }
    enqueueUpdateCallback(cb, ctx) {
        this.updateCallbacks.push(()=>{
            ctx ? cb.call(ctx) : cb();
        });
    }
    flushUpdateCallback() {
        const updateCallbacks = this.updateCallbacks;
        if (!updateCallbacks.length) return;
        const copies = updateCallbacks.slice(0);
        this.updateCallbacks.length = 0;
        for(let i = 0; i < copies.length; i++){
            copies[i]();
        }
    }
    constructor(){
        super();
        this.updatePayloads = [];
        this.updateCallbacks = [];
        this.pendingUpdate = false;
        this.ctx = null;
        this.nodeName = ROOT_STR;
        this.tagName = ROOT_STR.toUpperCase();
    }
};
var TaroText = class extends TaroNode {
    set textContent(text) {
        MutationObserver.record({
            target: this,
            type: "characterData",
            oldValue: this._value
        });
        this._value = text;
        this.enqueueUpdate({
            path: `${this._path}.${"v"}`,
            value: text
        });
    }
    get textContent() {
        return this._value;
    }
    set nodeValue(text) {
        this.textContent = text;
    }
    get nodeValue() {
        return this._value;
    }
    set data(text) {
        this.textContent = text;
    }
    get data() {
        return this._value;
    }
    constructor(value){
        super();
        this.nodeType = 3;
        this.nodeName = "#text";
        this._value = value;
    }
};
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var _URLSearchParams_dict;
var findReg = /[!'()~]|%20|%00/g;
var plusReg = /\+/g;
var replaceCharMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
};
function replacer(match) {
    return replaceCharMap[match];
}
function appendTo(dict, name, value) {
    const res = isArray(value) ? value.join(",") : value;
    if (name in dict) dict[name].push(res);
    else dict[name] = [
        res
    ];
}
function addEach(value, key) {
    appendTo(this, key, value);
}
function decode(str) {
    return decodeURIComponent(str.replace(plusReg, " "));
}
function encode(str) {
    return encodeURIComponent(str).replace(findReg, replacer);
}
var URLSearchParams = class {
    append(name, value) {
        appendTo(__classPrivateFieldGet(this, _URLSearchParams_dict, "f"), name, value);
    }
    delete(name) {
        delete __classPrivateFieldGet(this, _URLSearchParams_dict, "f")[name];
    }
    get(name) {
        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, "f");
        return name in dict ? dict[name][0] : null;
    }
    getAll(name) {
        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, "f");
        return name in dict ? dict[name].slice(0) : [];
    }
    has(name) {
        return name in __classPrivateFieldGet(this, _URLSearchParams_dict, "f");
    }
    keys() {
        return Object.keys(__classPrivateFieldGet(this, _URLSearchParams_dict, "f"));
    }
    set(name, value) {
        __classPrivateFieldGet(this, _URLSearchParams_dict, "f")[name] = [
            "" + value
        ];
    }
    forEach(callback, thisArg) {
        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, "f");
        Object.getOwnPropertyNames(dict).forEach(function(name) {
            dict[name].forEach(function(value) {
                callback.call(thisArg, value, name, this);
            }, this);
        }, this);
    }
    toJSON() {
        return {};
    }
    toString() {
        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, "f");
        const query = [];
        for(const key in dict){
            const name = encode(key);
            for(let i = 0, value = dict[key]; i < value.length; i++){
                query.push(name + "=" + encode(value[i]));
            }
        }
        return query.join("&");
    }
    constructor(query){
        _URLSearchParams_dict.set(this, /* @__PURE__ */ Object.create(null));
        if (!query) return;
        const dict = __classPrivateFieldGet(this, _URLSearchParams_dict, "f");
        if (typeof query === "string") {
            if (query.charAt(0) === "?") {
                query = query.slice(1);
            }
            for(let pairs = query.split("&"), i = 0, length = pairs.length; i < length; i++){
                const value = pairs[i];
                const index = value.indexOf("=");
                if (index > -1) {
                    appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));
                } else if (value.length) {
                    appendTo(dict, decode(value), "");
                }
            }
        } else {
            if (isArray(query)) {
                for(let i = 0, length = query.length; i < length; i++){
                    const value = query[i];
                    appendTo(dict, value[0], value[1]);
                }
            } else if (query.forEach) {
                query.forEach(addEach, dict);
            } else {
                for(const key in query){
                    appendTo(dict, key, query[key]);
                }
            }
        }
    }
};
_URLSearchParams_dict = /* @__PURE__ */ new WeakMap();
var _URL_hash;
var _URL_hostname;
var _URL_pathname;
var _URL_port;
var _URL_protocol;
var _URL_search;
var URL = class {
    static createObjectURL() {
        throw new Error("Oops, not support URL.createObjectURL() in miniprogram.");
    }
    static revokeObjectURL() {
        throw new Error("Oops, not support URL.revokeObjectURL() in miniprogram.");
    }
    get protocol() {
        return __classPrivateFieldGet(this, _URL_protocol, "f");
    }
    set protocol(val) {
        isString(val) && __classPrivateFieldSet(this, _URL_protocol, val.trim(), "f");
    }
    get host() {
        return this.hostname + (this.port ? ":" + this.port : "");
    }
    set host(val) {
        if (val && isString(val)) {
            val = val.trim();
            const { hostname , port  } = parseUrl(`//${val}`);
            this.hostname = hostname;
            this.port = port;
        }
    }
    get hostname() {
        return __classPrivateFieldGet(this, _URL_hostname, "f");
    }
    set hostname(val) {
        val && isString(val) && __classPrivateFieldSet(this, _URL_hostname, val.trim(), "f");
    }
    get port() {
        return __classPrivateFieldGet(this, _URL_port, "f");
    }
    set port(val) {
        isString(val) && __classPrivateFieldSet(this, _URL_port, val.trim(), "f");
    }
    get pathname() {
        return __classPrivateFieldGet(this, _URL_pathname, "f");
    }
    set pathname(val) {
        if (isString(val)) {
            val = val.trim();
            const HEAD_REG = /^(\/|\.\/|\.\.\/)/;
            let temp = val;
            while(HEAD_REG.test(temp)){
                temp = temp.replace(HEAD_REG, "");
            }
            if (temp) __classPrivateFieldSet(this, _URL_pathname, "/" + temp, "f");
            else __classPrivateFieldSet(this, _URL_pathname, "/", "f");
        }
    }
    get search() {
        return __classPrivateFieldGet(this, _URL_search, "f");
    }
    set search(val) {
        if (isString(val)) {
            val = val.trim();
            if (val) __classPrivateFieldSet(this, _URL_search, val.startsWith("?") ? val : `?${val}`, "f");
            else __classPrivateFieldSet(this, _URL_search, "", "f");
        }
    }
    get hash() {
        return __classPrivateFieldGet(this, _URL_hash, "f");
    }
    set hash(val) {
        if (isString(val)) {
            val = val.trim();
            if (val) __classPrivateFieldSet(this, _URL_hash, val.startsWith("#") ? val : `#${val}`, "f");
            else __classPrivateFieldSet(this, _URL_hash, "", "f");
        }
    }
    get href() {
        return `${this.protocol}//${this.host}${this.pathname}${this.search}${this.hash}`;
    }
    set href(val) {
        if (val && isString(val)) {
            val = val.trim();
            const { protocol , hostname , port , hash , search , pathname  } = parseUrl(val);
            this.protocol = protocol;
            this.hostname = hostname;
            this.pathname = pathname;
            this.port = port;
            this.hash = hash;
            this.search = search;
        }
    }
    get origin() {
        return `${this.protocol}//${this.host}`;
    }
    set origin(val) {
        if (val && isString(val)) {
            val = val.trim();
            const { protocol , hostname , port  } = parseUrl(val);
            this.protocol = protocol;
            this.hostname = hostname;
            this.port = port;
        }
    }
    get searchParams() {
        return new URLSearchParams(this.search);
    }
    toString() {
        return this.href;
    }
    toJSON() {
        return this.toString();
    }
    _toRaw() {
        return {
            protocol: this.protocol,
            port: this.port,
            host: this.host,
            hostname: this.hostname,
            pathname: this.pathname,
            hash: this.hash,
            search: this.search,
            origin: this.origin,
            href: this.href
        };
    }
    constructor(url, base){
        _URL_hash.set(this, "");
        _URL_hostname.set(this, "");
        _URL_pathname.set(this, "");
        _URL_port.set(this, "");
        _URL_protocol.set(this, "");
        _URL_search.set(this, "");
        if (!isString(url)) url = String(url);
        const parseResult = parseUrlBase(url, base);
        const { hash , hostname , pathname , port , protocol , search  } = parseResult;
        __classPrivateFieldSet(this, _URL_hash, hash, "f");
        __classPrivateFieldSet(this, _URL_hostname, hostname, "f");
        __classPrivateFieldSet(this, _URL_pathname, pathname || "/", "f");
        __classPrivateFieldSet(this, _URL_port, port, "f");
        __classPrivateFieldSet(this, _URL_protocol, protocol, "f");
        __classPrivateFieldSet(this, _URL_search, search, "f");
    }
};
_URL_hash = /* @__PURE__ */ new WeakMap(), _URL_hostname = /* @__PURE__ */ new WeakMap(), _URL_pathname = /* @__PURE__ */ new WeakMap(), _URL_port = /* @__PURE__ */ new WeakMap(), _URL_protocol = /* @__PURE__ */ new WeakMap(), _URL_search = /* @__PURE__ */ new WeakMap();
function parseUrl(url = "") {
    const result = {
        href: "",
        origin: "",
        protocol: "",
        hostname: "",
        host: "",
        port: "",
        pathname: "",
        search: "",
        hash: ""
    };
    if (!url || !isString(url)) return result;
    url = url.trim();
    const PATTERN = /^(([^:/?#]+):)?\/\/(([^/?#]+):(.+)@)?([^/?#:]*)(:(\d+))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    const matches = url.match(PATTERN);
    if (!matches) return result;
    result.protocol = matches[1] || "https:";
    result.hostname = matches[6] || "taro.com";
    result.port = matches[8] || "";
    result.pathname = matches[9] || "/";
    result.search = matches[10] || "";
    result.hash = matches[12] || "";
    result.href = url;
    result.origin = result.protocol + "//" + result.hostname;
    result.host = result.hostname + (result.port ? `:${result.port}` : "");
    return result;
}
function parseUrlBase(url, base) {
    const VALID_URL = /^(https?:)\/\//i;
    let fullUrl = "";
    let parsedBase = null;
    if (!isUndefined(base)) {
        base = String(base).trim();
        if (!VALID_URL.test(base)) throw new TypeError(`Failed to construct 'URL': Invalid base URL`);
        parsedBase = parseUrl(base);
    }
    url = String(url).trim();
    if (VALID_URL.test(url)) {
        fullUrl = url;
    } else if (parsedBase) {
        if (url) {
            if (url.startsWith("//")) {
                fullUrl = parsedBase.protocol + url;
            } else {
                fullUrl = parsedBase.origin + (url.startsWith("/") ? url : `/${url}`);
            }
        } else {
            fullUrl = parsedBase.href;
        }
    } else {
        throw new TypeError(`Failed to construct 'URL': Invalid URL`);
    }
    return parseUrl(fullUrl);
}
var document$1;
if (false) {
    let createDocument = function() {
        const doc = new TaroDocument();
        const documentCreateElement = doc.createElement.bind(doc);
        const html = documentCreateElement(HTML);
        const head = documentCreateElement(HEAD);
        const body = documentCreateElement(BODY);
        const app = documentCreateElement(APP);
        app.id = APP;
        const container = documentCreateElement(CONTAINER);
        doc.appendChild(html);
        html.appendChild(head);
        html.appendChild(body);
        body.appendChild(container);
        container.appendChild(app);
        doc.documentElement = html;
        doc.head = head;
        doc.body = body;
        return doc;
    };
    document$1 = env.document = createDocument();
} else {
    document$1 = env.document;
}
function getComputedStyle(element) {
    return element.style;
}
var eventCenter = hooks.call("getEventCenter", Events);
var RuntimeCache = class {
    has(identifier) {
        return this.cache.has(identifier);
    }
    set(identifier, ctx) {
        if (identifier && ctx) {
            this.cache.set(identifier, ctx);
        }
    }
    get(identifier) {
        if (this.has(identifier)) return this.cache.get(identifier);
    }
    delete(identifier) {
        this.cache.delete(identifier);
    }
    constructor(name){
        this.cache = /* @__PURE__ */ new Map();
        this.name = name;
    }
};
var _History_instances;
var _History_location;
var _History_stack;
var _History_cur;
var _History_window;
var _History_reset;
var cache$1 = new RuntimeCache("history");
var History = class extends Events {
    get length() {
        return __classPrivateFieldGet(this, _History_stack, "f").length;
    }
    get state() {
        return __classPrivateFieldGet(this, _History_stack, "f")[__classPrivateFieldGet(this, _History_cur, "f")];
    }
    go(delta) {
        if (!isNumber(delta) || isNaN(delta)) return;
        let targetIdx = __classPrivateFieldGet(this, _History_cur, "f") + delta;
        targetIdx = Math.min(Math.max(targetIdx, 0), this.length - 1);
        __classPrivateFieldSet(this, _History_cur, targetIdx, "f");
        __classPrivateFieldGet(this, _History_location, "f").trigger("__set_href_without_history__", __classPrivateFieldGet(this, _History_stack, "f")[__classPrivateFieldGet(this, _History_cur, "f")].url);
        __classPrivateFieldGet(this, _History_window, "f").trigger("popstate", __classPrivateFieldGet(this, _History_stack, "f")[__classPrivateFieldGet(this, _History_cur, "f")]);
    }
    back() {
        this.go(-1);
    }
    forward() {
        this.go(1);
    }
    pushState(state, title, url) {
        if (!url || !isString(url)) return;
        __classPrivateFieldSet(this, _History_stack, __classPrivateFieldGet(this, _History_stack, "f").slice(0, __classPrivateFieldGet(this, _History_cur, "f") + 1), "f");
        __classPrivateFieldGet(this, _History_stack, "f").push({
            state,
            title,
            url
        });
        __classPrivateFieldSet(this, _History_cur, this.length - 1, "f");
        __classPrivateFieldGet(this, _History_location, "f").trigger("__set_href_without_history__", url);
    }
    replaceState(state, title, url) {
        if (!url || !isString(url)) return;
        __classPrivateFieldGet(this, _History_stack, "f")[__classPrivateFieldGet(this, _History_cur, "f")] = {
            state,
            title,
            url
        };
        __classPrivateFieldGet(this, _History_location, "f").trigger("__set_href_without_history__", url);
    }
    get cache() {
        return cache$1;
    }
    constructor(location2, options2){
        super();
        _History_instances.add(this);
        _History_location.set(this, void 0);
        _History_stack.set(this, []);
        _History_cur.set(this, 0);
        _History_window.set(this, void 0);
        __classPrivateFieldSet(this, _History_window, options2.window, "f");
        __classPrivateFieldSet(this, _History_location, location2, "f");
        __classPrivateFieldGet(this, _History_location, "f").on("__record_history__", (href)=>{
            var _a;
            __classPrivateFieldSet(this, _History_cur, (_a = __classPrivateFieldGet(this, _History_cur, "f"), _a++, _a), "f");
            __classPrivateFieldSet(this, _History_stack, __classPrivateFieldGet(this, _History_stack, "f").slice(0, __classPrivateFieldGet(this, _History_cur, "f")), "f");
            __classPrivateFieldGet(this, _History_stack, "f").push({
                state: null,
                title: "",
                url: href
            });
        }, null);
        __classPrivateFieldGet(this, _History_location, "f").on("__reset_history__", (href)=>{
            __classPrivateFieldGet(this, _History_instances, "m", _History_reset).call(this, href);
        }, null);
        this.on(CONTEXT_ACTIONS.INIT, ()=>{
            __classPrivateFieldGet(this, _History_instances, "m", _History_reset).call(this);
        }, null);
        this.on(CONTEXT_ACTIONS.RESTORE, (pageId2)=>{
            cache$1.set(pageId2, {
                location: __classPrivateFieldGet(this, _History_location, "f"),
                stack: __classPrivateFieldGet(this, _History_stack, "f").slice(),
                cur: __classPrivateFieldGet(this, _History_cur, "f")
            });
        }, null);
        this.on(CONTEXT_ACTIONS.RECOVER, (pageId2)=>{
            if (cache$1.has(pageId2)) {
                const ctx = cache$1.get(pageId2);
                __classPrivateFieldSet(this, _History_location, ctx.location, "f");
                __classPrivateFieldSet(this, _History_stack, ctx.stack, "f");
                __classPrivateFieldSet(this, _History_cur, ctx.cur, "f");
            }
        }, null);
        this.on(CONTEXT_ACTIONS.DESTORY, (pageId2)=>{
            cache$1.delete(pageId2);
        }, null);
        __classPrivateFieldGet(this, _History_instances, "m", _History_reset).call(this);
    }
};
_History_location = /* @__PURE__ */ new WeakMap(), _History_stack = /* @__PURE__ */ new WeakMap(), _History_cur = /* @__PURE__ */ new WeakMap(), _History_window = /* @__PURE__ */ new WeakMap(), _History_instances = /* @__PURE__ */ new WeakSet(), _History_reset = function _History_reset2(href = "") {
    __classPrivateFieldSet(this, _History_stack, [
        {
            state: null,
            title: "",
            url: href || __classPrivateFieldGet(this, _History_location, "f").href
        }
    ], "f");
    __classPrivateFieldSet(this, _History_cur, 0, "f");
};
var Current = {
    app: null,
    router: null,
    page: null
};
var getCurrentInstance = ()=>Current;
var _Location_instances;
var _Location_url;
var _Location_noCheckUrl;
var _Location_window;
var _Location_reset;
var _Location_getPreValue;
var _Location_rollBack;
var _Location_recordHistory;
var _Location_checkUrlChange;
var INIT_URL = "https://taro.com";
var cache = new RuntimeCache("location");
var Location = class extends Events {
    get protocol() {
        return __classPrivateFieldGet(this, _Location_url, "f").protocol;
    }
    set protocol(val) {
        const REG = /^(http|https):$/i;
        if (!val || !isString(val) || !REG.test(val.trim())) return;
        val = val.trim();
        const preValue = __classPrivateFieldGet(this, _Location_instances, "m", _Location_getPreValue).call(this);
        __classPrivateFieldGet(this, _Location_url, "f").protocol = val;
        if (__classPrivateFieldGet(this, _Location_instances, "m", _Location_checkUrlChange).call(this, preValue)) __classPrivateFieldGet(this, _Location_instances, "m", _Location_recordHistory).call(this);
    }
    get host() {
        return __classPrivateFieldGet(this, _Location_url, "f").host;
    }
    set host(val) {
        if (!val || !isString(val)) return;
        val = val.trim();
        const preValue = __classPrivateFieldGet(this, _Location_instances, "m", _Location_getPreValue).call(this);
        __classPrivateFieldGet(this, _Location_url, "f").host = val;
        if (__classPrivateFieldGet(this, _Location_instances, "m", _Location_checkUrlChange).call(this, preValue)) __classPrivateFieldGet(this, _Location_instances, "m", _Location_recordHistory).call(this);
    }
    get hostname() {
        return __classPrivateFieldGet(this, _Location_url, "f").hostname;
    }
    set hostname(val) {
        if (!val || !isString(val)) return;
        val = val.trim();
        const preValue = __classPrivateFieldGet(this, _Location_instances, "m", _Location_getPreValue).call(this);
        __classPrivateFieldGet(this, _Location_url, "f").hostname = val;
        if (__classPrivateFieldGet(this, _Location_instances, "m", _Location_checkUrlChange).call(this, preValue)) __classPrivateFieldGet(this, _Location_instances, "m", _Location_recordHistory).call(this);
    }
    get port() {
        return __classPrivateFieldGet(this, _Location_url, "f").port;
    }
    set port(val) {
        const xVal = Number(val = val.trim());
        if (!isNumber(xVal) || xVal <= 0) return;
        const preValue = __classPrivateFieldGet(this, _Location_instances, "m", _Location_getPreValue).call(this);
        __classPrivateFieldGet(this, _Location_url, "f").port = val;
        if (__classPrivateFieldGet(this, _Location_instances, "m", _Location_checkUrlChange).call(this, preValue)) __classPrivateFieldGet(this, _Location_instances, "m", _Location_recordHistory).call(this);
    }
    get pathname() {
        return __classPrivateFieldGet(this, _Location_url, "f").pathname;
    }
    set pathname(val) {
        if (!val || !isString(val)) return;
        val = val.trim();
        const preValue = __classPrivateFieldGet(this, _Location_instances, "m", _Location_getPreValue).call(this);
        __classPrivateFieldGet(this, _Location_url, "f").pathname = val;
        if (__classPrivateFieldGet(this, _Location_instances, "m", _Location_checkUrlChange).call(this, preValue)) __classPrivateFieldGet(this, _Location_instances, "m", _Location_recordHistory).call(this);
    }
    get search() {
        return __classPrivateFieldGet(this, _Location_url, "f").search;
    }
    set search(val) {
        if (!val || !isString(val)) return;
        val = val.trim();
        val = val.startsWith("?") ? val : `?${val}`;
        const preValue = __classPrivateFieldGet(this, _Location_instances, "m", _Location_getPreValue).call(this);
        __classPrivateFieldGet(this, _Location_url, "f").search = val;
        if (__classPrivateFieldGet(this, _Location_instances, "m", _Location_checkUrlChange).call(this, preValue)) __classPrivateFieldGet(this, _Location_instances, "m", _Location_recordHistory).call(this);
    }
    get hash() {
        return __classPrivateFieldGet(this, _Location_url, "f").hash;
    }
    set hash(val) {
        if (!val || !isString(val)) return;
        val = val.trim();
        val = val.startsWith("#") ? val : `#${val}`;
        const preValue = __classPrivateFieldGet(this, _Location_instances, "m", _Location_getPreValue).call(this);
        __classPrivateFieldGet(this, _Location_url, "f").hash = val;
        if (__classPrivateFieldGet(this, _Location_instances, "m", _Location_checkUrlChange).call(this, preValue)) __classPrivateFieldGet(this, _Location_instances, "m", _Location_recordHistory).call(this);
    }
    get href() {
        return __classPrivateFieldGet(this, _Location_url, "f").href;
    }
    set href(val) {
        const REG = /^(http:|https:)?\/\/.+/;
        if (!val || !isString(val) || !REG.test(val = val.trim())) return;
        const preValue = __classPrivateFieldGet(this, _Location_instances, "m", _Location_getPreValue).call(this);
        __classPrivateFieldGet(this, _Location_url, "f").href = val;
        if (__classPrivateFieldGet(this, _Location_instances, "m", _Location_checkUrlChange).call(this, preValue)) __classPrivateFieldGet(this, _Location_instances, "m", _Location_recordHistory).call(this);
    }
    get origin() {
        return __classPrivateFieldGet(this, _Location_url, "f").origin;
    }
    set origin(val) {
        const REG = /^(http:|https:)?\/\/.+/;
        if (!val || !isString(val) || !REG.test(val = val.trim())) return;
        const preValue = __classPrivateFieldGet(this, _Location_instances, "m", _Location_getPreValue).call(this);
        __classPrivateFieldGet(this, _Location_url, "f").origin = val;
        if (__classPrivateFieldGet(this, _Location_instances, "m", _Location_checkUrlChange).call(this, preValue)) __classPrivateFieldGet(this, _Location_instances, "m", _Location_recordHistory).call(this);
    }
    assign() {
        warn(true, "\u5C0F\u7A0B\u5E8F\u73AF\u5883\u4E2D\u8C03\u7528location.assign()\u65E0\u6548.");
    }
    reload() {
        warn(true, "\u5C0F\u7A0B\u5E8F\u73AF\u5883\u4E2D\u8C03\u7528location.reload()\u65E0\u6548.");
    }
    replace(url) {
        this.trigger("__set_href_without_history__", url);
    }
    toString() {
        return this.href;
    }
    get cache() {
        return cache;
    }
    constructor(options2){
        super();
        _Location_instances.add(this);
        _Location_url.set(this, new URL(INIT_URL));
        _Location_noCheckUrl.set(this, false);
        _Location_window.set(this, void 0);
        __classPrivateFieldSet(this, _Location_window, options2.window, "f");
        __classPrivateFieldGet(this, _Location_instances, "m", _Location_reset).call(this);
        this.on("__set_href_without_history__", (href)=>{
            __classPrivateFieldSet(this, _Location_noCheckUrl, true, "f");
            const lastHash = __classPrivateFieldGet(this, _Location_url, "f").hash;
            __classPrivateFieldGet(this, _Location_url, "f").href = generateFullUrl(href);
            if (lastHash !== __classPrivateFieldGet(this, _Location_url, "f").hash) {
                __classPrivateFieldGet(this, _Location_window, "f").trigger("hashchange");
            }
            __classPrivateFieldSet(this, _Location_noCheckUrl, false, "f");
        }, null);
        this.on(CONTEXT_ACTIONS.INIT, ()=>{
            __classPrivateFieldGet(this, _Location_instances, "m", _Location_reset).call(this);
        }, null);
        this.on(CONTEXT_ACTIONS.RESTORE, (pageId2)=>{
            cache.set(pageId2, {
                lastHref: this.href
            });
        }, null);
        this.on(CONTEXT_ACTIONS.RECOVER, (pageId2)=>{
            if (cache.has(pageId2)) {
                const ctx = cache.get(pageId2);
                __classPrivateFieldSet(this, _Location_noCheckUrl, true, "f");
                __classPrivateFieldGet(this, _Location_url, "f").href = ctx.lastHref;
                __classPrivateFieldSet(this, _Location_noCheckUrl, false, "f");
            }
        }, null);
        this.on(CONTEXT_ACTIONS.DESTORY, (pageId2)=>{
            cache.delete(pageId2);
        }, null);
    }
};
_Location_url = /* @__PURE__ */ new WeakMap(), _Location_noCheckUrl = /* @__PURE__ */ new WeakMap(), _Location_window = /* @__PURE__ */ new WeakMap(), _Location_instances = /* @__PURE__ */ new WeakSet(), _Location_reset = function _Location_reset2() {
    const Current2 = getCurrentInstance();
    const router = Current2.router;
    if (router) {
        const { path , params  } = router;
        const searchArr = Object.keys(params).map((key)=>{
            return `${key}=${params[key]}`;
        });
        const searchStr = searchArr.length > 0 ? "?" + searchArr.join("&") : "";
        const url = `${INIT_URL}${path.startsWith("/") ? path : "/" + path}${searchStr}`;
        __classPrivateFieldSet(this, _Location_url, new URL(url), "f");
        this.trigger("__reset_history__", this.href);
    }
}, _Location_getPreValue = function _Location_getPreValue2() {
    return __classPrivateFieldGet(this, _Location_url, "f")._toRaw();
}, _Location_rollBack = function _Location_rollBack2(href) {
    __classPrivateFieldGet(this, _Location_url, "f").href = href;
}, _Location_recordHistory = function _Location_recordHistory2() {
    this.trigger("__record_history__", this.href);
}, _Location_checkUrlChange = function _Location_checkUrlChange2(preValue) {
    if (__classPrivateFieldGet(this, _Location_noCheckUrl, "f")) {
        return false;
    }
    const { protocol , hostname , port , pathname , search , hash  } = __classPrivateFieldGet(this, _Location_url, "f")._toRaw();
    if (protocol !== preValue.protocol || hostname !== preValue.hostname || port !== preValue.port) {
        __classPrivateFieldGet(this, _Location_instances, "m", _Location_rollBack).call(this, preValue.href);
        return false;
    }
    if (pathname !== preValue.pathname) {
        return true;
    }
    if (search !== preValue.search) {
        return true;
    }
    if (hash !== preValue.hash) {
        __classPrivateFieldGet(this, _Location_window, "f").trigger("hashchange");
        return true;
    }
    __classPrivateFieldGet(this, _Location_instances, "m", _Location_rollBack).call(this, preValue.href);
    return false;
};
function generateFullUrl(val = "") {
    const origin = INIT_URL;
    if (/^[/?#]/.test(val)) {
        return origin + val;
    }
    return val;
}
var machine = "Macintosh";
var arch = "Intel Mac OS X 10_14_5";
var engine = "AppleWebKit/534.36 (KHTML, like Gecko) NodeJS/v4.1.0 Chrome/76.0.3809.132 Safari/534.36";
var msg = "(" + machine + "; " + arch + ") " + engine;
var nav = true ? env.window.navigator : {
    appCodeName: "Mozilla",
    appName: "Netscape",
    appVersion: "5.0 " + msg,
    cookieEnabled: true,
    mimeTypes: [],
    onLine: true,
    platform: "MacIntel",
    plugins: [],
    product: "Taro",
    productSub: "20030107",
    userAgent: "Mozilla/5.0 " + msg,
    vendor: "Joyent",
    vendorSub: ""
};
var now;
(function() {
    let loadTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
        now = ()=>performance.now();
    } else if (Date.now) {
        loadTime = Date.now();
        now = ()=>Date.now() - loadTime;
    } else {
        loadTime = new Date().getTime();
        now = ()=>new Date().getTime() - loadTime;
    }
})();
var lastTime = 0;
var _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame !== null ? requestAnimationFrame : function(callback) {
    const _now = now();
    const nextTime = Math.max(lastTime + 16, _now);
    return setTimeout(function() {
        callback(lastTime = nextTime);
    }, nextTime - _now);
};
var _caf = typeof cancelAnimationFrame !== "undefined" && cancelAnimationFrame !== null ? cancelAnimationFrame : function(seed) {
    clearTimeout(seed);
};
var window$1;
if (false) {
    class Window extends Events {
        initEvent() {
            const _location = this.location;
            const _history = this.history;
            this.on(CONTEXT_ACTIONS.INIT, (pageId2)=>{
                _location.trigger(CONTEXT_ACTIONS.INIT, pageId2);
            }, null);
            this.on(CONTEXT_ACTIONS.RECOVER, (pageId2)=>{
                _location.trigger(CONTEXT_ACTIONS.RECOVER, pageId2);
                _history.trigger(CONTEXT_ACTIONS.RECOVER, pageId2);
            }, null);
            this.on(CONTEXT_ACTIONS.RESTORE, (pageId2)=>{
                _location.trigger(CONTEXT_ACTIONS.RESTORE, pageId2);
                _history.trigger(CONTEXT_ACTIONS.RESTORE, pageId2);
            }, null);
            this.on(CONTEXT_ACTIONS.DESTORY, (pageId2)=>{
                _location.trigger(CONTEXT_ACTIONS.DESTORY, pageId2);
                _history.trigger(CONTEXT_ACTIONS.DESTORY, pageId2);
            }, null);
        }
        get document() {
            return env.document;
        }
        addEventListener(event, callback) {
            if (!isString(event)) return;
            this.on(event, callback, null);
        }
        removeEventListener(event, callback) {
            if (!isString(event)) return;
            this.off(event, callback, null);
        }
        setTimeout(...args) {
            return setTimeout(...args);
        }
        clearTimeout(...args) {
            return clearTimeout(...args);
        }
        constructor(){
            super();
            this.navigator = nav;
            this.requestAnimationFrame = _raf;
            this.cancelAnimationFrame = _caf;
            this.getComputedStyle = getComputedStyle;
            const globalProperties = [
                ...Object.getOwnPropertyNames(global || {}),
                ...Object.getOwnPropertySymbols(global || {})
            ];
            globalProperties.forEach((property)=>{
                if (property === "atob" || property === "document") return;
                if (!Object.prototype.hasOwnProperty.call(this, property)) {
                    this[property] = global[property];
                }
            });
            this.Date || (this.Date = Date);
            this.location = new Location({
                window: this
            });
            this.history = new History(this.location, {
                window: this
            });
            this.initEvent();
        }
    }
    window$1 = env.window = new Window();
} else {
    window$1 = env.window;
}
var location = window$1.location;
var history = window$1.history;
var SVGElement = class extends TaroElement {
};
var instances = /* @__PURE__ */ new Map();
var pageId = incrementId();
function injectPageInstance(inst, id) {
    hooks.call("mergePageInstance", instances.get(id), inst);
    instances.set(id, inst);
}
function getPageInstance(id) {
    return instances.get(id);
}
function removePageInstance(id) {
    instances.delete(id);
}
function addLeadingSlash(path) {
    if (path == null) {
        return "";
    }
    return path.charAt(0) === "/" ? path : "/" + path;
}
function safeExecute(path, lifecycle, ...args) {
    const instance = instances.get(path);
    if (instance == null) {
        return;
    }
    const func = hooks.call("getLifecycle", instance, lifecycle);
    if (isArray(func)) {
        const res = func.map((fn)=>fn.apply(instance, args));
        return res[0];
    }
    if (!isFunction(func)) {
        return;
    }
    return func.apply(instance, args);
}
function stringify(obj) {
    if (obj == null) {
        return "";
    }
    const path = Object.keys(obj).map((key)=>{
        return key + "=" + obj[key];
    }).join("&");
    return path === "" ? path : "?" + path;
}
function getPath(id, options2) {
    const idx = id.indexOf("?");
    if (true) {
        return `${idx > -1 ? id.substring(0, idx) : id}${stringify((options2 === null || options2 === void 0 ? void 0 : options2.stamp) ? {
            stamp: options2.stamp
        } : {})}`;
    } else {
        return `${idx > -1 ? id.substring(0, idx) : id}${stringify(options2)}`;
    }
}
function getOnReadyEventKey(path) {
    return path + "." + ON_READY;
}
function getOnShowEventKey(path) {
    return path + "." + ON_SHOW;
}
function getOnHideEventKey(path) {
    return path + "." + ON_HIDE;
}
function createPageConfig(component, pageName, data, pageConfig) {
    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${pageId()}`;
    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES] = hooks.call("getMiniLifecycleImpl").page;
    let pageElement = null;
    let unmounting = false;
    let prepareMountList = [];
    function setCurrentRouter(page) {
        const router = true ? page.$taroPath : page.route || page.__route__ || page.$taroPath;
        Current.router = {
            params: page.$taroParams,
            path: addLeadingSlash(router),
            $taroPath: page.$taroPath,
            onReady: getOnReadyEventKey(id),
            onShow: getOnShowEventKey(id),
            onHide: getOnHideEventKey(id)
        };
        if (!isUndefined(page.exitState)) {
            Current.router.exitState = page.exitState;
        }
    }
    let loadResolver;
    let hasLoaded;
    const config = {
        [ONLOAD] (options2 = {}, cb) {
            hasLoaded = new Promise((resolve)=>{
                loadResolver = resolve;
            });
            perf.start(PAGE_INIT);
            Current.page = this;
            this.config = pageConfig || {};
            const uniqueOptions = Object.assign({}, options2, {
                $taroTimestamp: Date.now()
            });
            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);
            if (true) {
                config.path = $taroPath;
            }
            if (this.$taroParams == null) {
                this.$taroParams = uniqueOptions;
            }
            setCurrentRouter(this);
            if (false) {
                window$1.trigger(CONTEXT_ACTIONS.INIT, $taroPath);
            }
            const mount = ()=>{
                Current.app.mount(component, $taroPath, ()=>{
                    pageElement = env.document.getElementById($taroPath);
                    ensure(pageElement !== null, "\u6CA1\u6709\u627E\u5230\u9875\u9762\u5B9E\u4F8B\u3002");
                    safeExecute($taroPath, ON_LOAD, this.$taroParams);
                    loadResolver();
                    if (false) {
                        pageElement.ctx = this;
                        pageElement.performUpdate(true, cb);
                    } else {
                        isFunction(cb) && cb();
                    }
                });
            };
            if (unmounting) {
                prepareMountList.push(mount);
            } else {
                mount();
            }
        },
        [ONUNLOAD] () {
            const $taroPath = this.$taroPath;
            if (false) {
                window$1.trigger(CONTEXT_ACTIONS.DESTORY, $taroPath);
            }
            safeExecute($taroPath, ONUNLOAD);
            unmounting = true;
            Current.app.unmount($taroPath, ()=>{
                unmounting = false;
                instances.delete($taroPath);
                if (pageElement) {
                    pageElement.ctx = null;
                    pageElement = null;
                }
                if (prepareMountList.length) {
                    prepareMountList.forEach((fn)=>fn());
                    prepareMountList = [];
                }
            });
        },
        [ONREADY] () {
            hasLoaded.then(()=>{
                safeExecute(this.$taroPath, ON_READY);
                _raf(()=>eventCenter.trigger(getOnReadyEventKey(id)));
                this.onReady.called = true;
            });
        },
        [ONSHOW] (options2 = {}) {
            hasLoaded.then(()=>{
                Current.page = this;
                setCurrentRouter(this);
                if (false) {
                    window$1.trigger(CONTEXT_ACTIONS.RECOVER, this.$taroPath);
                }
                safeExecute(this.$taroPath, ON_SHOW, options2);
                _raf(()=>eventCenter.trigger(getOnShowEventKey(id)));
            });
        },
        [ONHIDE] () {
            if (false) {
                window$1.trigger(CONTEXT_ACTIONS.RESTORE, this.$taroPath);
            }
            if (Current.page === this) {
                Current.page = null;
                Current.router = null;
            }
            safeExecute(this.$taroPath, ON_HIDE);
            eventCenter.trigger(getOnHideEventKey(id));
        }
    };
    LIFECYCLES.forEach((lifecycle)=>{
        config[lifecycle] = function() {
            return safeExecute(this.$taroPath, lifecycle, ...arguments);
        };
    });
    SIDE_EFFECT_LIFECYCLES.forEach((lifecycle)=>{
        var _a;
        if (component[lifecycle] || ((_a = component.prototype) === null || _a === void 0 ? void 0 : _a[lifecycle]) || component[lifecycle.replace(/^on/, "enable")]) {
            config[lifecycle] = function(...args) {
                var _a2;
                const target = (_a2 = args[0]) === null || _a2 === void 0 ? void 0 : _a2.target;
                if (target === null || target === void 0 ? void 0 : target.id) {
                    const id2 = target.id;
                    const element = env.document.getElementById(id2);
                    if (element) {
                        target.dataset = element.dataset;
                    }
                }
                return safeExecute(this.$taroPath, lifecycle, ...args);
            };
        }
    });
    config.eh = eventHandler;
    if (!isUndefined(data)) {
        config.data = data;
    }
    hooks.call("modifyPageObject", config);
    return config;
}
function createComponentConfig(component, componentName, data) {
    const id = componentName !== null && componentName !== void 0 ? componentName : `taro_component_${pageId()}`;
    let componentElement = null;
    const [ATTACHED, DETACHED] = hooks.call("getMiniLifecycleImpl").component;
    const config = {
        [ATTACHED] () {
            var _a;
            perf.start(PAGE_INIT);
            const path = getPath(id, {
                id: ((_a = this.getPageId) === null || _a === void 0 ? void 0 : _a.call(this)) || pageId()
            });
            Current.app.mount(component, path, ()=>{
                componentElement = env.document.getElementById(path);
                ensure(componentElement !== null, "\u6CA1\u6709\u627E\u5230\u7EC4\u4EF6\u5B9E\u4F8B\u3002");
                this.$taroInstances = instances.get(path);
                safeExecute(path, ON_LOAD);
                if (false) {
                    componentElement.ctx = this;
                    componentElement.performUpdate(true);
                }
            });
        },
        [DETACHED] () {
            const path = getPath(id, {
                id: this.getPageId()
            });
            Current.app.unmount(path, ()=>{
                instances.delete(path);
                if (componentElement) {
                    componentElement.ctx = null;
                }
            });
        },
        methods: {
            eh: eventHandler
        }
    };
    if (!isUndefined(data)) {
        config.data = data;
    }
    [
        OPTIONS,
        EXTERNAL_CLASSES,
        BEHAVIORS
    ].forEach((key)=>{
        var _a;
        config[key] = (_a = component[key]) !== null && _a !== void 0 ? _a : EMPTY_OBJ;
    });
    return config;
}
function createRecursiveComponentConfig(componentName) {
    const isCustomWrapper = componentName === CUSTOM_WRAPPER;
    const [ATTACHED, DETACHED] = hooks.call("getMiniLifecycleImpl").component;
    const lifeCycles = isCustomWrapper ? {
        [ATTACHED] () {
            var _a, _b;
            const componentId = ((_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);
            if (isString(componentId)) {
                customWrapperCache.set(componentId, this);
            }
        },
        [DETACHED] () {
            var _a, _b;
            const componentId = ((_a = this.data.i) === null || _a === void 0 ? void 0 : _a.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);
            if (isString(componentId)) {
                customWrapperCache.delete(componentId);
            }
        }
    } : EMPTY_OBJ;
    return Object.assign({
        properties: {
            i: {
                type: Object,
                value: {
                    ["nn"]: getComponentsAlias(internalComponents)[VIEW]._num
                }
            },
            l: {
                type: String,
                value: ""
            }
        },
        options: {
            addGlobalClass: true,
            virtualHost: !isCustomWrapper
        },
        methods: {
            eh: eventHandler
        }
    }, lifeCycles);
}
var nextTick = (cb, ctx)=>{
    var _a, _b, _c;
    const router = Current.router;
    const timerFunc = ()=>{
        setTimeout(function() {
            ctx ? cb.call(ctx) : cb();
        }, 1);
    };
    if (router !== null) {
        let pageElement = null;
        const path = router.$taroPath;
        pageElement = env.document.getElementById(path);
        if (pageElement === null || pageElement === void 0 ? void 0 : pageElement.pendingUpdate) {
            if (true) {
                (_c = (_b = (_a = pageElement.firstChild) === null || _a === void 0 ? void 0 : _a["componentOnReady"]) === null || _b === void 0 ? void 0 : _b.call(_a).then(()=>{
                    timerFunc();
                })) !== null && _c !== void 0 ? _c : timerFunc();
            } else {
                pageElement.enqueueUpdateCallback(cb, ctx);
            }
        } else {
            timerFunc();
        }
    } else {
        timerFunc();
    }
};
export { Events, isFunction, isArray, hooks, EMPTY_OBJ, ensure, MutationObserver, incrementId, eventSource, hydrate, TaroNode, Style, TaroElement, options, TaroEvent, createEvent, eventHandler, FormElement, TaroRootElement, TaroText, URLSearchParams, URL, parseUrl, document$1, getComputedStyle, eventCenter, History, Current, getCurrentInstance, Location, nav, now, _raf, _caf, window$1, location, history, SVGElement, injectPageInstance, getPageInstance, removePageInstance, addLeadingSlash, safeExecute, stringify, createPageConfig, createComponentConfig, createRecursiveComponentConfig, nextTick };
